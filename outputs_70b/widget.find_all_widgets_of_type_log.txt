
================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Target types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:21.6037
 :20.1293
 fun:19.4215
 ?:15.485
    :15.139
 #:15.117
  :14.9796
        :13.8191
 //:13.643
 @:13.4257
                :13.3822
 function:13.1067
     :13.0489
      :12.9899
 undefined:12.9215
 {:12.8959
 not:12.8109
 \:12.7892
   :12.7655
 f:12.7283
 rec:12.6782

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Target types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 :25.6833
   :24.5441
fun:22.8329
  :20.3958
       :20.3601
	:19.9774
 fun:19.6172
     :19.6168
    :18.7663
           :17.4446

:17.2281
let:16.7463
#:16.6305
                :16.4628
         :16.4204
      :16.2373
               :15.9864
        :15.0477
function:14.8207
f:14.753
 let:14.6962

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
 

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
 
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Target types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:24.8299
 let:19.1953
 #:18.1013
 rec:15.6846
 function:15.5328
 @:15.2809
 fn:15.0239
 ?:14.8955
 func:14.2835
 f:13.9727
 (:13.8713
 pass:13.8439
 |:13.7802
 error:13.3358
 m:13.3107
	:13.3031
 {:13.1121
 match:13.0758
 (*:13.0753
 //:12.9553
 var:12.8566

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 widget:21.7058
 root:20.3953
 w:19.7465
 parent:17.5783
 tree:17.04
 node:17.0013
 container:16.1053
 initial:16.0587
 base:16.0376
 x:15.9527
 outer:15.8968
 start:15.8087
 current:15.6716
 input:15.6119
 top:15.5324
 main:15.4629
 wid:15.2548
 target:14.9858
 init:14.9476
 layout:14.7843
 element:14.7381

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: (Widget, (Widget -> Bool)), find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widget
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:22.6165
_:17.4652
 ->:17.3854
s:17.2029
To:16.0163
0:15.9402
Of:15.8872
1:15.8826
_,:15.6314
Type:15.619
 ,:15.5707
::15.4861
',:14.7618
 =>:14.2469
 type:13.9125
->:13.8128
 ::13.7767
':13.1362
A:13.0377
Pred:13.0181
List:12.9987

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 f:19.7234
 predicate:19.1797
 test:18.7843
 pred:17.695
 is:17.5843
 p:17.4686
 filter:17.167
 type:17.0561
 match:16.6298
 condition:16.0295
 check:15.7042
 cond:15.036
 matches:15.0246
 widget:14.9982
 selector:14.9581
 t:14.7018
 should:14.7017
 typ:14.6902
 func:14.3189
 target:14.3185
 ty:14.2959

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <f>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: f
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: f
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:22.7709
->:17.9453
 =>:17.0566
 :16.3891
_:16.2208
,:15.5182
':15.4898
st:15.2904
 when:15.2557

:14.9651
 as:14.5196
w:14.3186
1:14.1879
::13.6446
2:13.6432
(:13.4588
 =:13.4138
c:13.3639
 -:13.3606
?:13.3106
 |:13.2517

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:

:22.1794
 :19.6279
 case:18.2027
 []:17.2759
  :17.1727
    :17.1544
 #:17.1435
 List:16.5321
 match:16.4725
 let:16.2134
        :15.9385
      :15.6786
 if:15.5212
                :15.2996
 {:15.252
     :15.115
 ?:15.0189
 [:14.9374
            :14.7759
       :14.7334
   :14.6556

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
   :24.1544
     :23.0032
 :21.1312
       :20.895
    :20.411
  :19.8558
	:19.6318

:18.9759
#:18.7129
let:18.1843
case:18.0925
end:17.9334
      :17.8231
         :17.1599
           :17.0699
if:16.8558
{:16.345
        :15.6836
match:15.627
                :14.941
               :14.8064

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
   

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
   
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 case:22.9231
 let:22.5081
 if:21.8066
 #:18.9701
 match:18.921
 List:17.8158
 []:17.182
 fun:15.9551
 [:15.7368
 (:15.1971
 acc:14.785
 rec:14.7717
 ():14.6518
 #[:14.6115
 var:14.3722
 //:14.3651
 func:14.2974
 @:14.2916
 {:14.1264
 fn:14.1049
 fl:13.9692

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 widget:22.1835
 f:18.0187
 List:16.4103
 (:14.9032

:14.773
 #:14.1598
 get:13.8027
 is:13.6322
 true:13.622
 :13.6181
 Widget:13.4548
 String:13.4275
 type:13.3488
 match:13.2827
 {:12.9626
 ():12.9584
 []:12.8896
 True:12.6919
 if:12.6134
 [:12.5869
 as:12.5414

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:23.7858
 of:22.7436
 :21.2568
  :18.582
    :17.8982
 #:17.498
 |:16.4805
                :16.0349
.:15.9217
        :15.8495
 =>:15.8263
      :15.7749
 //:15.5474
   :15.5408
,:15.3158
     :15.2593
 match:15.1265
            :15.0103
	:14.8208
 ::14.712
::14.6674

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :26.396
     :25.8307
       :24.7437
    :22.5443
	:21.1232

:21.0696
      :20.4664
           :20.053
 :19.8909
         :19.6742
        :19.6136
|:19.4435
  :19.3118
#:18.7991
                :18.1831
             :17.6392
               :17.5335
 |:17.5111
          :17.3695
            :17.0944
              :15.7205

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
   

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
   
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:27.1437
 of:19.9099
 #:19.7111
 //:16.154
 ||:15.4351
 in:15.1888
 (*:15.0673
 match:14.7793
 {:14.7559
 is:14.682
 row:14.6655
 ##:14.6573
 -:14.606
 end:14.6036
 with:14.5423
 when:14.5373
 Text:14.5007
 ###:14.0035
 ::13.9274
 │:13.895
 /:13.82

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    |

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    |
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Text:21.676
 Column:19.4226
 Container:17.7667
 w:15.9574
 #:15.9549
 Row:15.7594
 _:15.6695
 widget:14.683
 (:14.6614
 Widget:14.4608
 x:14.3906
 row:14.2
 text:14.0764
 column:13.8081
 t:13.581
 container:13.447
 P:12.7377
 Cont:12.6322
 a:12.5876
 :12.5803
 Col:12.5762

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ((String, [Attribute]) -> Widget)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow ((Prod [String; (List (Var "Attribute"))]), (Var "Widget")
              ))})))
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Text
Nature of error: Expecting type Widget but got inconsistent type ((String, [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Text
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Text
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:21.9194
(_:21.3716
 _:20.1717
 =>:18.5436
(":18.226
():17.6782
 ->:17.0477
((:16.7868
(__:16.1346
(*:15.1983
 _,:15.1932
 (:14.9391
(':14.7252
    :14.6274
($:14.6058
  :14.216
("#:13.9697
     :13.9544
   :13.9527
      :13.8731
 x:13.8458

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
_,:21.8199
text:20.0225
string:19.0983
value:18.6075
str:18.5439
content:18.1092
x:18.0986
t:17.3364
s:16.9729
txt:16.7153
data:16.5473
..:16.4701
label:16.2412
contents:16.0794
w:16.0031
a:15.7792
body:15.2514
inner:15.1861
name:15.1023
title:14.7689
v:14.5907
Rejected the highest logit candidate _, with logit 21.8199

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {text: (String, [Attribute]), f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: text
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: text
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:23.4272
):19.9328
_:18.3213
',:17.4779
1:17.164
Content:16.8797
::16.6593
ual:16.2252
Value:16.1829
_,:16.1707
2:16.1154
 ,:16.0145
String:15.8905
o:15.5969
0:15.5341
value:15.1088
'):15.0781
,[:14.8696
content:14.7908
s:14.764
string:14.7454

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "Margin" | "Padding" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 attributes:21.4745
 attr:20.568
 _):19.5577
 att:17.9644
 mod:16.6536
 [:15.9931
 attribute:15.8865
 _:15.556
 xs:15.4315
 styles:15.1896
 style:14.8525
 properties:14.624
 at:14.587
 alignment:14.5793
 props:14.5765
 align:14.3241
_):14.2425
 as:14.1404
 a:14.1323
 options:14.087
 text:14.0083

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: attributes
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
):24.396
)->:18.9215
),:18.8281
)::17.1909
,:17.0265
_):16.8806
 ):16.7049
 as:16.5507
1:16.4784
_:16.4207
)=:16.3716
)|:16.3474
::15.9546
);:15.1128
=:15.1073
'):15.0639
0:15.0146
 =:15.0136
2:14.8196
)):14.511
 @:14.3857

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:22.0529
 as:17.2832
 ->:17.2253
 if:16.8983

:14.7543
 when:14.5365
                :14.376
  :14.3351
 |:14.2814
     :14.2382
    :14.2306
 :14.1625
      :14.0107
       :13.9628
         :13.8498
        :13.805
           :13.5472
   :13.4874
          :13.3034
            :13.1888
             :12.7977

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) =>

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) =>
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 if:21.78
 []:19.5337

:19.2859
 List:18.3336
 [:17.8117
 :17.8032
 #:15.8315
 let:15.5152
 (:15.2253
 f:14.7663
 match:14.6072
  :14.5746
 find:14.2869
 ([:14.096
 list:14.0623
 case:14.0357
    :13.5768
 widget:13.5728
     :13.4717
 [],:13.1272
 [(:13.0631

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp f false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string text true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "String.reverse" | "String.starts_with" | "String.transform" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "text" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 f:22.3941
 List:18.9481
 (:17.2874
(:15.7348
 true:15.7299
f:15.273
 not:15.0564
 String:14.8457
 !:14.767
 contains:14.6789
 is:14.2958
 false:14.1444
 :13.809
 $:13.8046
 #:13.6809
 Widget:13.3543
_:13.3396
 match:13.1827
 Bool:13.1607
 @:13.1317
 bool:13.0705

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <f>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool; syn = (Arrow ((Var "Widget"), Bool))})))
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  f
Nature of error: Expecting type Bool but got inconsistent type (Widget -> Bool)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: f
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: f
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp f false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string text true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "alse" | "loat_of_int" | "loat_of_string" | "loor"
new-tokens ::= whitespace | "(" | "then"
root ::= completions | new-tokens

Top 20 Logits:
(:24.7831
 widget:19.8517
 then:18.5774
 (:17.8173
((:17.2658
(@:16.5356
 ==:15.7293
($:15.3061
(":15.1009
([:15.0593
():14.8776
.(:14.7491
({:14.689
.:14.482
 in:14.4547
widget:14.433
 match:14.2546
(\:13.9672
(_:13.9556
(&:13.6587
 &&:13.571

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp f false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string text true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "case " | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
Text:26.0681
widget:25.2012
self:17.7795
text:17.7787
container:17.6961
w:17.5862
Container:17.2871
case:16.9686
Widget:16.8076
this:16.6706
wid:16.5506
TextField:16.0728
Texture:15.962
TEXT:15.8642
word:15.8293
Term:15.7694
window:15.7178
 widget:15.7137
Column:15.7095
List:15.6893
row:15.5366

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ((String, [Attribute]) -> Widget)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow ((Prod [String; (List (Var "Attribute"))]), (Var "Widget")
              ))})))
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  Text
Nature of error: Expecting type Widget but got inconsistent type ((String, [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: Text
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((String, [Attribute]) -> Widget)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Text
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:23.2075
(":19.1278
("#:17.4878
):16.9258
.:16.8517
()):15.9764
([:15.8551
(@:15.6946
($:15.4922
((:14.7764
 (:14.6073
("<:14.45
(?:14.2959
(_:14.0497
("@:14.0079
2:13.9946
({:13.7315
)(:13.703
(':13.6777
{:13.6338
,:13.3186

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "String.reverse" | "String.transform" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "text" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
text:25.1199
String:18.3122
string:17.8822
attributes:17.58
_,:17.2161
#:16.7172
null:15.8006
t:15.4675
 text:15.4165
empty:15.3867
[":15.0206
nil:14.9931
0:14.9763
test:14.8485
name:14.8373
Text:14.7782
value:14.5925
#,:14.5107
x:14.4244
tex:14.3928
title:14.3692

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [String; (List (Var "Attribute"))]);
           syn = String})))
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  text
Nature of error: Expecting type (String, [Attribute]) but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: text
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is String
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: text
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is String
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "++" | ","
root ::= new-tokens

Top 20 Logits:
,:25.0095
)):18.6149
 ,:16.51
.:16.079
::15.7008
 @:15.4097
),:15.0621
,[:14.7936
:::14.5272
@:14.3549
[::13.7139
[:13.6911
,":13.5852
->:13.5396
_:13.3875
 [],:13.3697
 =:13.3098
 ::13.237
=:13.2131
 attributes:12.9921
)),:12.6714

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Margin" | "Padding" | "[" | "[]" | "attributes" | "case " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 attributes:23.6671
 []:20.9557
attributes:19.3117
 List:16.3737
 [:15.7375
 attribute:15.6914
[]:15.4743
 null:14.6796
 nil:14.6563
 attr:14.556
 :14.5084
 att:14.3809
 [],:14.1518
 list:13.9208
 Nil:13.8165
 properties:13.5778
 empty:13.5748
 at:13.5301
 #:13.3324
 Att:13.331
 (:13.2377

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: [Attribute]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Attribute]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: attributes
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
)):29.8516
)),:21.7296
):19.6229
),:19.3403
));:19.1864
))):18.9051
 :18.3917
::17.9151
))::17.9036
)){:17.4269
)::17.0118
 ::16.6715
)).:16.5703
,:16.3873
 ):15.9856
))\:15.6842
.:15.5649
))`:15.5386
)));:15.5143
 =:15.2622
())):15.1961
Rejected the highest logit candidate )) with logit 29.8516

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 then:18.9603
 ):17.9146
 as:16.3986
 ::15.6025
:::15.3487
 $:15.3203
 :::15.0669
 @:14.7055
 ==:14.2865
 #:13.9048

:13.7464
 ||:13.7206
 ->:13.5495
 ++:13.1042
 in:12.8223
 =>:12.6959
 :12.5476
then:12.5282
 =:12.4162
 end:12.3799
#:11.989
Rejected the highest logit candidate  then with logit 18.9603

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) )

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) )
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:22.9898
then:18.2238

:16.7928
 :16.7538
 ==:16.1171
 ||:15.6113
  :14.6312
 #:14.5256
 &&:14.1091
 <>:13.8997
 >:13.6381
 else:13.5809
 $:13.3992
==:13.2529
                :13.2513
    :13.0716
#:12.9852
 ):12.8544
>:12.7556
 than:12.5422
||:12.5214

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 [:20.6643

:18.3145
 List:18.0877
 Text:17.2485
 :16.9086
 []:16.7935
 #:15.7074
 let:15.1466
 widget:15.1387
 [(:14.9262
 ([:14.8274
  :14.5398
 [[:14.2888
 (:14.2783
[:14.0125
 #[:13.9187
 list:13.7828
 {:13.5449
 Widget:13.393
 return:13.275
 ?:13.1863

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "case " | "if " | "let " | "type " | "widget"
root ::= completions | new-tokens

Top 20 Logits:
Text:21.6496
widget:19.6981
 Text:19.2155
 widget:17.8326
|:15.7412
Widget:15.1808
 ]:14.8419

:14.6256
?:14.2586
text:13.8692
 (:13.6572
 Widget:13.4865
List:13.4301
TEXT:13.4001
TextBox:13.3855
#:13.3423
container:13.3364
 :13.3325
Container:13.2297
Texture:13.1374
  :13.0154

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ((String, [Attribute]) -> Widget)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow ((Prod [String; (List (Var "Attribute"))]), (Var "Widget")
              ))})))
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: ALL errors:
Error in term:
  Text
Nature of error: Expecting type Widget but got inconsistent type ((String, [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: Text
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((String, [Attribute]) -> Widget)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Text
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "]"
root ::= new-tokens

Top 20 Logits:
(:25.2373
(":19.4932
 (:19.2275
((:17.3314
($:16.6136
]:16.4643
("#:15.7671
.:15.7156
():15.3398
([:15.2532
[:14.8688
(_:14.5411
(@:14.4285
(':14.3666
 :13.9402
 ]:13.8981
 (":13.7488
{:13.7481
2:13.7153
_(:13.6593
](:13.6347

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "String.reverse" | "String.transform" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "text" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
text:25.2937
 text:20.9138
String:17.7919
attributes:17.5856
string:16.3586
Text:15.2858
  :15.1948
t:15.1327
x:14.8057
test:14.7852
_,:14.6878
 ":14.6785

:14.6471
value:14.5613
tex:14.5492
 :14.5301
name:14.2904
title:14.1627
content:14.1174
txt:13.8667
#:13.8184

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [String; (List (Var "Attribute"))]);
           syn = String})))
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: ALL errors:
Error in term:
  text
Nature of error: Expecting type (String, [Attribute]) but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: text
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is String
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: text
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is String
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "++" | ","
root ::= new-tokens

Top 20 Logits:
,:26.0206
 ,:19.7684
)]:19.2193
.:16.751
::16.0366
),:15.6201
):15.5929
 @:15.3468
_:14.4452
 ::14.0692
s:14.0616
@:13.969
 attributes:13.8031
 +:13.7844
:::13.6773
;:13.3478
,$:13.2984
->:13.2047
_,:13.1922

:13.1814
2:13.1803

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Margin" | "Padding" | "[" | "[]" | "attributes" | "case " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 attributes:23.1176
attributes:19.1792
 []:16.9752
 List:16.7362
 [:16.4027
 :15.0651
 attribute:14.5862
  :13.6183
 attr:13.3322
 att:13.2504
 null:12.9504

:12.9223
 list:12.8583
 Att:12.6995
    :12.6612
 properties:12.6368
 at:12.3617
 String:12.2296
 [],:12.2031
     :12.1287
 nil:12.0935

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: [Attribute]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Attribute]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: attributes
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
)]:27.2497
):23.9054
)];:19.3967
 ):18.9327
),:18.7836
)](:17.5053
)):17.2029
)::17.1333
]:17.018
))]:16.8204
);:16.7921
)}:16.7786
)|:16.4834
,:16.3356
]]:15.6121
 :15.5684
)>:15.4669
]):15.2599
)":15.0611
)->:15.0561
 ]]:15.0459
Rejected the highest logit candidate )] with logit 27.2497

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "]"
root ::= new-tokens

Top 20 Logits:
 ]:25.0373
 :17.294
  :16.7521
 ];:16.6523
 as:16.5501
 ,:15.6345
 else:15.3462

:15.3411
 }:15.2457
 ;:15.1766
 ::15.0439
 @:15.0135
    :14.9085
 :::14.8513
]):14.5404
 end:14.3122
                :14.2756
 |:14.2659
   :14.2377
 in:14.2179
][:14.1691

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ]

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ]
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:
 else:24.2716

:17.8828
 :17.7708
else:17.106
 end:16.9847
  :16.1881
 @:15.6089
 as:15.6084
                :15.3742
 ++:15.2848
 els:15.2309
    :14.931
 #:14.6175
      :14.4106
     :14.1314
   :14.1217
 +:13.9849
 el:13.7413
       :13.6571
 ::13.5414
 //:13.5185

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 []:22.8088
 [:17.0028
 :15.2289
 [];:15.0944
 List:14.7267
 nil:14.6228

:14.2873
[]:14.0492
 ([:13.6744
 let:13.3501
 Nil:13.1562
 [],:12.9691
 null:12.3904
 [[:12.1253
 error:12.1182
  :12.0758
 [":12.0632
 fail:12.0465
 list:11.9199
 #:11.8335
 end:11.7775

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:23.583
 :20.3366
  :19.6166
 end:19.1859
 #:18.8545
    :18.8376
                :17.5517
 @:17.5252
 in:17.4437
     :17.2853
      :17.2437
   :17.1427
 ++:16.9871
       :16.8705
        :16.5529
#:16.1351
            :16.023
          :15.8871
 |:15.7584
	:15.6809
           :15.5409

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :23.1739
    :18.7041

:17.6664
       :17.4325
	:17.0697
     :16.8453
#:16.4279
                :16.3581
end:15.8883
  :15.8453
|:15.5828
        :15.5171
      :15.2032
 :15.0687
           :14.6338
            :14.2934
in:14.0641
               :14.0421
         :13.882
          :13.4731
             :12.9116

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
   

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
   
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:25.8028
 #:21.5202
 end:19.2267
 +:18.3587
 (*:17.1606
 {:16.234
 //:15.7434
 else:15.605
 ~:15.5394
 ##:15.3138

:15.2638
 `:15.1611
 --:15.1288
 let:15.0201
 ++:14.8974
 ||:14.8676
 -:14.795
 #[:14.422
 >:14.2829
 %:14.2535
 {-:14.0062

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    |

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    |
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Column:24.1444
 Row:23.146
 Container:22.0704
 Col:16.6601
 Color:15.0573
 R:14.8674
 Cont:14.8195
 P:14.6982
 :14.5747
 C:14.5614
 Box:14.3686
 _:14.1832
 Con:13.9957
 Widget:13.9199
 F:13.8984
 column:13.8789
 Em:13.8504
 Button:13.8092
Column:13.7643
 Text:13.7233
 Center:13.6565

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Column>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow (
              (Prod
                 [(List
                     (Rec ("\206\177",
                        (Sum
                           [("Text",
                             (Some (Prod [String; (List (Var "Attribute"))])));
                             ("Column",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Row",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Container",
                              (Some (Prod
                                       [(Var "\206\177");
                                         (List (Var "Attribute"))])))
                             ])
                        )));
                   (List (Var "Attribute"))]),
              (Var "Widget")))})))
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Column
Nature of error: Expecting type Widget but got inconsistent type (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Column
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Column
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:24.1024
([:21.1012
(_:18.8012
 (:18.1735
((:18.0264
 ([:15.3729
 _:14.8886
 children:14.6405
  :14.4508
 :14.3974
(__:14.3335
[:13.9004
 ->:13.8864
():13.813
s:13.68
 widget:13.653
(*:13.3341
 layout:13.3173
    :13.2623
|:13.0189
 (_:12.9997

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
widget:21.6151
children:20.6815
columns:17.5361
xs:17.4901
child:17.3664
elements:17.2855
sub:17.1919
column:16.8841
ws:16.868
cs:16.815
contents:16.6416
content:16.542
items:16.3786
rows:16.044
w:15.4307
col:15.358
list:15.2831
cols:15.1926
inner:14.9694
_,:14.8684
body:14.5584

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widget
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
s:26.3357
List:19.2463
_:18.9718
,:18.0885
list:16.9559
1:16.9085
:::16.8611
Array:16.2965
Children:15.7451
Arr:15.3146
_,:15.1092
S:14.7959
ss:14.6708
2:14.5354
es:14.3661
0:14.3364
 :::14.2811
',:13.9669
Vec:13.5478
Tree:13.4945
Seq:13.4634

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widgets
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:24.0912
 ,:18.8899
1:17.9401
_:17.9152
',:17.8348
0:17.1823
):17.1496
_,:16.5972
::15.1658
  :14.9824
,[:14.6538
A:14.5553
    :14.4745
2:14.3015
     :14.268
In:14.211
List:14.0731
 =:13.9439
@:13.5036
 :13.4907
   :13.4525

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "Margin" | "Padding" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 attributes:21.0983
 _):18.9761
 attr:17.6821
 attribute:16.8737
 _:16.3246
 att:15.6117
attributes:15.4197
 [:14.9374
 properties:14.4037
 alignment:14.3986
 :14.3914
 column:14.0176
 at:13.9438
  :13.8584
_):13.8503
 align:13.8177
     :13.8171
    :13.7291
 a:13.6705
 widget:13.1931
 row:13.1672

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: attributes
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
):25.2249
)=:19.2977
 ):18.9873
)->:18.8765
)|:17.7284
1:17.4737
2:17.1216
_:17.0515
_):16.3868
0:16.0555
  :15.8937
),:15.7293
 as:15.4007
 :15.3197
::15.0812
,:15.0368
)::14.9856
 @:14.7788
)):14.7469
=:14.7354
'):14.5122

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.8673
 :14.5951

:14.3432
  :13.7571
 |:13.5528
 ->:13.0809
 or:13.0686
    :12.9872
 as:12.7794
 if:12.415
     :12.2906
      :12.2143
   :12.0611
 ||:11.8328
        :11.5862
=>:11.5816
                :11.4893
       :11.2542
 =:11.2075
         :11.0887
            :10.7581

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) =>

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) =>
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget" | "widgets"
root ::= new-tokens

Top 20 Logits:
 List:20.8171

:18.9629
 let:18.6701
 if:18.3047
 :18.254
 find:17.8886
 (:17.426
 [:16.3031
 #:16.1926
 widget:15.6517
  :15.5364
 []:15.3139
 conc:15.2447
 list:15.0172
 Array:14.7929
 ?:14.6087
 column:14.1257
 _:13.9481
 fl:13.7598
 match:13.6573
    :13.5093

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:26.9026
.(:19.4362
.@:17.1323
_:16.1937
.[:15.1089
.<:15.0394
::14.9723
(:14.1417
._:13.936
2:13.8874

:13.7725
((:13.6488
ing:13.2812
1:13.0369
@:12.87
(@:12.8455
.*:12.7789
..:12.7274
,:12.7134
Utils:12.6703
Util:12.6535

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "filter" | "fold_left" | "fold_right" | "init" | "rev" | "tl"
root ::= completions

Top 20 Logits:
fold:27.5714
concat:25.6635
filter:24.6593
fl:23.9596
init:23.4727
rev:23.1742
flat:22.8447
append:22.8002
map:21.6558
cons:20.8658
join:20.5086
collect:19.5475
merge:19.4275
con:19.2878
reduce:19.259
reverse:18.7011
find:18.3904
apply:18.0941
f:18.0114
tl:17.8439
fol:17.772

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold"))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.fold
Nature of error: Variable List.fold is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold
LSP: Generating Completions for prefix: List.fold
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_left" | "_right"
root ::= completions

Top 20 Logits:
_:29.0424
(:19.1167
r:18.9257
l:18.0365
Left:17.8554
Right:16.4937
i:16.2636
((:16.2344
left:16.0865
ing:16.0544
([:15.8392
right:15.5173
 (:15.4395

:15.2936
(@:15.0718
_(:14.5442
t:14.5423
-:14.5251
[:14.3926
ed:14.2647
():14.1379

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.fold_
Nature of error: Variable List.fold_ is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold_
LSP: Generating Completions for prefix: List.fold_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "left" | "right"
root ::= completions

Top 20 Logits:
left:32.2159
right:30.7293
rig:20.1678
lef:20.143
l:19.4071
flat:19.1017
Left:18.8919
append:18.7622
r:18.7489
bottom:18.691
list:18.6771
down:18.6444
map:18.4505
center:18.4214
concat:18.3939
LEFT:18.3769
Right:18.2858
let:18.2413
up:18.1914
with:17.755
add:17.7425

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_left>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Widget"));
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                     (Unknown TypeHole)));
                   (Unknown TypeHole); (List (Unknown TypeHole))]),
              (Unknown TypeHole)))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.fold_left
Nature of error: Expecting type [Widget] but got inconsistent type ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: List.fold_left
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: List.fold_left
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
((:25.6207
(:22.5143
(@:20.8936
 ((:20.2806
 (:20.0235
([:19.5601
(|:18.7467

:18.2336
($:17.831
(\:17.7681
({:17.56
(?:17.3356
(_:17.0227
(&:16.6164
(():16.482
 (@:16.1618
():15.913
(":15.5284
(::15.4103
(%:15.3005
(__:15.2732
Rejected the highest logit candidate (( with logit 25.6207

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Column Container List.cons List.contains List.filter List.fold_left List.fold_right List.init Row String.starts_with String.transform Text case  find_all_widgets_of_type fun  if  let  mod string_compare string_concat type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Abs" | "App" | "Column" | "Container" | "List.cons" | "List.contains" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "Row" | "String.starts_with" | "String.transform" | "Text" | "case " | "find_all_widgets_of_type" | "fun " | "if " | "let " | "mod" | "string_compare" | "string_concat" | "type "
root ::= new-tokens

Top 20 Logits:
fun:18.6141
List:16.585

:16.5313
fn:16.176
 (:16.1594
 fun:13.4341
concat:13.4117
 @:13.3567
 (@:13.3276
#:13.2665
 :12.9701
f:12.8422
func:12.7712
 fn:12.7707
 ((:12.4027
let:12.3205
Widget:12.2953
 #:12.2277
  :12.0139
compose:12.0067
append:11.9078

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun ? ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "Text" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:17.913
 xs:16.0104
 result:15.2522
 a:15.2166
 accum:14.8226
 l:14.7179
 x:14.4856
 (:14.4259
 widget:14.3369
 ws:14.0712
 children:13.9124
 found:13.7403
 w:13.6431
 results:13.3591
 res:13.302
 list:13.2682
 all:13.1821
 rest:12.8303
 y:12.8111
 r:12.4473
 sum:12.1582

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun acc ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:20.3346
u:17.0565
 w:15.803
 x:15.3352
1:15.1813
m:15.1772
_:14.9098
2:14.2826
 ->:14.2573
 ,:14.246
0:14.1709
',:14.1595
 widget:13.7753
::13.3618
s:13.285
 _,:13.1339
_,:13.1201
W:12.537
 column:12.4205
w:12.3332
 xs:12.2514

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "Text" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 w:20.4783
 x:19.1939
 widget:18.8055
 child:18.0292
 elem:17.5542
 e:17.3491
 curr:17.2288
 next:17.1413
 it:16.9032
 el:16.6319
 h:16.5573
 cur:16.4292
 wid:16.1805
 item:16.1525
 sub:16.128
 element:15.871
 current:15.5277
 a:15.4741
 row:15.433
 v:15.4302
 xs:15.3279

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <w>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: w
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: w
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:19.4692
 in:16.8085
::16.1
,:15.7358
d:15.7196
 =>:15.6545
i:15.4975
->:15.1987
g:15.1634
dl:14.717
gt:14.5911
dg:14.4178
':14.1536
 :13.606
1:13.6032
 =:13.4694
:::13.2169
t:13.0347
_:12.8964
dx:12.694
ig:12.3481

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w ->

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w ->
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "w" | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:17.4932
 find:16.5336
 if:15.0721
 List:15.068
 (:14.8332

:14.6106
 let:13.9816
 :13.7914
 w:13.5543
 #:13.5166
 [:12.7257
 fun:12.5035
 case:12.4774
 match:12.1288
 go:11.8002
 f:11.7644
acc:11.0093
 ((:10.942
 get:10.6168
 merge:10.5395
  :10.4541

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 @:23.7996
 ++:21.3234
@:19.5018
++:17.9604
 +:17.6072
:::15.1004
 :15.0013
@@:14.2223
 |:13.7538
 #:13.5738

:13.5702
 &:13.5333
 ||:13.4888
 --:13.3187
.:13.1821
 :::13.1735
,:13.0653
 <:12.9788
 =:12.9273
 ==:12.916
++,:12.8783

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "w" | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 find:19.6987
 (:17.4607
 :13.6605
 [:13.5823
 if:13.1339
 List:12.7283
 [],:12.2268
find:11.6444

:11.3296
 ((:11.2468
 []:11.2321
 w:11.1668
 get:11.1409
 @:11.0729
 #:10.8802
 match:10.7959
(:10.2977
 filter:10.2616
 list:10.0876
 case:9.96741
 f:9.87088

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find
Nature of error: Variable find is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find
LSP: Generating Completions for prefix: find
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_all_widgets_of_type"
root ::= completions

Top 20 Logits:
_:24.5795
All:15.3515
(:15.1358
all:14.8928
er:12.8206
 all:12.7052
Widget:12.1703
-:11.6412
 (:11.6049
,:11.1358
_(:11.0126
.:10.8465
1:10.4999
2:10.4113

:10.2427
W:10.1638
 _:10.0867
_,:9.99171
':9.9374
n:9.91482
b:9.90654

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_
Nature of error: Variable find_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_
LSP: Generating Completions for prefix: find_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "all_widgets_of_type"
root ::= completions

Top 20 Logits:
all:29.7723
widget:18.5103
align:18.3276
text:17.9119
only:17.1619
alls:17.1095
child:16.9768
with:16.7828
attributes:16.7095
first:16.6912
att:16.4992
al:16.4981
by:16.4683
a:16.4082
columns:16.3095
aligned:16.2892
cont:16.2248
attr:16.2023
attribute:16.1646
w:16.1579
of:15.7549

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all
Nature of error: Variable find_all is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all
LSP: Generating Completions for prefix: find_all
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_widgets_of_type"
root ::= completions

Top 20 Logits:
_:26.8444
(:17.8481
Widget:14.1657
,:13.6272
_(:13.4943
 widget:13.454
 (:13.3329
<:13.2033
__:12.8268
-:12.4788

:12.3685
 :12.3042
widget:12.2023
(),:11.9132
:::11.9012
_,:11.7595
1:11.3632
 _:11.3314
(":11.2084
.:11.0327
[:11.0246

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_
Nature of error: Variable find_all_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_
LSP: Generating Completions for prefix: find_all_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "widgets_of_type"
root ::= completions

Top 20 Logits:
widget:27.6151
attributes:17.2246
of:17.0457
text:15.9302
elements:15.5203
w:15.3726
wid:15.2581
cont:15.0824
width:15.0668
Widget:15.0407
container:14.8854
words:14.8846
wd:14.6317
p:14.5648
items:14.5167
in:14.4366
with:14.2706
children:14.2267
columns:14.2185
f:14.2182
wrapper:14.1802

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widget"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widget
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widget
Nature of error: Variable find_all_widget is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widget
LSP: Generating Completions for prefix: find_all_widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s_of_type"
root ::= completions

Top 20 Logits:
s:26.8589
(:16.6079
_:16.0847
 of:14.2049
os:13.2148
,:12.2734
of:12.1589
 (:11.7598
sBy:11.2745
::11.2331
ss:11.2167
S:11.1984
so:10.7217
o:10.7138
sd:10.5003
ows:10.4825
es:10.4602
sg:10.3332
Of:10.1516
 build:10.1033
is:10.0116

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widgets
Nature of error: Variable find_all_widgets is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets
LSP: Generating Completions for prefix: find_all_widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of_type"
root ::= completions

Top 20 Logits:
_:27.5004
(:18.0348
Of:15.9111
 of:15.2995
_(:14.0201
,:13.8898
 (:13.4754
(),:13.0085
 :12.4916
_,:12.4445
-:12.2877

:11.9866
.:11.7422
1:11.6958
():11.609
 _:11.5732
2:11.3632
__:11.3076
((:11.2469
[:11.1581
\_:11.0462

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets_
Nature of error: Variable find_all_widgets_ is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_
LSP: Generating Completions for prefix: find_all_widgets_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "of_type"
root ::= completions

Top 20 Logits:
of:32.2568
or:17.2777
to:17.1104
type:16.7473
with:16.7392
by:15.5822
term:15.2562
for:14.7229
from:14.5401
get:14.3012
off:14.2574
equal:14.1777
o:14.0769
is:14.0211
Of:13.8402
where:13.8151
do:13.7054
in:13.7045
offset:13.6285
out:13.5546
that:13.3228

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets_of
Nature of error: Variable find_all_widgets_of is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of
LSP: Generating Completions for prefix: find_all_widgets_of
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_type"
root ::= completions

Top 20 Logits:
_:25.9809
(:14.4201
 type:13.1113
Type:12.5746
_(:12.3149
 _:12.0219
-:11.8057
,:11.745
__:11.0826
ype:11.0673
 Type:11.0379
type:10.711
 :10.5678
_,:10.4802
\_:10.364
 (:10.25

:10.1874
[:10.1669
::10.0016
<:9.83198
__(:9.73674

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets_of_
Nature of error: Variable find_all_widgets_of_ is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of_
LSP: Generating Completions for prefix: find_all_widgets_of_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "type"
root ::= completions

Top 20 Logits:
type:29.8907
Type:16.9407
types:16.2467
attribute:15.5616
t:15.4611
kind:15.2828
ty:15.2652
ype:14.9495
column:14.874
typ:14.7936
TYPE:14.6725
name:13.8843
value:13.7879
 type:13.7575
attr:13.6646
class:13.6387
f:13.4873
a:13.3375
c:13.2295
id:12.9618
p:12.8458

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_type>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn =
           (Arrow ((Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))]),
              (List (Var "Widget"))))})))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets_of_type
Nature of error: Expecting type [?] but got inconsistent type ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: find_all_widgets_of_type
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: find_all_widgets_of_type
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | "::"
root ::= new-tokens

Top 20 Logits:
(:25.3983
 (:20.9075
((:16.3488
(@:16.3178
 w:15.9135
 :15.8005
::15.4844
_:15.371
2:15.1208
,:14.9467
(),:14.6687

:14.5353
():14.2821
<:14.0811
($:14.0315
[:13.6781
([:13.5417
  :13.5378
:::13.4645
.(:13.3447
(":13.3442

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Var "Widget"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "acc" | "case " | "if " | "let " | "type " | "w" | "widget"
root ::= completions | new-tokens

Top 20 Logits:
w:26.201
f:20.5108
Column:18.0757
 w:17.9298
widget:17.066
Text:16.8056
Widget:15.5333
fun:15.5332
column:15.2669
Row:14.9927

:14.808
Container:14.8
 :14.7579
attributes:14.4606
W:14.1023
 widget:13.5801
 f:13.5509
List:13.5331
text:13.498
find:13.2971
row:13.1416

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <w>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: w
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: w
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "idget"
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:25.2175
 ,:20.745
),:19.8961
):16.6954
 ),:16.2477
)(:15.4874
 :15.3709
.:15.1716
  :14.98
)),:14.8772
::14.7198
:::14.3292
,$:14.1802
->:14.1714
 ):14.0405
 ->:14.0183
,(:13.936
    :13.6531
 ::13.6213
,,:13.5162
 @:13.4032

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc f ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right acc case  f fun  if  let  type  w
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "acc" | "case " | "f" | "fun " | "if " | "let " | "type " | "w"
root ::= new-tokens

Top 20 Logits:
 f:23.3633
f:20.861
 :18.5807
 fun:17.0758
 Text:15.7385
  :15.148
 (:14.8118
 attributes:14.5842
 func:13.996
 fn:13.9004
 Widget:13.708
 is:13.6893
 text:13.6404

:13.5291
    :13.4839
 w:13.4214
 widget:13.3028
 x:13.1811
 #:13.1062
 id:12.8692
     :12.551

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <f>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: f
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: f
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc f ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right acc case  f fun  if  let  type  w
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "un "
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
),:27.6627
):23.0832
 ),:22.2575
)),:20.8553
)):19.4657
 :18.2156
 ):18.1987
)::17.7297
);:17.3285
)[:17.3197
,:17.2587
)(:16.9332
::16.7765
).:16.7232
));:16.1225
),(:16.0264
)|:16.0224
  :15.6998
)->:15.4229
 end:15.364
)},:15.1854
Rejected the highest logit candidate ), with logit 27.6627

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Var "Widget"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 end:21.2747
 ,:20.9299
 :17.5924
 [],:17.3022

:16.8746
  :15.7959
 ),:15.7014
 @:14.6894
end:14.5773
 ):14.5232
 in:14.2703
    :14.2614
 ::13.8669
   :13.6881
     :13.5924
 },:13.5265
 ?:13.1042
      :13.0554
 []:13.051
                :13.0403
 (:13.0237
Rejected the highest logit candidate  end with logit 21.2747

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) ,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) ,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> [Widget]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (List (Var "Widget"))));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> [Widget]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (List (Var "Widget"))));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Column Container List.cons List.contains List.filter List.fold_left List.fold_right List.init Row String.starts_with String.transform Text case  find_all_widgets_of_type fun  if  let  mod string_compare string_concat type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [],:22.245
 widget:19.2707
[:18.0844
 []:16.9864
 :16.712
 List:16.3452
 [:16.3299
 find:15.7341
 (:15.1467

:14.5912
[]:14.4579
 Widget:13.9161
find:13.7793
List:13.7784
widget:13.7262
 [[:13.1686
 ([:12.9886
  :12.783
 [];:12.623
[]):12.0992
 f:11.9315
Rejected the highest logit candidate  [], with logit 22.245

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) ,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widget
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), Widget)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (Var "Widget")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (Var "Widget")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | ")" | "::"
root ::= completions | new-tokens

Top 20 Logits:
s:25.0124
,:17.5807
:::15.8847
_:15.7468
):14.6061
 :::14.2713
 ,:14.0208
->:13.9395
.:13.8587
 @:13.674
List:13.3656
[:13.3285
 [],:13.3045
 :13.2616
 ->:13.108
 in:13.0273
::13.0179

:12.8763
 ):12.7763
@:12.5446
[]:12.5019

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List
        (Rec ("\206\177",
           (Sum
              [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
                ("Column",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Row",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Container",
                 (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
                ])
           )))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List
        (Rec ("\206\177",
           (Sum
              [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
                ("Column",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Row",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Container",
                 (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
                ])
           )))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
,:24.0785
 ,:19.8802
,[:18.3737
):18.1628
 @:17.9873
 :17.2131
 [],:16.6416
 ):15.9595
  :15.1782

:15.1364
),:15.0789
 end:14.8829
::14.8767
@:14.8741
 ->:14.5402
.:14.5346
[@:14.5083
 ::14.1922
 =>:14.0474
 [:13.8558
,,:13.7512
Rejected the highest logit candidate , with logit 24.0785

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:20.4021
 :18.9548
 @:18.806
 end:17.8499
 ([:17.6738
([:17.3316
 ++:16.6831
 ,:16.6032
 [],:16.2588
 []:16.2086
 (:16.0237
  :15.9911
@:15.5604
    :15.3645
 +:15.1823
 (@:15.17
 in:15.094
 of:14.8394
 #:14.5325
[]:14.4719
 ():14.3388

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :23.4196
in:19.6588
end:19.5065
       :18.2731
 :17.9506
                :17.9354
    :17.4862
     :17.345
	:16.7458

:16.245
  :15.8326
           :15.039
               :14.9771
        :14.9638
      :14.9256
         :14.8745
|:14.6881
#:14.5514
let:14.0344
 end:13.647
//:13.4585

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
   

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
   
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:24.5756
 end:21.5968
 #:19.0238
 else:17.9519
 in:17.1556
 //:16.876
 (*:16.3789
 =:16.2679
 (:15.9279
 }:15.5446
 ():15.4882
 {:15.3812
 @:15.3515
 ||:15.3266
 +:15.113
 &:15.0308
 _:15.0067
 !:14.742
 >:14.5427
 []:14.5121
 /*:14.4292

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    |

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    |
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Row:23.7311
 Container:18.8501
 _:17.4806
 :14.8531
 Column:14.3429
 R:14.0243
 Text:13.9245
  :13.9003
 Widget:13.4039
 row:13.3386
 ...:13.1507
Row:12.6169
 other:12.2956
 Ro:12.2849
 Raw:12.256
 Cont:12.1678
 P:12.0748
 x:12.061
 Un:11.7302
 Box:11.6725
 Em:11.594

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow (
              (Prod
                 [(List
                     (Rec ("\206\177",
                        (Sum
                           [("Text",
                             (Some (Prod [String; (List (Var "Attribute"))])));
                             ("Column",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Row",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Container",
                              (Some (Prod
                                       [(Var "\206\177");
                                         (List (Var "Attribute"))])))
                             ])
                        )));
                   (List (Var "Attribute"))]),
              (Var "Widget")))})))
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  Row
Nature of error: Expecting type Widget but got inconsistent type (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Row
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:25.0566
  :20.3958
(_:20.1345
 :19.7339
 (:19.4644
():18.7125
([:18.3174
   :17.4114
 _:16.5437
((:16.2011
 ->:15.9649
    :15.5683
 =>:15.4866
	:15.1438
->:14.9867
(...):14.8556

:14.6344
     :14.335
[:14.318
=>:14.197
(-:14.1852

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
widget:23.709
children:18.118
columns:17.4627
rows:17.246
  :16.7539
_,:16.7313
ws:16.7133
row:16.4396
 widget:16.0685
Widget:15.9161
xs:15.8142
attributes:15.8016
wid:15.7677
w:15.6686
 :15.4881
items:15.1036
cols:15.0608
a:14.9432
elements:14.9426
width:14.9261
first:14.8549

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widget
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
s:24.3446
,:17.5144
ss:15.989
es:15.0532
1:14.661
_:13.7657
):13.7558
2:13.3575
x:13.1036
S:12.9099
st:12.8462
List:12.8349
0:12.653
sd:12.4636
a:12.3713
list:11.9642
d:11.7318
w:11.6521
':11.5519
 ,:11.5112
[:11.4764

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widgets
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:25.1338
):18.2496
  :17.5745
 ,:16.9912
1:16.7815
',:16.7434
2:16.6243
_,:16.4711
::15.9575
_:15.9227
 :15.7654
   :15.6948
0:15.0153
    :14.8091
,[:14.5249
),:14.1456
     :13.8559
,,:13.5213
 _,:13.4124
 =:13.3872
 attributes:13.3796

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "Margin" | "Padding" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 attributes:22.1336
 _):17.1845
 attr:16.9163
attributes:16.6127
 :16.4082
 attribute:16.3644
 att:15.9035
  :15.6032
 at:14.8448
 _:14.69
    :14.3983
   :14.0286
 [:13.7419
 row:13.6921
 a:13.5962
 align:13.4983
     :13.3105
 widget:13.1828
 attributed:13.0288
 columns:12.7762
 alignment:12.7173

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: attributes
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
):25.1177
)=:19.1879
 ):17.7441
)->:17.6978
2:16.5533
)):16.5121
 :16.4253
  :16.3656
),:16.1135
)|:15.8907
,:15.7456
1:15.6819
   :14.9832
 =>:14.9502
    :14.7072
_):14.5139
0:14.2142
::14.1526
_:14.113
)::13.9844
d:13.895

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.4944
  :16.7099
 :16.3934
   :16.1803
 ->:13.2791
    :12.8041

:12.6923
=>:12.665
 =:12.512
     :12.0898
      :11.442
	:11.2437
 as:10.6818
 |:10.5897
       :10.4928
                :10.2053
 ==:10.0777
 >:9.80901
 if:9.72463
 ||:9.62051
        :9.61518

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) =>

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) =>
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget" | "widgets"
root ::= new-tokens

Top 20 Logits:
 List:20.13
 :17.1737
  :14.683

:14.335
 if:14.2179
List:14.1641
 ?:14.0501
 find:14.0372
 []:13.8327
 let:13.7005
 widget:13.5466
 (:13.4385
    :13.1741
   :13.1598
 ...:13.0019
 [:12.9777
 #:12.702
 _:11.8603
 ??:11.8105
 acc:11.8092
 Column:11.76

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  List
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:22.3588
(:12.7998
List:12.7598
.(:12.5811
 .:12.0951
.[:11.7067

:11.5728
..:11.5321
 (:11.3684
():11.3397
_:11.3022
,:11.2918
.<:11.062
(":10.9067
 :10.8012
(@:10.7857
::10.7335
().:10.6562
._:10.5826
 List:10.5797
/:10.4337

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  List.
Nature of error: "List." isn't a valid token
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "filter" | "fold_left" | "fold_right" | "init" | "rev" | "tl"
root ::= completions

Top 20 Logits:
fold:23.9554
filter:18.3496
fl:18.2872
map:17.4514
concat:17.4193
fol:17.3025
init:16.8494
reduce:16.8058
find:16.6969
 fol:16.3263
append:16.1733
rev:15.8338
flat:15.5798
F:14.9023
f:14.8891
sum:14.781
join:14.0943
collect:13.8769
re:13.6319
comb:13.6103
merge:13.5276

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold"))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  List.fold
Nature of error: Variable List.fold is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold
LSP: Generating Completions for prefix: List.fold
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_left" | "_right"
root ::= completions

Top 20 Logits:
_:25.9327
Left:17.75
(:17.1656
 left:15.8497
-:15.4243
i:15.2125
r:15.1842
ing:15.0557
_(:15.0472
left:15.0113
l:14.9931
Right:14.5173

:14.4575
ed:14.4397
 (:14.174
__:13.4553
t:13.419
():13.3138
 _:13.2526
1:13.2152
2:13.1368

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  List.fold_
Nature of error: Variable List.fold_ is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold_
LSP: Generating Completions for prefix: List.fold_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "left" | "right"
root ::= completions

Top 20 Logits:
left:27.2314
right:22.751
l:18.2946
le:17.4202
list:17.31
Left:17.1878
let:16.9484
top:16.4378
lef:16.2029
light:16.1705
out:15.9992
down:15.9677
last:15.8789
like:15.8639
up:15.805
long:15.6501
center:15.4523
middle:15.391
less:15.2958
next:15.2404
all:15.199

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_left>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Widget"));
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                     (Unknown TypeHole)));
                   (Unknown TypeHole); (List (Unknown TypeHole))]),
              (Unknown TypeHole)))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  List.fold_left
Nature of error: Expecting type [Widget] but got inconsistent type ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: List.fold_left
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: List.fold_left
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:24.2896
((:21.3329
(@:18.7335
 (:18.5132
():17.2955
(?:16.8118
([:16.3232
(|:16.0807
(\:15.6687
(_:15.6001
 ((:15.2937

:15.1464
(():14.9597
 :14.8891
(&:14.8394
(::14.7037
2:14.5374
($:14.3911
({:14.293
  :14.1953
(/:14.1864

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Column Container List.cons List.contains List.filter List.fold_left List.fold_right List.init Row String.starts_with String.transform Text case  find_all_widgets_of_type fun  if  let  mod string_compare string_concat type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Abs" | "App" | "Column" | "Container" | "List.cons" | "List.contains" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "Row" | "String.starts_with" | "String.transform" | "Text" | "case " | "find_all_widgets_of_type" | "fun " | "if " | "let " | "mod" | "string_compare" | "string_concat" | "type "
root ::= new-tokens

Top 20 Logits:
fun:22.5302
 fun:17.5534
find:16.8953
List:16.4899
 (:16.3195
acc:14.9308

:14.8037
f:14.6409
func:14.6112
 :14.1488
fn:14.0022
Row:13.8413
Text:13.5618
  :13.4306
row:13.4035
Widget:13.2571
un:13.1687
Column:13.1148
w:13.0077
widget:12.9048
function:12.5649

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun ? ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "Text" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:22.2692
 accum:15.9906
 a:15.5174
 (:15.1607
 w:14.8796
 :14.7063
 x:14.4803
 widget:14.27
 xs:13.927
 result:13.751
 ac:13.6039
 _,:13.0842
 ws:12.9488
 l:12.9438
,:12.9413
 all:12.8601
 y:12.8242
(:12.702
 list:12.5738
 h:12.2431
 children:12.2296

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun acc ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:23.2272
2:15.9357
',:15.2525
 w:15.241
 ,:15.039
1:14.725
 ->:14.6113
m:14.1224
 x:13.4842
 (:13.1814
::12.8618
 _,:12.8281
u:12.6726
.:12.4709
 :12.4555
0:12.4041
->:12.3943
 widget:12.2099
_,:12.1288
 a:11.8504
 b:11.8168

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "Text" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 w:24.141
 :18.1296
 x:17.1888
w:17.1567
 row:16.4469
 widget:16.4236
 e:16.2058
 r:15.9057
 v:15.6473
 (:15.6123
 h:15.5749
 y:15.1109
 i:15.0685
 a:14.7601
 child:14.6629
  :14.5545
 column:14.5385
 Widget:14.2718
 c:14.0845
 m:14.0741
 s:13.9609

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <w>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: w
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: w
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:23.6261
 :18.271
->:18.2449
2:16.0262
':15.7602
1:15.5198
  :15.1654
 =:14.9033
,:14.8543
 -:14.7967
 =>:14.1576
i:13.6825
::13.4044
    :13.0693
   :13.0409
):12.943
 <-:12.6815
 in:12.5865
0:12.5403

:12.4164
g:12.3861

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w ->

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w ->
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "w" | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:22.2144
 :17.4772
 if:15.5308
 (:15.4744
 find:15.4694
 List:15.3245
acc:15.2233
 w:14.994
 [:14.5009
  :13.6374

:13.5265
 accum:12.9654
 let:12.9127
 #:12.825
 widget:12.3199
 ac:12.1994
 Widget:12.1122
    :12.066
 print:12.0153
 a:11.8954
 f:11.7529

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 @:23.9583
 :17.4431
 ++:17.0406
@:16.5559
 +:15.8666
,:15.1596
),:14.1204
 #:13.8683
):13.7402
 &:13.7022
 =:13.7018
 end:13.6394
 ,:13.6387
 ):13.6133
 &&:13.5655
 ||:13.5564
  :13.4418
++:13.3032
 `:13.2196
 <:13.2159
 $:13.2143

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "w" | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 find:21.6382
 (:16.6533
 :15.8481
 List:14.2995
 if:14.2014
 [:14.1179
find:14.0347
 Widget:13.5781
 w:13.4302
 [],:13.1338
 :12.5162
  :12.4668
 acc:12.4459
 get:12.1906
 rec:12.0557
 ,:11.9212
 fun:11.8557
 f:11.6696
 []:11.6614
 ((:11.5781
 #:11.458

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find
Nature of error: Variable find is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find
LSP: Generating Completions for prefix: find
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_all_widgets_of_type"
root ::= completions

Top 20 Logits:
_:24.554
 all:14.3299
-:13.6106
(:13.29
all:13.1578
.:12.4551
All:12.1165
 _:11.9683
,:11.9054
Column:11.7278
 :11.5699
ed:11.443
__:11.1805
\_:11.1712
 (:11.0467
_(:10.8945
 column:10.8469
s:10.7034
1:10.6313
e:10.6034
ing:10.4898

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_
Nature of error: Variable find_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_
LSP: Generating Completions for prefix: find_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "all_widgets_of_type"
root ::= completions

Top 20 Logits:
all:26.8995
align:16.9976
start:15.4979
al:15.4463
add:15.0169
get:14.9772
a:14.9758
All:14.2751
list:13.9195
with:13.8138
any:13.7452
find:13.7309
only:13.7199
widget:13.5581
and:13.4748
each:13.4081
left:13.3253
first:13.28
ALL:13.2773
 all:13.2387
the:13.083

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find_all
Nature of error: Variable find_all is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all
LSP: Generating Completions for prefix: find_all
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_widgets_of_type"
root ::= completions

Top 20 Logits:
_:25.799
(:15.4028
Widget:13.9821
 widget:13.8155
-:13.4833
__:13.3744
,:13.2157
Column:12.9276
widget:12.71
_(:12.5619
.:12.4295
[:12.1442
 _:12.0553
\_:11.7252
_,:11.5871
Row:11.4826
(_:11.3796
 (:11.268
(),:10.9417
Container:10.9041
():10.7988

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find_all_
Nature of error: Variable find_all_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_
LSP: Generating Completions for prefix: find_all_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "widgets_of_type"
root ::= completions

Top 20 Logits:
widget:27.2827
Widget:16.8484
w:15.9347
string:15.908
wid:15.8911
width:15.2409
wrapper:14.5387
web:14.2951
 widget:14.2741
window:14.2396
text:14.2067
webpack:14.1195
wiki:13.987
words:13.9055
column:13.5702
wig:13.5312
view:13.4713
world:13.4307
layout:13.3804
watch:13.3243
word:13.1977

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widget"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widget
Nature of error: Variable find_all_widget is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widget
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widget
LSP: Generating Completions for prefix: find_all_widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s_of_type"
root ::= completions

Top 20 Logits:
s:25.5446
(:16.6419
_:15.478
,:13.0002
es:12.9811
 (:12.0565
::11.9663
 of:11.8838
.:11.6869
):11.5825
():11.4359
[:11.4055
),:11.362
w:11.3581
S:11.3084
(":11.282
':11.2813
ing:11.222
ed:11.1172
 :11.0474
 s:10.9966

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widgets
Nature of error: Variable find_all_widgets is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets
LSP: Generating Completions for prefix: find_all_widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of_type"
root ::= completions

Top 20 Logits:
_:26.3843
Of:19.2523
(:17.664
of:15.7443
 of:15.6632
,:15.3265
(),:14.8992
_,:14.0823
-:13.8669
():13.7243
 (:13.4851
_(:13.4655
):13.1425
__:12.7595
),:12.6808
0:12.6436
 :12.538
.:12.4907
1:12.3649

:12.3161
Text:12.0641

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widgets_
Nature of error: Variable find_all_widgets_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_
LSP: Generating Completions for prefix: find_all_widgets_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "of_type"
root ::= completions

Top 20 Logits:
of:26.6938
or:14.9887
contains:14.4278
Of:14.3722
o:14.3692
with:14.0401
eq:13.8126
old:13.7778
filter:13.6942
OF:13.554
cont:13.5311
to:13.504
only:13.464
on:13.3128
off:13.2469
for:13.2004
in:13.0121
from:12.9846
by:12.6264
ok:12.5418
list:12.5273

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets_of
Nature of error: Variable find_all_widgets_of is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of
LSP: Generating Completions for prefix: find_all_widgets_of
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_type"
root ::= completions

Top 20 Logits:
_:25.7867
(:15.5828
Type:14.3727
_(:13.6763
-:13.6637
,:13.2848
):13.0048
():12.6518
 type:12.1944
_,:12.1774
__:12.1173
(),:12.0983
 (:11.8722
<:11.8604

:11.8301
.:11.7174
ype:11.6134
 _:11.4785
),:11.3272
\_:11.0507
(":11.0389

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widgets_of_
Nature of error: Variable find_all_widgets_of_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of_
LSP: Generating Completions for prefix: find_all_widgets_of_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "type"
root ::= completions

Top 20 Logits:
type:24.088
Type:14.608
types:14.3201
typ:14.0817
ty:13.7407
widget:13.1257
t:13.0996
attribute:12.754
column:12.7333
ype:12.5133
 type:11.94
text:11.8199
value:11.6048
TYPE:11.5047
the:11.4735
attr:11.4114
a:11.3101
attributes:11.1127
row:11.067
template:10.8838
element:10.8675

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_type>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn =
           (Arrow ((Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))]),
              (List (Var "Widget"))))})))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find_all_widgets_of_type
Nature of error: Expecting type [?] but got inconsistent type ((Widget, (Widget -> Bool)) -> [Widget])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: find_all_widgets_of_type
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: find_all_widgets_of_type
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | "::"
root ::= new-tokens

Top 20 Logits:
(:25.234
 (:18.7604
():16.7943
(),:16.6196
,:16.0662
 :15.4964
((:15.2676
 w:15.0805
([:14.8808
2:14.6354
):14.3478
 ):14.2027
_:14.1851
w:14.1698
 ,:14.105
),:14.1042
)(:13.978
[:13.8588
  :13.8438

:13.8203
(@:13.7809

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Var "Widget"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "acc" | "case " | "if " | "let " | "type " | "w" | "widget"
root ::= completions | new-tokens

Top 20 Logits:
w:22.7827
 w:15.0698
widget:14.0409
_,:13.1357
row:12.62
f:12.5981
text:12.3213
,:12.1867
x:12.1491
 :12.1195
1:11.9654
column:11.9515

:11.8994
acc:11.8951
a:11.746
v:11.5245
Text:11.2878
wd:11.2512
list:11.2453
0:11.1341
ws:10.7849

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <w>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: w
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: w
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "idget"
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:23.3334
),:16.3573
 ,:15.3735
):15.3447
.:13.8423
)):13.4475
 :13.2682
::13.211
,,:12.3316
 ):12.324
,$:12.2262
)),:12.2083
,(:12.1387
,[:12.0554
;:11.9465
1:11.9346
Text:11.9313
 ),:11.9202
Column:11.8509
,":11.7096
  :11.7084

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc f ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right acc case  f fun  if  let  type  w
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "acc" | "case " | "f" | "fun " | "if " | "let " | "type " | "w"
root ::= new-tokens

Top 20 Logits:
 f:24.6299
f:20.0157
 :18.1035
 w:15.5369
  :14.8521
 ):14.4874
 fun:14.4519
 g:14.2058
 attributes:14.035
 Widget:13.997
 ),:13.8855
 F:13.4771
 (:13.4515
 fn:13.4046
 s:13.3292
 false:13.2188
 x:13.1961
 Text:13.1536
    :13.0536
 fs:13.0465
 row:13.032

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <f>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: f
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: f
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc f ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right acc case  f fun  if  let  type  w
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "un "
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
),:26.995
):26.2835
)),:20.9417
)):20.9129
 ):20.4447
 ),:20.0133
 :18.669
  :18.593
);:17.1649
),(:17.1418
,:17.0969
).:16.9202
)]:16.2744
));:16.0952
))):16.0254
)(:16.0206
)::16.0094
    :16.0016
)",:15.8943
   :15.8899
)[:15.6361
Rejected the highest logit candidate ), with logit 26.995

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Var "Widget"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.3928
  :16.0665
 :15.8374
 ):14.9158
 ),:13.8777
   :13.584
 end:13.4502
    :13.3177

:12.6677
 },:12.0356
     :10.8944
 [],:10.7392
 ],:10.696
 @:10.5978
 .:10.5671
 +:10.557
 ::10.5277
，:10.5104
 [:10.2903
      :10.2134
	:10.1844

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) ,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) ,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> [Widget]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (List (Var "Widget"))));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> [Widget]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (List (Var "Widget"))));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Column Container List.cons List.contains List.filter List.fold_left List.fold_right List.init Row String.starts_with String.transform Text case  find_all_widgets_of_type fun  if  let  mod string_compare string_concat type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 widget:22.1314
 :17.178
 [],:16.9487
widget:16.3022
 []:16.1938
 [:16.1839
 row:15.7575
  :14.8485
 attributes:14.2792
 Widget:13.3498
 acc:13.2186
    :13.2117
 (:13.1427
[:12.9413
 List:12.766
   :12.5905

:12.3761
 ,:12.3173
 Row:12.2231
 rows:12.1679
 wid:11.8008

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) ,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widget
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), Widget)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (Var "Widget")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (Var "Widget")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | ")" | "::"
root ::= completions | new-tokens

Top 20 Logits:
s:25.0689
):14.7595
,:13.5254
),:12.0518
::11.8693
ss:11.8286
S:11.6993
 s:11.6664

:11.2598
 :11.2086
(:10.8469
);:10.7765
.:10.7541
)):10.5202
_:10.4725
;:10.3474
 ):10.3291
is:10.3277
es:10.2164
w:9.75079
 =>:9.74584

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List
        (Rec ("\206\177",
           (Sum
              [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
                ("Column",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Row",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Container",
                 (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
                ])
           )))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List
        (Rec ("\206\177",
           (Sum
              [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
                ("Column",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Row",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Container",
                 (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
                ])
           )))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
):25.4829
 ):20.8292
,:19.506
)):18.931
),:18.902
);:17.2801
 :17.2778

:16.9026
 end:16.5942
)]:16.4165
)}:15.7377
  :15.4801
).:15.4598
)::15.3876
 ,:15.2284
 @:15.0107
)|:14.8544
    :14.4563
 in:14.2801
)[:14.269
)?:14.2627

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:22.1274
 :20.0254
 end:17.696
  :17.1874
    :17.0871
   :15.4109
     :14.9109
                :14.7225
        :14.5735
       :14.5215
 in:14.4848
 @:14.3781
      :14.2844
 //:13.2728
         :13.1886
end:13.1147
 else:12.9631
           :12.9567
	:12.8993
            :12.8171
@:12.8101

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :23.3804
end:18.8041
 :17.9074
in:17.5661
    :17.3382
       :16.9587
	:16.6178

:16.3878
  :16.2426
     :15.858
#:14.8862
|:14.6206
                :14.2018
      :14.1027
        :14.0147
//:13.867
 end:13.6796
           :13.6466
let:13.0426
         :13.0336
               :12.8341

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
   

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
   
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:25.3029
 end:21.0707
 #:18.8445
 //:18.1143
 +:17.7909
 in:17.7639
 else:16.1911
 ||:15.812
 /*:15.6558
 case:15.5979
 =:15.5374
 ?:15.3934
 -:15.3783
 !:15.3695
 {:14.878
 [:14.6894
 @:14.6596
 }:14.5474
 ::14.5288
 &:14.478
 >:14.3249

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    |

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    |
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Container:23.9431
 _:17.335
 Column:15.5152
 Cont:14.8691
 :14.862
 container:14.2773
 c:14.2397
 Widget:14.1302
 w:14.0758
 C:14.0571
 x:13.6831
 Text:13.6617
 other:13.5793
 Con:13.4761
 Box:13.2433
Container:13.1216
 P:12.922
 Em:12.8226
 e:12.8115
 (:12.7594
 #:12.7418

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Container>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow (
              (Prod
                 [(Rec ("\206\177",
                     (Sum
                        [("Text",
                          (Some (Prod [String; (List (Var "Attribute"))])));
                          ("Column",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Row",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Container",
                           (Some (Prod
                                    [(Var "\206\177");
                                      (List (Var "Attribute"))])))
                          ])
                     ));
                   (List (Var "Attribute"))]),
              (Var "Widget")))})))
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  Container
Nature of error: Expecting type Widget but got inconsistent type ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Container
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Container
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:25.0537
(_:19.9693
 (:19.7266
():17.3417
((:17.302
([:17.1672
({:15.1281
 :15.051
(__:14.6655

:14.6527
 _:14.6048
 ->:14.5299
(":14.424
Widget:14.0442
[:13.9372
(-:13.8653
(...):13.8176
 =>:13.7452
(*:13.6377
(...:13.5095
(`:13.3283

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
widget:20.5334
child:20.2784
w:19.6602
content:18.6219
inner:18.1518
container:17.081
c:16.3499
box:16.3238
sub:16.2767
cont:16.2536
contents:16.2516
body:15.7952
_,:15.6755
wid:15.6694
children:15.5294
column:15.2555
layout:14.8271
Widget:14.4127
wd:14.2545
other:14.237
center:14.209

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]), f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widget
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:22.4586
',:21.0772
_,:20.4411
s:19.0793
1:18.8204
2:18.3866
):17.5875
_:17.3953
0:17.2556
'):16.6443
 ,:16.3859
@:15.8741
':15.261
_):15.086
y:14.9918
i:14.6106
::14.5616
__:14.428
x:14.316
A:14.1704
z:14.1175

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Seft type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Seft type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
            ("Column",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Row",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Container",
             (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
            ])
       ));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "Margin" | "Padding" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 attributes:21.4289
 _):17.6027
 attribute:16.9584
 attr:16.8658
 :16.3956
 [:16.3022
attributes:16.2362
 att:15.7752
 _:15.2596
 padding:14.3026
 container:14.0662
 widget:13.9383
 a:13.8634
 at:13.8596
 properties:13.1362
_):13.1276
 children:13.0573
 alignment:12.9631
 row:12.6855
 align:12.5743
  :12.5735

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
            ("Column",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Row",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Container",
             (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
            ])
       ));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: attributes
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
            ("Column",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Row",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Container",
             (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
            ])
       ));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
):25.0574
 ):19.9478
)=:18.9226
)->:18.3518
2:16.7421
1:16.2454
::15.8092
,:15.5171
_):15.4788
)::15.1544
 as:15.0828
 :15.0011
)):14.8485
 =:14.6622
0:14.5483
'):14.3763
 =>:14.2329
=:14.2313
),:14.2138
_:14.1192
)|:14.0836

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:21.944
 ->:17.785
 :17.6082
 as:14.8425
 =:14.2214
  :13.9975

:13.7747
    :13.6121
 if:13.4902
=>:13.2607
 when:13.1728
   :13.1345
     :12.3765
 [:11.9925
 ==:11.9274
	:11.7281
 -->:11.3394
      :11.1986
 in:11.1866
 >:11.1371
 :::11.0695

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) =>

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) =>
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 find:19.4274
 [:17.4343
 List:17.1295
 :16.843
 (:16.5283
 if:15.6924
 []:15.5835
 let:15.4969

:15.3079
 Widget:13.5739
 widget:13.0658
find:12.8721
 ([:12.6962
  :12.5415
 acc:12.2971
 list:12.2177
 match:12.0636
 Container:11.9891
 case:11.9015
 #:11.5091
 get:11.4272

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find
Nature of error: Variable find is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find
LSP: Generating Completions for prefix: find
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_all_widgets_of_type"
root ::= completions

Top 20 Logits:
_:24.1045
All:15.4435
(:14.8404
all:14.3432
 all:13.6829
er:12.2643
Widget:11.7174
_(:11.6289
Container:11.5341

:11.4066
.:11.0885
-:11.0038
 (:10.9037
():10.3699
 _:10.3263
Column:10.1024
l:10.0886
__:9.98781
ers:9.81394
Text:9.78653
::9.76475

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find_
Nature of error: Variable find_ is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_
LSP: Generating Completions for prefix: find_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "all_widgets_of_type"
root ::= completions

Top 20 Logits:
all:26.0765
widget:16.8698
only:15.9381
a:15.3819
attributes:15.3252
add:15.1529
cont:14.9545
first:14.8282
child:14.7106
text:14.5203
columns:14.4879
every:14.2305
alls:14.0535
with:14.0484
elements:14.0382
some:13.7698
al:13.7534
any:13.7283
default:13.6246
p:13.5916
container:13.5883

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find_all
Nature of error: Variable find_all is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all
LSP: Generating Completions for prefix: find_all
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_widgets_of_type"
root ::= completions

Top 20 Logits:
_:26.5475
(:15.9514
Columns:13.6545
 widget:13.4769
-:13.3099
 columns:13.1423
__:12.9203
widget:12.8524
_(:12.7481

:12.3335
\_:12.285
Widget:12.2569
columns:12.0742
s:12.0112
():12.0091
 Column:11.7251
Column:11.6987
 (:11.5674
Rows:11.4636
(_:11.3246
Text:11.2837

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  find_all_
Nature of error: Variable find_all_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_
LSP: Generating Completions for prefix: find_all_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "widgets_of_type"
root ::= completions

Top 20 Logits:
widget:26.4445
wid:15.6988
Widget:15.4677
attributes:14.9124
width:14.8093
wig:14.7443
layout:14.461
all:14.192
text:14.1831
attr:14.1677
items:14.0151
get:13.9595
w:13.8363
find:13.8245
but:13.697
cell:13.5891
is:13.4976
block:13.4874
words:13.4849
with:13.4485
to:13.3837

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widget"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find_all_widget
Nature of error: Variable find_all_widget is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widget
LSP: Generating Completions for prefix: find_all_widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s_of_type"
root ::= completions

Top 20 Logits:
s:25.5132
(:15.8606
_:15.7769
ss:13.1483
os:13.0952
::13.047
 (:12.7493
 of:12.3077
is:12.0399

:11.8807
():11.8192
 =:11.7997
,:11.6893
1:11.6124
so:11.5919
es:11.5806
(":11.5693
.:11.3501
us:11.1818
sBy:11.1795
 :11.0912

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find_all_widgets
Nature of error: Variable find_all_widgets is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets
LSP: Generating Completions for prefix: find_all_widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of_type"
root ::= completions

Top 20 Logits:
_:26.2677
(:17.2727
Of:14.7446
 of:14.0505
_(:13.7452

:13.7256
():13.0612
(_:12.4262
 (:12.3908
__:12.2797
1:12.278
([:12.2513
-:11.9391
((:11.8545
 :11.8196
0:11.6928
[:11.5106
 _:11.2918
(@:11.2509
.:10.9959
<:10.9094

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find_all_widgets_
Nature of error: Variable find_all_widgets_ is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_
LSP: Generating Completions for prefix: find_all_widgets_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "of_type"
root ::= completions

Top 20 Logits:
of:28.4904
or:17.2466
from:17.0366
to:16.9094
type:15.9477
for:15.4648
off:15.2711
o:15.2167
with:15.0459
if:14.9722
Of:14.6092
OF:14.2097
get:14.1536
do:14.1383
in:13.7691
by:13.7479
only:13.5653
f:13.5205
offset:13.4323
out:13.2202
and:13.1539

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find_all_widgets_of
Nature of error: Variable find_all_widgets_of is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of
LSP: Generating Completions for prefix: find_all_widgets_of
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_type"
root ::= completions

Top 20 Logits:
_:25.793
(:16.2068
Type:14.8524
 type:14.421
ype:13.8448
-:13.5162
_(:13.4173
type:13.0757
__:12.8841

:12.6034
():12.4737
(":12.1014
y:12.0618
e:11.9374
 (:11.8017
(':11.4862
\_:10.8911
.:10.755
((:10.7525
s:10.6601
a:10.564

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find_all_widgets_of_
Nature of error: Variable find_all_widgets_of_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of_
LSP: Generating Completions for prefix: find_all_widgets_of_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "type"
root ::= completions

Top 20 Logits:
type:27.3491
types:19.3726
Type:16.5265
typ:16.1286
TYPE:15.475
color:15.4572
t:15.0904
a:14.8478
with:14.7245
ty:14.6441
text:14.5583
attribute:14.5574
ype:14.0909
tree:14.0464
the:13.9858
name:13.8399
f:13.7725
atype:13.7464
value:13.7129
any:13.6946
that:13.6644

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_type>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Widget"));
           syn =
           (Arrow ((Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))]),
              (List (Var "Widget"))))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  find_all_widgets_of_type
Nature of error: Expecting type [Widget] but got inconsistent type ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: find_all_widgets_of_type
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: find_all_widgets_of_type
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:24.4198
 (:19.2784
(@:17.0705
((:16.6094
():16.598

:15.6213
 :14.8307
2:14.5838
_:14.5736
([:14.5612
 widget:14.5604
[:14.2456
($:14.1954
_(:13.9067
.(:13.7643
(_:13.7019
(":13.5429
!(:13.4334
<:13.3794
1:13.2176
.:13.1402

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "case " | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
widget:23.5661
Container:18.9585
Widget:17.3641
Text:17.2474
w:17.2173
container:17.1773
Column:17.0627
 widget:16.6384
f:15.8423
Row:15.5542
column:14.7263
row:14.4918
child:14.2253

:14.1756
wrapper:14.054
wid:14.0452
text:14.0378
List:13.6904
Col:13.6002
#:13.4359
_,:13.274

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))]);
           syn =
           (Rec ("\206\177",
              (Sum
                 [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
                   ("Column",
                    (Some (Prod
                             [(List (Var "\206\177"));
                               (List (Var "Attribute"))])));
                   ("Row",
                    (Some (Prod
                             [(List (Var "\206\177"));
                               (List (Var "Attribute"))])));
                   ("Container",
                    (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
                   ])
              ))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  widget
Nature of error: Expecting type (Widget, (Widget -> Bool)) but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Rec ("\206\177",
   (Sum
      [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
        ("Column",
         (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
        ("Row",
         (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
        ("Container",
         (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
        ])
   ))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Rec ("\206\177",
   (Sum
      [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
        ("Column",
         (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
        ("Row",
         (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
        ("Container",
         (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
        ])
   ))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | ","
root ::= new-tokens

Top 20 Logits:
,:23.9395
):20.0777
 ,:17.9166
 ):16.9748
s:16.9214
),:16.2987
(),:16.0182
)(:15.8215
.:15.7533
 f:15.5276
_,:15.486
(:15.2597
:::15.0199
[:14.7646
 @:14.6037
 _,:14.5358
::14.4875
_:13.8387
 (:13.8036
():13.8029
()):13.6517

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: f ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  f fun  if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "f" | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 f:22.7395
f:18.8679
 :17.4122
 fun:16.7815
 attributes:15.2309
 (:15.002
 ):14.7191
 Widget:14.0874
 [:14.0297
 fn:13.7563
 _):13.6838
 if:13.6255
 is:13.5812
 x:13.5758
 id:13.4432
 Text:13.4219
 true:13.3831
 attr:13.3529
 w:13.3213
 g:13.2216
 widget:13.1189

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <f>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: f
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: f
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: f ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  f fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "un "
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):25.0371
 ):21.3486
);:19.5527
),:18.8592
 :18.024
)):17.2925
 in:16.8137

:16.637
 :::16.5599
::16.5534
).:16.4885
,:16.4718
 ++:16.4491
)[:16.412
)|:16.3742
)::16.346
)?:16.262
 ::16.0286
 end:15.9898
)]:15.988
  :15.8893

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:22.0406
 end:21.5009
 :20.7374
 in:19.5126
 ++:18.7714
    :17.8279
  :17.7916
 +:17.5622
 @:17.2334
 //:15.9217
   :15.8817
 :::15.6949
end:15.3955
 else:15.3845
 ::15.3691
     :15.3096
      :15.2849
 #:15.0394
                :14.9968
@:14.9366
++:14.8882

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
end:22.5096
in:22.399
   :21.8851
 :21.3922
    :18.038
  :17.9597

:17.8922
 in:16.8625
 end:16.7555
       :16.7455
     :16.6742
let:16.1343
	:16.0054
else:15.6159
                :15.5993
      :14.8488
        :14.7173
;:14.6759
and:14.6058
           :14.5023
endif:14.1786

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)
end

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)
end
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:
 in:23.7697

:21.2541
 :19.9403
;:17.2216
    :16.7673
  :16.2888
 end:16.234
 let:15.3096
in:14.8295
                :14.5597
 #:14.4636
   :14.3128
 fun:14.2448
      :14.1694
 @:14.1375
 //:14.1339
     :14.0623
,:13.8878
        :13.7931
 ;:13.7662
 if:13.6877

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)
end in

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)
end in
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)
end
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:20.1908
 :17.4037
    :15.2997
  :14.3289
        :12.3748
   :12.3006
     :12.177
 let:12.1498
      :12.011
 #:11.9881
                :11.9317
 find:11.9311
       :11.2957
 ():11.2856
 {:11.1024
            :10.9092
 //:10.8021
 [:10.5503
 []:10.2301
	:10.1095
          :10.07

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)
end in


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)
end in

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
  fun widget, f ->
    case widget
    | Text(text, attributes) => if f(Text(text, attributes) ) then [Text(text, attributes) ] else []
    | Column(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Row(widgets, attributes) => List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, f) , widgets)
    | Container(widget, attributes) => find_all_widgets_of_type(widget, f)
end in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, f), widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}])
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:20.8957
    :17.6764
let:16.2837
  :16.0772
 :15.9599
        :15.0375
#:14.9387
"":14.5838
      :14.5046
find:14.0277
```:13.9501
            :13.8149
     :13.7632
   :13.7233
\:13.5751
                :13.4897
":13.4045
       :13.2325
(*:12.963
          :12.77
print:12.7278
