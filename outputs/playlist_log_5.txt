

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlayS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
             


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id ==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
             


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | Pause


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrent


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
         


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
         


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | Add


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
         


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id ==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
             


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
         


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
             


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
          


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | Remove


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
             


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don'


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
             


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id ==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id &&


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) >


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id !=


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
             


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id ==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id &&


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) >


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id !=


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
             


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
             


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id ==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id &&


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) >


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id !=


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
             


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
             


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id !=


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
            end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
            end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
            end
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
            end
      end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
            end
      end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
            end
      end
in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun pl, action ->
      case action 
        | PlaySong(id) =>
            match get_state(pl) with 
              | PausedOn(song_id) when song_id == id => ([get_songs(pl)], Playing(id))
              | _ => pl 
            end
        
        # If nothing is playing, no need to pause #
        | PauseCurrentSong =>
          match get_state(pl) with
            | Playing(song_id) -> ([get_songs(pl)], PausedOn(song_id))
            | _ => pl
          end
        
        | AddSong(id) => 
          if List.contains(fun song_id -> song_id == id, get_songs(pl)) then 
              pl 
          else 
              ([id::get_songs(pl)], NoSongSelected)
           end
        
        | RemoveSong(id) =>
            match get_state(pl) with
              # If there are other songs in the playlist, don't remove selected song from current state #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              | PausedOn(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # If there are other songs in the playlist, remove selected song from current state if it is playing #
              | Playing(song_id) when song_id == id && List.length(get_songs(pl)) > 1 => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
              
              # Otherwise remove the only song from playlist and current state #
              | _ => ([List.filter(fun song_id -> song_id != id, get_songs(pl))], NoSongSelected)
            end
      end
in


