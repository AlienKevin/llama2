
================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Target types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:18.5892
 :17.5619
 fun:16.8853
    :13.0288
  :12.9588
   :11.9097
                :11.7094
     :11.0579
        :10.7056
 #:10.6561	prefix accepted: 
 func:10.1937	prefix accepted: fun
            :10.1696
 (:10.0977
 ?:10.075	prefix accepted: 
	:9.98728	rejected
 \:9.98623	prefix accepted: 
      :9.93076
       :9.86398
 let:9.74925
         :9.65009
 {:9.58755	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Target types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
   :21.3841
 :19.1895
fun:17.7986
       :15.2844
  :15.2604
 fun:14.5392
	:14.5038	rejected
    :13.9629
     :13.5098
func:13.4786	prefix accepted:fun
let:13.2803
#:12.8763	rejected

:12.1517
           :11.7948
      :11.5956
                :11.0976
function:10.9236	prefix accepted:fun
 let:10.8612
        :10.6649
fn:10.4595	prefix accepted:f
         :10.4072

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
   

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
   
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Target types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:21.056
 let:16.1154
 #:14.4313	prefix accepted: 
 rec:13.0331	prefix accepted: 
 (*:12.7254	prefix accepted: (
 fix:11.8815	prefix accepted: f
 (:12.7254
 func:11.2679	prefix accepted: fun
 @:11.264	prefix accepted: 
 find:11.0324	prefix accepted: f
 f:11.8815
 Rec:10.7471	prefix accepted: 
 recursive:10.7169	prefix accepted: 
 mem:10.6378	prefix accepted: 
 match:10.5248	prefix accepted: 
 go:10.5111	prefix accepted: 
 ~:10.4773	prefix accepted: 
 ##:10.3647	prefix accepted: 
 mut:10.1994	prefix accepted: 
 List:10.1759
 fol:10.1411	prefix accepted: f

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 widget:15.4195
 root:15.4005
 w:14.6226
 container:13.1564
 parent:12.5994
 tree:12.3195
 top:12.0951
 node:12.0155
 target:11.8034
 start:11.6786
 x:11.3781
 layout:11.2651
 main:11.1618
 initial:10.9099
 base:10.8573
 ws:10.7062
 (:10.6747
 element:10.5778
 view:10.4893
 term:10.4403
 starting:10.4217

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: (Widget, (Widget -> Bool)), find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widget
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:16.2907
 f:12.7797	prefix accepted: 
 test:12.1659	prefix accepted: 
 predicate:11.9885	prefix accepted: 
 pred:11.6339	prefix accepted: 
s:11.5856
_:11.5054
 check:10.9263	prefix accepted: 
 find:10.8986	prefix accepted: 
 query:10.7797	prefix accepted: 
 to:10.6035	prefix accepted: 
 p:10.4781	prefix accepted: 
 search:10.4134	prefix accepted: 
 ->:10.1674
 type:10.0231	prefix accepted: 
 is:9.93527	prefix accepted: 
 target:9.93505	prefix accepted: 
 tree:9.89158	prefix accepted: 
 filter:9.88325	prefix accepted: 
 root:9.69554	prefix accepted: 
 ,:9.4647

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 f:16.2738
 test:15.2967
 predicate:15.199
 pred:14.5886
 p:14.284
 is:14.0969
 filter:12.2541
 condition:12.1047
 check:11.8477
 match:11.8249
 func:11.396
 matches:11.3768
 satisfies:11.3347
 type:11.3334
 cond:11.1395
 widget:11.1274
 fn:10.8449
 has:10.4454
 find:10.3866
 should:10.1216
 matching:9.90615

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <f>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: f
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: f
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:19.1006
->:14.3818
 :13.4698
_:12.1872
 =>:11.733	prefix accepted: 
,:11.4339	rejected

:11.3398
1:10.729
ns:10.122
x:10.0994
p:9.8083
ct:9.70056
pred:9.59207
::9.57495	rejected
wd:9.56625
w:9.34935
':9.25006	rejected
 -:9.18688
0:9.18514
2:9.08043
 =:9.07153	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:

:19.0402
 :17.4099
 List:14.7838
    :14.1255
 if:13.7807
 case:13.1161
  :13.0738
 match:13.0715	prefix accepted: 
        :12.6818
 let:12.6681
 find:12.47
     :12.0768
 #:11.9746	prefix accepted: 
                :11.7337
            :11.3923
      :11.3814
   :11.3756
 [:11.2544
 fail:11.1978	prefix accepted: f
       :11.1524
 (:11.1035

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
       :20.1116
   :16.5803
           :14.0746
     :14.0665
      :13.5625
        :13.3521
    :12.8418
case:12.6841

:12.3012
if:12.2623
	:11.8428	rejected
let:11.5783
         :11.2257
 :11.2036
               :10.9648
#:10.8701	rejected
match:10.4404	rejected
  :10.4337
                :10.2232
          :10.0723
            :9.847

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
       

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
       
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 case:19.7424
 let:19.1205
 if:18.8201
 match:17.0452	prefix accepted: 
 List:15.4282
 #:15.1743	prefix accepted: 
 var:12.8837	prefix accepted: 
 find:12.6796
 rec:12.4325	prefix accepted: 
 (:12.2892
 (*:12.0435	prefix accepted: (
 [:11.9166
 f:11.8725
 fun:11.8643	prefix accepted: f
 assert:11.5929	prefix accepted: 
 list:11.2013	prefix accepted: l
 type:11.1998
 go:11.1699	prefix accepted: 
 func:10.9889	prefix accepted: f
 recursive:10.8729	prefix accepted: 
 cond:10.7484	prefix accepted: c

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 widget:18.7126
 f:15.729
 List:13.7681
 find:13.068
 :12.6846
 (:12.5958

:12.1454
 #:12.0093	prefix accepted: 
 filter:11.9645	prefix accepted: fi
 match:11.0654	prefix accepted: ma
 [:11.0181
 type:10.6819
 is:10.425
 Widget:10.2744	prefix accepted: 
 list:10.2061	prefix accepted: l
 search:10.1149	prefix accepted: s
 !:10.0311
 width:10.0265	prefix accepted: wid
(:10.0238
 let:9.87386
 {:9.8167	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.1103
 :18.4812
,:15.3543
 of:14.7481	prefix accepted: 
    :13.6623
  :13.557
 with:13.4951	prefix accepted: 
 |:13.439
 in:13.3189	prefix accepted: 
        :12.8621
::12.7585
                :12.6488
            :12.3947
     :12.2029
      :12.0642
   :11.7364
 match:11.7234	prefix accepted: 
 {:11.3749	prefix accepted: 
 #:11.1048	prefix accepted: 
 ::11.0977
 f:11.0413	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
           :21.6503
       :21.6323
         :17.6384
            :16.8123
        :16.8068
   :16.1612
               :16.0502
          :15.9912
     :15.14

:15.0846
             :14.8316
	:14.6925	rejected
                :14.6422
    :14.5066
      :14.2067
              :13.5849
#:13.04	rejected
|:12.4755
 :12.3377
  :12.2101
 |:11.7892

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.7215
 #:16.3672	prefix accepted: 
 (*:12.5103	prefix accepted: 
 +:12.4712	prefix accepted: 
 ~:11.9898	prefix accepted: 
 //:11.7622	prefix accepted: 
 let:11.592	prefix accepted: 
 if:11.4458	prefix accepted: 
 ##:11.2523	prefix accepted: 
 match:11.0674	prefix accepted: 
 when:11.0121	prefix accepted: 
 Text:10.9573	prefix accepted: 
 {:10.9457	prefix accepted: 
 ,:10.88
 *:10.7986	prefix accepted: 
 ||:10.7247	prefix accepted: |
 Column:10.6666	prefix accepted: 
 (:10.6207	prefix accepted: 
 /*:10.579	prefix accepted: 
 -:10.4352	prefix accepted: 
 ::10.3482

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            |

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            |
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Text:18.5096
 Column:16.3832
 Container:15.1404
 Row:14.1658
 _:12.7274
 (:12.0973
 Widget:11.5717	prefix accepted: 
 column:10.956
 row:10.6435
 Col:10.3625
 :11.5717
 []:10.3471	prefix accepted: 
 container:10.2312
 x:10.1889
 widget:10.1542
 w:10.1173
 ~:10.0072	prefix accepted: 
 #:9.91176	prefix accepted: 
Text:9.86442
 P:9.71504	prefix accepted: 
 text:9.70279

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ((String, [Attribute]) -> Widget)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow ((Prod [String; (List (Var "Attribute"))]), (Var "Widget")
              ))})))
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Text
Nature of error: Expecting type Widget but got inconsistent type ((String, [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Text
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Text
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.1301
(_:15.2841	prefix accepted:(
 _:15.053	prefix accepted: 
 _,:12.8571	prefix accepted: 
 =>:11.9393
(":11.4493	prefix accepted:(
 (:10.9012
,:10.8887	rejected
():10.8652	prefix accepted:(
 ->:10.7862	prefix accepted: 
 text:10.5463	prefix accepted: 
(...):10.4832	prefix accepted:(
 x:10.242	prefix accepted: 
((:10.1853	prefix accepted:(
 w:9.93758	prefix accepted: 
 t:9.91269	prefix accepted: 
_,:9.7251	rejected
($:9.63863	prefix accepted:(
(),:9.62397	prefix accepted:(
({:9.34187	prefix accepted:(
([:9.32291	prefix accepted:(

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
_,:18.7849	prefix accepted:_
text:18.0501
string:16.9956
content:16.497
str:16.3335
x:15.7518
s:15.2051
value:15.0232
txt:14.9871
label:14.3893
t:14.3291
contents:13.93
body:12.8368
a:12.689
w:12.6857
data:12.6747
c:12.399
name:12.3649
val:12.1869
title:11.9398
inner:11.9315
Rejected the highest logit candidate _, with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Wildcard
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ","
root ::= new-tokens

Top 20 Logits:
string:15.309	rejected
text:15.132	rejected
content:14.6661	rejected
 ,:13.8426
str:13.8089	rejected
x:13.2512	rejected
:::12.9232	rejected
s:12.883	rejected
value:12.671	rejected
label:12.3203	rejected
t:12.2881	rejected
attr:11.8262	rejected
),:11.6876	prefix accepted:)
txt:11.4029	rejected
contents:11.3798	rejected
 :::11.2475	prefix accepted: 
message:11.0063	rejected
attributes:10.9207	rejected
xs:10.9124	rejected
data:10.7745	rejected
a:10.5475	rejected
Rejected the highest logit candidate string with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ ,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ ,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "Margin" | "Padding" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 _):17.4832	prefix accepted: _
_):16.3097	prefix accepted:_
 _:17.4832
 attr:12.8839
 attributes:12.4151
_:16.3097
 :11.3853
 __:10.9352	prefix accepted: _
attributes:10.8302
attr:10.7498
__:10.5304	prefix accepted:_
 att:10.3628
 a:10.1005
 _,:9.81287	prefix accepted: _
_,:9.61898	prefix accepted:_
 xs:9.43921
 [:9.32871
a:9.09915
  :8.97814
att:8.5831
 x:8.48747
Rejected the highest logit candidate  _) with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ ,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= new-tokens

Top 20 Logits:
 ):17.6883
attributes:13.3634	rejected
 :13.2536
),:13.2232	prefix accepted:)
  :12.9069
attr:12.644	rejected
    :12.321
 :::12.2958
)=:12.21	prefix accepted:)
     :11.9422
)|:11.4746	prefix accepted:)
 _):11.3333	prefix accepted: 
   :11.2636
      :11.1595
 ),:11.1022	prefix accepted: )
:::10.749
 attributes:10.5077	prefix accepted: 
 attr:10.369	prefix accepted: 
)->:10.3544	prefix accepted:)
a:10.0157	rejected
)::9.95113	prefix accepted:)

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ )

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ )
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.7678
=>:14.1312
 :14.0123
 when:13.2955	prefix accepted: 
 ->:13.1893	prefix accepted: 
  :12.8545
 if:12.4812	prefix accepted: 
 as:12.3386	prefix accepted: 

:11.8015
    :11.5842
     :11.2458
      :11.0677
   :10.9096
 |:10.6095	prefix accepted: 
         :10.3648
->:10.3198	rejected
        :10.2891
                :10.2698
 ,:9.90965	prefix accepted: 
       :9.83467
          :9.82021

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) =>

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) =>
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 if:18.8035
 :16.6657

:16.1581
 [:15.1923
 List:14.5329
 (:13.8878
 []:13.8294
 f:13.0492
  :12.4588
 #:12.4346	prefix accepted: 
 [(:12.342	prefix accepted: [
 let:12.0377
    :11.7168
 ([:11.2672	prefix accepted: (
 find:11.1593
 case:10.8728
     :10.7878
        :10.5912
                :10.5617
   :10.5227
 match:10.502	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp f false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "String.reverse" | "String.starts_with" | "String.transform" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 f:19.5608
 (:15.1353
 :13.5923
 List:13.3293
(:13.2525
f:12.9314
 not:12.8907	prefix accepted: n
  :12.1622
 !:11.6287
 Bool:11.5618	prefix accepted: 
 is:11.5433
 @:11.424	prefix accepted: 
     :11.0008
 String:10.8488
 bool:10.7639
 true:10.7355
_:10.6713	rejected
    :10.6601

:10.6258
 then:10.4795	prefix accepted: t
 find:10.2227	prefix accepted: f

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <f>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool; syn = (Arrow ((Var "Widget"), Bool))})))
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  f
Nature of error: Expecting type Bool but got inconsistent type (Widget -> Bool)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: f
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: f
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp f false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "alse" | "loat_of_int" | "loat_of_string" | "loor"
new-tokens ::= whitespace | "(" | "then"
root ::= completions | new-tokens

Top 20 Logits:
(:19.6341
 widget:14.9991	prefix accepted: 
 (:14.1666
($:13.8294	prefix accepted:(
(_:12.6351	prefix accepted:(
 then:12.2674
(@:12.1295	prefix accepted:(
((:11.9889	prefix accepted:(
 $:11.9673	prefix accepted: 
(":11.3161	prefix accepted:(
([:11.1103	prefix accepted:(
():11.0221	prefix accepted:(
 text:11.0156	prefix accepted: t
$:10.9498	rejected
.:10.7112	rejected
[:10.5225	rejected
 @:10.1929	prefix accepted: 
 #:10.1103	prefix accepted: 
(*:10.0933	prefix accepted:(
.(:10.0814	rejected
 Text:9.93957	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp f false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "case " | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
widget:19.3356
Text:17.7064
text:13.3612	prefix accepted:t
 widget:13.1668
Widget:11.8187	rejected
#:11.6017	rejected
w:11.1854
 Text:10.8327
wid:9.96376
Texture:9.89081	prefix accepted:Text
x:9.71719	rejected
Term:9.65674	prefix accepted:Te
wig:9.58415	prefix accepted:wi
Ab:9.40243	rejected
Column:9.30355
 #:9.30106	prefix accepted: 
TextBox:9.2051	prefix accepted:Text
node:9.13709	rejected
0:9.13358	rejected
this:8.9901	prefix accepted:t
self:8.85525	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):20.728
::13.6685	rejected
 ):13.0165
 ::12.9327	prefix accepted: 
),:12.4896	prefix accepted:)
 =:12.3141	prefix accepted: 
)::11.8153	prefix accepted:)
 $:11.4613	prefix accepted: 
 as:11.4552	prefix accepted: 
)=:11.446	prefix accepted:)
){:11.3976	prefix accepted:)
 @:11.3259	prefix accepted: 
@:11.2762	rejected
=:11.2289	rejected
)$:11.0908	prefix accepted:)
)(:10.9725	prefix accepted:)
 then:10.9679	prefix accepted: 
);:10.9513	prefix accepted:)
$:10.6895	rejected
 :12.9327
 %:10.2392	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:20.7553
 :15.2976

:12.9279
 [:11.969	prefix accepted: 
 ||:11.9495	prefix accepted: 
 &&:11.6846
 ==:11.5478	prefix accepted: 
then:11.3593
 {:10.8666	prefix accepted: 
 []:10.6963	prefix accepted: 
  :10.5144
 =:10.4127	prefix accepted: 
 Then:9.82366	prefix accepted: 
 else:9.76831	prefix accepted: 
 ?:9.71457	prefix accepted: 
    :9.47067
 #:9.35902	prefix accepted: 
     :9.2308
                :9.22573
 [[:9.14861	prefix accepted: 
 ([:9.12594	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 [:18.0284
 widget:14.9188
 []:14.404
 :14.149
 List:13.8725

:13.1908
 (:12.9344
[:12.7229
 [(:12.5817	prefix accepted: [
 #:12.4575	prefix accepted: 
 cons:12.267	prefix accepted: c
 ([:12.0203	prefix accepted: (
 list:11.5774	prefix accepted: l
 #[:11.1415	prefix accepted: 
 [[:10.8658	prefix accepted: [
 {:10.8532	prefix accepted: 
 [_:10.4093	prefix accepted: [
 text:10.3983	prefix accepted: t
 Text:10.3316
 <:10.1196	prefix accepted: 
  :10.0246

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "case " | "if " | "let " | "type " | "widget"
root ::= completions | new-tokens

Top 20 Logits:
widget:18.253
Text:14.5329
 widget:14.2274
text:12.3507	prefix accepted:t
#:11.3977	rejected
|:11.0522	rejected
f:11.028	rejected
Widget:10.2602	rejected
w:9.99062
 Text:9.66629
 ]:9.56758	prefix accepted: 
||:9.02553	rejected
find:8.94274	rejected

:8.92702
@:8.84027	rejected
x:8.83987	rejected
():8.82468	prefix accepted:(
Texture:8.55719	prefix accepted:Text
result:8.49793	rejected
$:8.45658	rejected
List:8.40715

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "]"
root ::= new-tokens

Top 20 Logits:
]:20.5332
 ]:14.3447
 @:13.2431	prefix accepted: 
:::12.7727	rejected
 else:12.6979	prefix accepted: 
 :::12.2806	prefix accepted: 
@:12.2275	rejected
 ::12.1554	prefix accepted: 
 |:12.1451	prefix accepted: 
;:12.0186	rejected
,:11.5577	rejected
::11.4891	rejected
 :13.2431
]\:11.2748	prefix accepted:]
][:10.6627	prefix accepted:]
](:10.662	prefix accepted:]
 as:10.5706	prefix accepted: 
],:10.4675	prefix accepted:]
,]:10.4408	rejected
];:10.4243	prefix accepted:]
]`:10.3626	prefix accepted:]

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget]

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget]
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:
 else:21.5222
 :14.8712

:13.706
 @:12.9834
 elif:12.7753	prefix accepted: el
 end:11.4209	prefix accepted: e
 els:11.3966
  :11.2916
 []:10.9991	prefix accepted: 
else:10.8385
    :10.8025
 el:12.7753
     :10.5249
                :10.1325
   :10.0988
      :10.0937
        :9.87997
 #:9.70855	prefix accepted: 
 \:9.54325	prefix accepted: 
            :9.35157
 :::9.25005	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 []:21.0498
 [:15.9356
 :14.46
[]:12.9406
 [];:12.8862	prefix accepted: []
 List:12.8623
 ([:11.7279	prefix accepted: (
 nil:11.6378	prefix accepted: 
 [(:11.6197	prefix accepted: [

:11.1994
 #:11.1359	prefix accepted: 
 [_:11.0374	prefix accepted: [
 f:10.8995
  :10.6604
 [],:10.6592	prefix accepted: []
 (:11.7279
 [[:10.4088	prefix accepted: [
 else:10.3431	prefix accepted: 
 :10.2154	rejected
 let:9.95051
 if:9.88155

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.423
 end:17.2751
 :16.2122
  :13.0322
                :12.7689
 |:12.6062
            :12.5169
 (*:12.3601	prefix accepted: 
 #:12.353	prefix accepted: 
    :12.0685
        :12.0024
 in:11.7237	prefix accepted: 
     :11.3484
#:11.2527	rejected
   :11.1746
             :11.0917
         :10.8463
      :10.8074
          :10.7321
               :10.6903
:::10.5213	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
           :21.0585
            :15.8009
       :15.4286
               :14.8306
                :14.8132

:14.7217
	:14.0344	rejected
          :13.9807
        :13.937
#:13.6208	rejected
    :12.8585
   :12.722
             :12.6169
         :12.6104
 :12.1853
|:11.8573
     :11.7494
              :11.6989
  :11.3093
      :11.1508
(*:10.2602	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.32
 #:16.8553	prefix accepted: 
 //:13.9805	prefix accepted: 
 (*:13.7148	prefix accepted: 
 end:13.4031
 Column:12.2764	prefix accepted: 
 ##:12.26	prefix accepted: 
 /*:12.2386	prefix accepted: 
 ||:11.6464	prefix accepted: |
 --:11.5124	prefix accepted: 
 +:11.3676	prefix accepted: 
 (:11.02	prefix accepted: 
 else:11.0104	prefix accepted: e
 Row:10.9697	prefix accepted: 
 ~:10.8488	prefix accepted: 
 {:10.8032	prefix accepted: 
 @:10.7584

:10.6638
 column:10.6228	prefix accepted: 
 ::10.5945	prefix accepted: 
 %:10.5574	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            |

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            |
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Column:20.1765
 Row:17.6603
 Container:17.2496
 _:12.3518
 Col:11.7426
 Widget:11.2714	prefix accepted: 
 :11.2714
 (:10.7698
 column:10.7322
 R:10.6081
 row:10.1862
 Color:10.1547	prefix accepted: Col
Column:9.86011
 Cell:9.57998	prefix accepted: C
 container:9.40194
 Box:9.33097	prefix accepted: 
 Cont:9.1638
  :9.14858
 Text:9.03908
 x:8.9433
 Rect:8.8661	prefix accepted: R

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Column>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow (
              (Prod
                 [(List
                     (Rec ("\206\177",
                        (Sum
                           [("Text",
                             (Some (Prod [String; (List (Var "Attribute"))])));
                             ("Column",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Row",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Container",
                              (Some (Prod
                                       [(Var "\206\177");
                                         (List (Var "Attribute"))])))
                             ])
                        )));
                   (List (Var "Attribute"))]),
              (Var "Widget")))})))
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Column
Nature of error: Expecting type Widget but got inconsistent type (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Column
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Column
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.3398
(_:17.5173	prefix accepted:(
([:16.7768	prefix accepted:(
 (:14.4239
((:13.0025	prefix accepted:(
 (_:12.2668	prefix accepted: (
 ([:11.3247	prefix accepted: (
 _:10.9461	prefix accepted: 
[:10.9271	rejected
 :10.9461
(__:10.539	prefix accepted:(
 children:10.5292	prefix accepted: 
 widget:10.294	prefix accepted: 
({:10.2234	prefix accepted:(
 _,:9.82913	prefix accepted: 
  :9.70791
(*:9.61716	prefix accepted:(
():9.46666	prefix accepted:(
(...:9.32384	prefix accepted:(
,:9.18278	rejected
(?:9.00107	prefix accepted:(

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
children:15.9378
widget:14.4594
ws:13.5016
xs:13.3754
items:12.9379
contents:12.5589
list:12.485
child:12.4517
elements:12.329
sub:12.2595
w:12.225
inner:12.0901
 children:11.9705
content:11.916
_,:11.8034	prefix accepted:_
nested:11.7807
rows:11.7708
columns:11.5343
ele:11.334
column:11.2843
 widget:11.2737

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <children>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: children
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: children
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:19.3776
 ,:16.4995
_:14.198
):13.8029
_,:13.7818	prefix accepted:_
 :13.6992
1:13.1233
',:12.2701	rejected
  :11.8554
 _,:11.7279	prefix accepted: 
::11.5123	rejected
),:11.304	prefix accepted:)
 :::11.1743	prefix accepted: 
 ::10.8791	prefix accepted: 
0:10.7904
 [],:10.5335	prefix accepted: 
    :10.3669
 =:10.3444	prefix accepted: 
:::10.311	rejected
,[:10.2762	prefix accepted:,
 ):10.2588

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "Margin" | "Padding" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 _):20.1759	prefix accepted: _
 _:20.1759
 attributes:15.5314
 attr:15.0482
_):14.7016	prefix accepted:_
 :13.4987
 __:12.1805	prefix accepted: _
_:14.7016
 att:12.0608
 a:11.121
 children:10.8445
 params:10.8102
 xs:10.6372
 [:10.5259
 args:10.4234
 _,:10.4192	prefix accepted: _
 options:10.2846
 *):10.2006	prefix accepted: 
 [_:10.1972	prefix accepted: [
 style:10.0845
 ):10.0691	prefix accepted: 
Rejected the highest logit candidate  _) with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= new-tokens

Top 20 Logits:
 ):17.476
 :13.8099
attributes:12.5829	rejected
 _):11.9819	prefix accepted: 
),:11.7568	prefix accepted:)
  :11.7306
)=:11.6775	prefix accepted:)
attr:11.6452	rejected
)|:11.4145	prefix accepted:)
 :::11.2728
 ),:10.9535	prefix accepted: )
 attributes:10.7944	prefix accepted: 
)->:10.5559	prefix accepted:)
 attr:10.1376	prefix accepted: 
)::9.95936	prefix accepted:)
    :9.88302
:::9.81919
   :9.50234
     :9.39186
):11.7568
 /*:9.12309	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ )

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ )
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.1303
 :14.0768
 |:13.6187	prefix accepted: 

:13.007
=>:12.5073
 ||:12.1174	prefix accepted: 
|:12.0987	rejected
 ->:11.2521	prefix accepted: 
  :11.2057
 or:10.2102	prefix accepted: 
    :9.60256
   :9.13126
 then:8.92274	prefix accepted: 
     :8.4657
      :8.44903
->:8.19805	rejected
        :7.98815
 =:7.96453
 :=:7.95194	prefix accepted: 
 as:7.88921	prefix accepted: 
||:7.85304	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) =>

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) =>
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  children find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "children" | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 List:17.3294
 :16.795

:16.2082
 find:15.8228
 if:15.4886
 children:15.0175
 let:14.0279
 [:13.4371
 (:13.1999
 #:12.9323	prefix accepted: 
  :12.2989
 list:11.441	prefix accepted: l
 child:11.3129
 Array:11.0297	prefix accepted: 
 match:11.0126	prefix accepted: 
    :10.9825
 column:10.9032	prefix accepted: c
 filter:10.8394	prefix accepted: fi
 conc:10.6062	prefix accepted: c
 fol:10.5451	prefix accepted: f
 []:10.3142

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  children find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:23.7768
.(:15.7887	prefix accepted:.
_:13.6231	rejected
.@:13.0128	prefix accepted:.
@:12.1988	rejected
2:12.0682	rejected
(:11.2818	rejected
.[:10.9378	prefix accepted:.
Util:10.7934	rejected
/:10.7728	rejected
s:10.7478	rejected
 .:10.6834	rejected
.<:10.5467	prefix accepted:.
Utils:10.5349	rejected
 @:10.5167	rejected
[:10.4793	rejected
:::10.4752	rejected
x:10.4641	rejected
._:10.4295	prefix accepted:.
..:10.1966	prefix accepted:.
1:10.0902	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  children find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "filter" | "fold_left" | "fold_right" | "init" | "rev" | "tl"
root ::= completions

Top 20 Logits:
fold:20.7747
filter:20.3281
concat:18.7088	prefix accepted:con
map:17.7261	rejected
rev:17.6031
flat:17.0385	prefix accepted:f
cons:16.2057
append:16.1649	rejected
fl:16.0427	prefix accepted:f
find:16.02	prefix accepted:fi
init:14.9909
reverse:14.6944	prefix accepted:rev
join:13.8755	rejected
tl:13.858
bind:13.4796	rejected
collect:13.4381	prefix accepted:co
merge:13.2103	rejected
reduce:13.1934	prefix accepted:re
contains:13.0576	prefix accepted:con
remove:13.0277	prefix accepted:re
add:12.9847	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold"))
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.fold
Nature of error: Variable List.fold is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold
LSP: Generating Completions for prefix: List.fold
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  children find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_left" | "_right"
root ::= completions

Top 20 Logits:
_:20.9965
r:16.8465	rejected
((:16.2108	rejected
l:16.1698	rejected
(:15.3145	rejected
([:15.0042	rejected
Left:13.8507	rejected
left:12.2308	rejected
Right:12.0528	rejected
 (:11.6481	rejected
[:11.3856	rejected
 ((:11.273	rejected
i:11.2277	rejected
right:10.9671	rejected
(_:10.9595	rejected
-:10.6412	rejected
_(:10.6335	prefix accepted:_
ing:10.5965	rejected
f:10.3617	rejected
(::10.2787	rejected
(@:10.1567	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold_"))
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.fold_
Nature of error: Variable List.fold_ is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold_
LSP: Generating Completions for prefix: List.fold_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  children find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "left" | "right"
root ::= completions

Top 20 Logits:
left:27.5595
right:26.362
map:16.8436	rejected
r:16.6251
bottom:16.3429	rejected
flat:15.9739	rejected
top:15.6654	rejected
l:15.493
down:15.3884	rejected
list:15.2007	prefix accepted:l
rig:15.0494
Left:14.9895	rejected
center:14.9162	rejected
up:14.8703	rejected
with:14.4798	rejected
lef:14.3365
back:14.29	rejected
in:14.2694	rejected
append:14.1607	rejected
inline:14.0698	rejected
Right:14.0518	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_left>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Widget"));
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                     (Unknown TypeHole)));
                   (Unknown TypeHole); (List (Unknown TypeHole))]),
              (Unknown TypeHole)))})))
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.fold_left
Nature of error: Expecting type [Widget] but got inconsistent type ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: List.fold_left
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: List.fold_left
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  children find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
((:18.6713	prefix accepted:(
(:18.6713
([:14.486	prefix accepted:(
 ((:12.514	prefix accepted: (
<:12.5137	rejected
(@:12.4909	prefix accepted:(
(?:12.1587	prefix accepted:(
(&:11.8619	prefix accepted:(
 (:12.514
(():11.3093	prefix accepted:(
({:10.6992	prefix accepted:(
(|:10.6983	prefix accepted:(
(_:10.56	prefix accepted:(
(\:10.5134	prefix accepted:(
(::10.5009	prefix accepted:(
[:10.4141	rejected
($:10.3897	prefix accepted:(

:10.3004
(__:10.0793	prefix accepted:(
(%:9.56052	prefix accepted:(
(":9.42892	prefix accepted:(
Rejected the highest logit candidate (( with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Column Container List.cons List.contains List.filter List.fold_left List.fold_right List.init Row String.starts_with String.transform Text case  find_all_widgets_of_type fun  if  let  mod string_compare string_concat type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  children find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Abs" | "App" | "Column" | "Container" | "List.cons" | "List.contains" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "Row" | "String.starts_with" | "String.transform" | "Text" | "case " | "find_all_widgets_of_type" | "fun " | "if " | "let " | "mod" | "string_compare" | "string_concat" | "type "
root ::= new-tokens

Top 20 Logits:
fun:16.3263
find:14.7222
List:14.0701

:13.9209
 (:12.0792
fn:12.0122	prefix accepted:f
Text:11.6923
#:11.6792	rejected
lambda:11.2644	prefix accepted:l
cons:11.0505	prefix accepted:c
 #:11.0313	prefix accepted: 
concat:10.882	prefix accepted:c
func:10.8178	prefix accepted:fun
Widget:10.8146	rejected
 fun:10.6132
(\:10.527	prefix accepted:(
 :11.0313
String:9.90734
append:9.8798	rejected
begin:9.55676	rejected
list:9.55511	prefix accepted:l

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun ? ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "Text" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:15.2984
 xs:14.0608
 x:12.9091
 l:12.4862
 result:12.3122
 ws:12.1896
 children:12.0749
 accum:11.9125
 a:11.8359
 widget:11.7824
 all:11.6708
 (:11.4896
 res:11.489
 list:11.3234
 found:11.3218
 y:11.2996
 results:11.1031
 so:10.8681
 r:10.5927
 w:10.5317
 prev:10.397

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun acc ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:16.2958
 child:13.7664	prefix accepted: 
 x:12.7317	prefix accepted: 
 w:12.2638	prefix accepted: 
 ->:11.7559
 elem:11.3906	prefix accepted: 
 widget:11.1066	prefix accepted: 
 el:11.0094	prefix accepted: 
 c:10.9484	prefix accepted: 
u:10.7812
 _,:10.5635	prefix accepted: 
_:10.5533
 children:10.3613	prefix accepted: 
 item:10.3452	prefix accepted: 
 e:10.2917	prefix accepted: 
 ,:9.99176
 element:9.95579	prefix accepted: 
um:9.67556
1:9.61773
 curr:9.50638	prefix accepted: 
 row:9.35151	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "Text" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 child:16.6265
 x:15.829
 w:15.257
 c:13.5949
 elem:13.1566
 widget:12.9479
 curr:12.9219
 cur:12.3935
 next:12.1776
 item:12.1746
 el:12.0923
 e:11.9844
 element:11.9579
 sub:11.9566
 current:11.8455
 ch:11.5442
 new:11.153
 children:11.1052
 y:10.5609
 row:10.3896
 v:10.3687

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <child>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: child
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: child
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:19.0285
_:14.5617
 :14.2835
::14.0534
->:13.9304
 =>:12.7426	prefix accepted: 
':12.5494	rejected
 ::12.1435
 =:10.9511	prefix accepted: 
,:10.8535
1:10.714
Widget:10.633
 -:10.2973
 widget:10.2405	prefix accepted: 
  :10.078
 →:9.79322	prefix accepted: 

:9.77747
s:9.6562
 -->:9.60999	prefix accepted: -
 {:9.4805	prefix accepted: 
 <-:9.35662	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child ->

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child ->
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "child" | "children" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:15.6731
 find:14.135
 :13.8047

:13.7423
 if:13.6672
 (:13.574
 List:12.6796
 #:11.0475	prefix accepted: 
 let:10.7498
 fun:10.7051
 [:10.5109
 child:10.3574
 merge:10.2655	prefix accepted: m
 @:10.0718	prefix accepted: 
 cons:10.0194	prefix accepted: co
 match:9.81883	prefix accepted: ma
acc:9.79269
 Text:9.7696
 ((:9.64605	prefix accepted: (
 f:9.61641
 function:9.41256	prefix accepted: fun

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 @:19.8918
 ++:17.8901
@:14.0725
 +:13.9669
++:12.9397
 #:12.7471	prefix accepted: 
 &:12.1071
 ||:11.9919	prefix accepted: 
 ^:11.8777	prefix accepted: 
 <>:11.8325	prefix accepted: <
 :12.7471
 $:11.6135
 :::11.4733
 |:11.3442	prefix accepted: 
 <:11.8325
 %:10.8354	prefix accepted: 
 &&:10.806
 ::10.7225
:::10.3771
 `:10.2684	prefix accepted: 
 `@:10.0855	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "child" | "children" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 find:18.831
 (:16.3741
@:13.922	rejected
 List:13.314
 if:12.6221
 :12.5515
 [:11.9432
#:11.4731	rejected
@@:11.4289	rejected

:11.1225
 @:11.0897	prefix accepted: 
find:11.0598
 Text:11.0559
 Find:10.7988	prefix accepted: 
*:10.6661	rejected
 #:10.6183	prefix accepted: 
+:9.88634	rejected
 ((:9.73561	prefix accepted: (
[:9.7313
(:9.65243
=:9.09989	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find"))
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find
Nature of error: Variable find is not bound  
Error in term:
  fun (acc, child) ->
 acc @ find
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find
LSP: Generating Completions for prefix: find
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_all_widgets_of_type"
root ::= completions

Top 20 Logits:
_:21.5329
(:12.515	rejected
All:11.9518	rejected
all:11.2134	rejected
Widget:10.5955	rejected
er:10.3977	rejected
,:10.214	rejected
 all:9.90937	rejected
Children:9.66102	rejected
((:8.9957	rejected
(),:8.93884	rejected
W:8.91966	rejected
 (:8.61779	rejected
Child:8.56927	rejected
-:8.51753	rejected
_(:8.38253	prefix accepted:_
_,:8.20503	prefix accepted:_
widget:8.12022	rejected
Text:8.08541	rejected
 widget:8.06588	rejected
([:8.04135	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_"))
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_
Nature of error: Variable find_ is not bound  
Error in term:
  fun (acc, child) ->
 acc @ find_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_
LSP: Generating Completions for prefix: find_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "all_widgets_of_type"
root ::= completions

Top 20 Logits:
all:27.0986
any:16.7568	prefix accepted:a
and:13.3646	prefix accepted:a
only:13.2888	rejected
al:13.2767
widget:13.2629	rejected
always:13.1357	prefix accepted:al
single:13.0074	rejected
in:12.8884	rejected
with:12.663	rejected
if:12.3822	rejected
alone:12.1594	prefix accepted:al
active:12.1579	prefix accepted:a
 all:12.1409	rejected
add:12.1268	prefix accepted:a
match:11.8924	rejected
a:16.7568
some:11.5042	rejected
array:11.5	prefix accepted:a
able:11.4981	prefix accepted:a
first:11.4417	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all"))
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all
Nature of error: Variable find_all is not bound  
Error in term:
  fun (acc, child) ->
 acc @ find_all
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all
LSP: Generating Completions for prefix: find_all
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_widgets_of_type"
root ::= completions

Top 20 Logits:
_:23.6746
(:14.2228	rejected
,:11.354	rejected
[:10.9009	rejected
((:10.4547	rejected
widget:10.0747	rejected
Widget:9.94686	rejected
__:9.84009	prefix accepted:_
(),:9.79381	rejected
([:9.6959	rejected
 widget:9.58679	rejected

:9.44246	rejected
_(:9.24217	prefix accepted:_
(@:9.21883	rejected
 (:9.09776	rejected
-:9.04462	rejected
<:8.9804	rejected
::8.93357	rejected
(_:8.77473	rejected
(':8.58967	rejected
_,:8.55908	prefix accepted:_

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_"))
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_
Nature of error: Variable find_all_ is not bound  
Error in term:
  fun (acc, child) ->
 acc @ find_all_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_
LSP: Generating Completions for prefix: find_all_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "widgets_of_type"
root ::= completions

Top 20 Logits:
widget:24.6339
w:13.7286
text:13.5666	rejected
with:13.3662	prefix accepted:wi
visual:13.1862	rejected
children:12.9442	rejected
 widget:12.9261	rejected
wig:12.8925	prefix accepted:wi
elements:12.8805	rejected
wid:12.489
layout:12.4554	rejected
columns:12.2954	rejected
s:11.9903	rejected
we:11.7944	prefix accepted:w
Widget:11.7941	rejected
components:11.7523	rejected
webpack:11.7411	prefix accepted:w
web:11.709	prefix accepted:w
width:11.658	prefix accepted:wid
f:11.3021	rejected
d:11.2573	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widget"))
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widget
Nature of error: Variable find_all_widget is not bound  
Error in term:
  fun (acc, child) ->
 acc @ find_all_widget
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widget
LSP: Generating Completions for prefix: find_all_widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s_of_type"
root ::= completions

Top 20 Logits:
s:25.5551
(:13.0394	rejected
_:12.0491	rejected
[:10.5482	rejected
t:10.3996	rejected
,:9.71867	rejected
$:9.36988	rejected
ss:9.21321	prefix accepted:s
ts:9.2117	rejected
 (:8.88534	rejected
 :8.57583	rejected
es:8.43888	rejected
st:8.4231	prefix accepted:s
<:8.34161	rejected
c:8.29181	rejected
{:8.26338	rejected

:8.02077	rejected
=:7.9825	rejected
с:7.96381	rejected
S:7.93674	rejected
as:7.79127	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets"))
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widgets
Nature of error: Variable find_all_widgets is not bound  
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets
LSP: Generating Completions for prefix: find_all_widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of_type"
root ::= completions

Top 20 Logits:
_:24.7729
(:16.3087	rejected
,:12.3426	rejected
((:12.2964	rejected
([:12.1734	rejected
(),:12.0824	rejected
 of:11.2826	rejected
 (:11.1912	rejected
Of:10.8808	rejected
[:10.8326	rejected
():10.5605	rejected
-:10.408	rejected
_(:10.3149	prefix accepted:_
__:10.2953	prefix accepted:_
1:10.0796	rejected

:10.0773	rejected
2:9.95387	rejected
)(:9.5555	rejected
(*:9.47834	rejected
(_:9.42037	rejected
,(:9.25008	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_"))
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widgets_
Nature of error: Variable find_all_widgets_ is not bound  
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_
LSP: Generating Completions for prefix: find_all_widgets_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "of_type"
root ::= completions

Top 20 Logits:
of:28.4794
list:15.1349	rejected
o:14.3966
 of:13.6024	rejected
off:12.9781	prefix accepted:of
if:12.9189	rejected
Of:12.7726	rejected
on:12.5413	prefix accepted:o
in:12.4254	rejected
only:12.3561	prefix accepted:o
or:12.2388	prefix accepted:o
by:12.1371	rejected
with:11.8974	rejected
ok:11.8672	prefix accepted:o
opt:11.6606	prefix accepted:o
over:11.6163	prefix accepted:o
no:11.5892	rejected
for:11.5871	rejected
0:11.4235	rejected
at:11.2947	rejected
match:11.2546	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of"))
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widgets_of
Nature of error: Variable find_all_widgets_of is not bound  
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of
LSP: Generating Completions for prefix: find_all_widgets_of
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_type"
root ::= completions

Top 20 Logits:
_:22.981
(:12.0108	rejected
_,:10.4491	prefix accepted:_
_(:10.4331	prefix accepted:_
 _:9.7343	rejected
 (:9.18926	rejected
(_:9.04763	rejected
__:8.7992	prefix accepted:_
 :8.66914	rejected
\_:8.65635	rejected
-:8.49634	rejected
[:8.45965	rejected
([:8.17699	rejected
(),:8.11882	rejected

:8.1125	rejected
__(:7.84779	prefix accepted:_
():7.79623	rejected
((:7.78361	rejected
_*:7.75771	prefix accepted:_
_.:7.70369	prefix accepted:_
(*:7.698	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of_"))
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets_of_
Nature of error: Variable find_all_widgets_of_ is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of_
LSP: Generating Completions for prefix: find_all_widgets_of_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "type"
root ::= completions

Top 20 Logits:
type:26.1808
types:14.3414	prefix accepted:type
ty:13.1168
typ:12.9284
text:12.7749	prefix accepted:t
test:12.3322	prefix accepted:t
ype:11.7864	rejected
Type:11.6609	rejected
 type:11.5362	rejected
the:11.118	prefix accepted:t
t:12.7749
name:10.9269	rejected
class:10.9154	rejected
this:10.6635	prefix accepted:t
value:10.5714	rejected
path:10.5099	rejected
a:10.4563	rejected
atype:10.3293	rejected
sub:10.3043	rejected
typename:10.2955	prefix accepted:type
ter:10.2815	prefix accepted:t

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_type>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn =
           (Arrow ((Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))]),
              (List (Var "Widget"))))})))
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widgets_of_type
Nature of error: Expecting type [?] but got inconsistent type ((Widget, (Widget -> Bool)) -> [Widget])  
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: find_all_widgets_of_type
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: find_all_widgets_of_type
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | "::"
root ::= new-tokens

Top 20 Logits:
(:21.9686
 (:16.7519
((:14.8455	prefix accepted:(
 child:13.6355	prefix accepted: 
([:13.49	prefix accepted:(
[:12.7303	rejected
(@:12.6715	prefix accepted:(
(?:12.5446	prefix accepted:(
(!:12.4744	prefix accepted:(
($:12.405	prefix accepted:(
(),:12.3721	prefix accepted:(
(*:12.0893	prefix accepted:(
.(:11.8924	rejected
(_:11.6657	prefix accepted:(
?(:11.6333	rejected
_:11.604	rejected

:11.4954
!(:11.429	rejected
,:11.2962
_(:11.2371	rejected
<:11.1741	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  child if  let  type  widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Var "Widget"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc children [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan bool_of_string case  ceil child children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "acc" | "case " | "child" | "if " | "let " | "type " | "widget"
root ::= completions | new-tokens

Top 20 Logits:
child:22.1873
widget:14.1928
f:13.9963	rejected
Text:13.6245
 child:13.2006
Widget:12.9721	rejected
#:12.6047	rejected
text:11.6572	prefix accepted:t
find:11.6161	rejected
w:10.9654

:10.8393
children:10.8274	prefix accepted:child
acc:10.7843
Child:10.6142	prefix accepted:C
 #:10.3543	prefix accepted: 
_,:10.2477	rejected
 :10.3543
row:9.71174	rejected
List:9.69934
x:9.65783	rejected
ch:9.49009

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <child>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: child
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: child
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  child if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ","
root ::= new-tokens

Top 20 Logits:
,:20.2212
 ,:15.0856
),:14.9675	prefix accepted:)
)),:11.1308	prefix accepted:)
):14.9675
)(:10.9833	prefix accepted:)
 f:10.8585	prefix accepted: 
,(:10.7483	prefix accepted:,
,[:10.5742	prefix accepted:,
 :10.8585
)):10.1345	prefix accepted:)
::9.97331	rejected
,\:9.36638	prefix accepted:,
.:9.29653	rejected
 @:9.04878	prefix accepted: 
 ),:8.97672	prefix accepted: )
 ::8.82683	prefix accepted: 
(),:8.77384	prefix accepted:(
@:8.75338	rejected
[:8.56784	rejected

:8.37657

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc f ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right acc case  child f fun  if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  child if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "acc" | "case " | "child" | "f" | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 f:20.4106
f:16.3884
 :14.5572
 (:11.5612
 predicate:11.1984	prefix accepted: 
 _:11.1782	prefix accepted: 
 fun:11.101
 pred:11.0838	prefix accepted: 
 x:10.913	prefix accepted: 
 widget:10.7192	prefix accepted: 
 ?:10.6717	prefix accepted: 
 func:10.6332	prefix accepted: fun
 acc:10.3263
 function:10.2239	prefix accepted: fun

:10.208
 $:10.2002	prefix accepted: 
 id:10.1558	prefix accepted: i
 true:10.0943	prefix accepted: t
 _):10.0676	prefix accepted: 
 p:10.0125	prefix accepted: 
  :9.94715

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <f>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: f
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: f
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: child acc f ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right acc case  child f fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "un "
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
),:22.0098	prefix accepted:)
):22.0098
)):15.8716	prefix accepted:)
)),:14.5918	prefix accepted:)
 ),:14.4357	prefix accepted: )
)[:12.049	prefix accepted:)
),(:11.5775	prefix accepted:)
);:11.5541	prefix accepted:)
)::11.363	prefix accepted:)
 :11.2968
).:11.2039	prefix accepted:)
 ):14.4357
));:10.5962	prefix accepted:)
)(:10.4637	prefix accepted:)
 =:10.1945	prefix accepted: 
))::10.0469	prefix accepted:)
),\:9.82761	prefix accepted:)
::9.82617	rejected
)",:9.76033	prefix accepted:)
)).:9.49582	prefix accepted:)
()),:9.43303	prefix accepted:(
Rejected the highest logit candidate ), with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Var "Widget"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 end:16.778	prefix accepted: 
 ,:15.5874
 :16.778

:12.6718
 if:12.3998	prefix accepted: 
 [],:11.6633	prefix accepted: 
end:10.9664	rejected
  :10.7525
   :10.5579
 @:10.1706
 ):10.1388
 in:9.91394	prefix accepted: 
 _,:9.67841	prefix accepted: 
 ;:9.44534	prefix accepted: 
(),:9.19711	rejected
 as:9.15238	prefix accepted: 
    :9.14572
 |:9.0951	prefix accepted: 
 ?:9.07743	prefix accepted: 
 ),:8.97974	prefix accepted: )
 ::8.89839
Rejected the highest logit candidate  end with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f) 

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f) 
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {child: ?, acc: ?, children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Var "Widget"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.7733
 end:18.3995	prefix accepted: 

:17.0153
 [],:13.6414	prefix accepted: 
 if:13.5899	prefix accepted: 
 @:12.8644
 ):12.4672
,":12.4239	prefix accepted:,
 in:12.2854	prefix accepted: 
 ),:12.2178	prefix accepted: )
 #:11.9636	prefix accepted: 
0:11.8664	rejected
 _,:11.8657	prefix accepted: 
 (:11.6805	prefix accepted: 
	:11.6777	rejected
1:11.6166	rejected
 [:11.2812	prefix accepted: 
,[:11.1082	prefix accepted:,
 as:11.0035	prefix accepted: 
 |:10.9401	prefix accepted: 
 []:10.8716	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  ,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  ,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f) 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> [Widget]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (List (Var "Widget"))));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> [Widget]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (List (Var "Widget"))));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: children f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Column Container List.cons List.contains List.filter List.fold_left List.fold_right List.init Row String.starts_with String.transform Text case  find_all_widgets_of_type fun  if  let  mod string_compare string_concat type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "children" | "cos" | "epsilon_float" | "exp" | "f" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [],:17.4741	prefix accepted: []
 find:14.4866
[:14.2308
 children:13.5046
 [:13.3065
 []:17.4741
 :12.5782
 f:12.4807
 if:12.4703
 (:12.3775
 List:12.1008
find:12.0184

:11.2865
  :10.605
[]:10.4043
 _,:10.3618	prefix accepted: 
if:10.2137
 widget:9.9896
[]):9.56337	prefix accepted:[]
f:9.34751
 acc:9.27341	prefix accepted: ac
Rejected the highest logit candidate  [], with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  ,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: children f widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil children cos epsilon_float exp f false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.4838	prefix accepted: 
 :16.4838
  :14.7364
   :14.4205
                :13.6235
    :13.5664
 as:13.1845	prefix accepted: 
     :13.1061
 ::12.8385
       :12.7141
 end:12.4404	prefix accepted: 
::12.3699
 ):12.2392
        :12.2055
      :12.13
               :12.0653
          :11.9242
         :11.7492
            :11.4883
              :11.4572

:11.3696
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , [] 

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , [] 
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.1937	prefix accepted: 
 end:15.1299	prefix accepted: 
 ):14.9302
 ::14.4492
 (:14.3436	prefix accepted: 

:14.2601
 as:14.2345	prefix accepted: 
 :::13.8026
 #:13.2243	prefix accepted: 
 @:13.2163
	:12.823	rejected
 ),:12.4189	prefix accepted: )
)::12.2516	prefix accepted:)
 if:12.1421	prefix accepted: 
 [:11.8079	prefix accepted: 
 <:11.7773	prefix accepted: 
 (*:11.6835	prefix accepted: 
 children:11.5766	prefix accepted: 
 ;:11.4483	prefix accepted: 
 (@:11.4396	prefix accepted: 
 ([:10.9841	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []  

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []  
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , [] 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.2585	prefix accepted: 
 ):14.8583
 ::14.6214
 (:14.4618	prefix accepted: 

:14.2611
 :::14.2521
 end:14.195	prefix accepted: 
 as:13.8014	prefix accepted: 
 @:13.4951
 #:13.393	prefix accepted: 
	:12.9577	rejected
 <:12.2429	prefix accepted: 
)::12.1822	prefix accepted:)
 ),:12.171	prefix accepted: )
 [:12.0573	prefix accepted: 
 (*:11.8156	prefix accepted: 
 ;:11.7423	prefix accepted: 
 if:11.7391	prefix accepted: 
 children:11.7337	prefix accepted: 
 *:11.5184	prefix accepted: 
 (@:11.4873	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []   

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []   
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []  
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.2181	prefix accepted: 
 ):14.8312
 (:14.446	prefix accepted: 
 ::14.1727

:14.1112
 end:13.8418	prefix accepted: 
 #:13.817	prefix accepted: 
 @:13.52
 :::13.4961
 children:13.0097	prefix accepted: 
	:13.0079	rejected
 ),:12.4202	prefix accepted: )
 [:12.3887	prefix accepted: 
 <:12.3548	prefix accepted: 
 as:12.1718	prefix accepted: 
 if:12.0277	prefix accepted: 
)::11.951	prefix accepted:)
 ;:11.7458	prefix accepted: 
 [],:11.6752	prefix accepted: 
 (*:11.6363	prefix accepted: 
 *:11.595	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []    

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []    
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.1895	prefix accepted: 
 ):14.7294
 (:14.4933	prefix accepted: 
 #:14.1275	prefix accepted: 

:13.7508
 end:13.6759	prefix accepted: 
 ::13.5953
 children:13.3608	prefix accepted: 
 @:13.1236
 [:12.9915	prefix accepted: 
 :::12.8442
	:12.7713	rejected
 ),:12.6457	prefix accepted: )
 if:12.4573	prefix accepted: 
 <:12.151	prefix accepted: 
 [],:12.0861	prefix accepted: 
 *:11.4907	prefix accepted: 
 ;:11.4124	prefix accepted: 
 |:11.2731	prefix accepted: 
 (*:11.2059	prefix accepted: 
 .:11.2025	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []     

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []     
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []    
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:19.9417	prefix accepted: 
 (:14.5335	prefix accepted: 
 ):14.4668
 children:13.4203	prefix accepted: 
 #:13.4013	prefix accepted: 

:13.3773
 [:13.37	prefix accepted: 
 end:13.2837	prefix accepted: 
 ::13.1835
 if:12.7242	prefix accepted: 
 [],:12.5893	prefix accepted: 
 ),:12.5382	prefix accepted: )
 :::12.2521
	:12.197	rejected
 @:12.0276
 <:11.8418	prefix accepted: 
 ():11.3988	prefix accepted: 
 .:11.3031	prefix accepted: 
 |:11.1311	prefix accepted: 
 list:11.0174	prefix accepted: 
 *:10.973	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []      

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []      
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.918	prefix accepted: 
 :18.918
 (:13.4316	prefix accepted: 
 ):13.4235
 [:12.8852	prefix accepted: 
  :12.7304
 [],:12.6877	prefix accepted: 
 children:12.6161	prefix accepted: 

:12.4899
 end:12.404	prefix accepted: 
 if:12.3321	prefix accepted: 
 ::12.0152
 #:11.9106	prefix accepted: 
 ),:11.5894	prefix accepted: )
   :11.3607
 :::11.0846
 ():10.8613	prefix accepted: 
 .:10.7298	prefix accepted: 
 []:10.6311	prefix accepted: 
 <:10.6228	prefix accepted: 
,:10.6216	rejected
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []       

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []       
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []      
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.6623	prefix accepted: 
 :16.6623
,:14.455	rejected
  :13.6946
   :12.3839
 [],:11.3135	prefix accepted: 
 [:11.1636	prefix accepted: 
 ):11.016
 if:10.8869	prefix accepted: 
,[:10.7626	rejected
     :10.7615
 (:10.7566	prefix accepted: 
    :10.6973

:10.6505
 children:10.4881	prefix accepted: 
                :10.2866
 end:10.205	prefix accepted: 
      :9.92384
       :9.71329
 ::9.49642
if:9.43625	rejected
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []        

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []        
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.3663	prefix accepted: 
 :16.3663
,:14.423	rejected
  :13.662
   :12.3923
 [],:11.41	prefix accepted: 
 [:11.0951	prefix accepted: 
,[:10.9015	rejected
     :10.8834
 if:10.786	prefix accepted: 
    :10.7711
 (:10.6874	prefix accepted: 
 ):10.647

:10.6259
                :10.3029
 children:10.2532	prefix accepted: 
      :10.0103
 end:9.97932	prefix accepted: 
       :9.84012
if:9.7962	rejected
[:9.77315	rejected
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []         

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []         
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []        
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.1732	prefix accepted: 
 :16.1732
,:13.7609	rejected
  :13.7366
   :12.5027
 [],:11.2758	prefix accepted: 
     :11.0422
 (:10.9697	prefix accepted: 
    :10.9178
 [:10.8368	prefix accepted: 
 ):10.5698

:10.5496
 if:10.4589	prefix accepted: 
,[:10.3228	rejected
                :10.2459
      :10.1731
 end:10.1082	prefix accepted: 
 children:10.0059	prefix accepted: 
       :9.96608
 []:9.53275	prefix accepted: 
if:9.39464	rejected
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []          

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []          
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []         
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.1933
 ,:16.0661	prefix accepted: 
  :13.7966
,:12.9981	rejected
   :12.5477
 (:11.2326	prefix accepted: 
     :11.1104
 [],:11.0287	prefix accepted: 
    :10.9787
 end:10.7249	prefix accepted: 
 [:10.6665	prefix accepted: 
 ):10.5387

:10.4972
      :10.2481
 if:10.2383	prefix accepted: 
                :10.0805
       :9.95189
 children:9.87562	prefix accepted: 
,[:9.59338	rejected
 ),:9.50981	prefix accepted: )
end:9.40569	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []          
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.5911
 ,:16.3995	prefix accepted: 
  :13.941
   :12.5655
,:12.2259	rejected
 end:11.851	prefix accepted: 
 (:11.6574	prefix accepted: 
     :11.1157
 [],:11.0844	prefix accepted: 
    :10.9765
 ):10.9091
 [:10.8776	prefix accepted: 

:10.6354
 if:10.4745	prefix accepted: 
      :10.2726
                :10.0752
 children:9.99	prefix accepted: 
       :9.95121
 ),:9.87728	prefix accepted: )
 #:9.36872	prefix accepted: 
end:9.15917	rejected

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []            

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []            
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.0663	prefix accepted: 
 :17.0663
  :13.9064
 end:12.9851	prefix accepted: 
 (:12.4684	prefix accepted: 
   :12.3315
 ):11.7242
 [],:11.5627	prefix accepted: 
 [:11.3776	prefix accepted: 
,:11.0469	rejected

:10.999
 if:10.9932	prefix accepted: 
     :10.858
    :10.7595
 ),:10.587	prefix accepted: )
 children:10.3084	prefix accepted: 
 #:10.0702	prefix accepted: 
      :10.0371
                :9.93396
 ::9.89205
       :9.75677
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []             

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []             
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []            
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.3244	prefix accepted: 
 :17.3244
 end:13.5567	prefix accepted: 
  :13.4907
 (:12.824	prefix accepted: 
 if:12.2831	prefix accepted: 
 ):12.1281
   :11.8652
 [],:11.6933	prefix accepted: 
 [:11.5011	prefix accepted: 

:11.1965
 ),:10.9376	prefix accepted: )
     :10.4059
 children:10.4029	prefix accepted: 
    :10.3746
 ::10.2957
 #:10.225	prefix accepted: 
,:10.2194	rejected
 in:10.1556	prefix accepted: 
 _,:9.8229	prefix accepted: 
 []:9.80048	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []              

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []              
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []             
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.0344
 ,:16.9185	prefix accepted: 
  :13.8685
 end:13.4736	prefix accepted: 
 (:12.3648	prefix accepted: 
   :12.2671
 if:11.8111	prefix accepted: 
 ):11.7565
 [],:11.3705	prefix accepted: 
 [:11.1269	prefix accepted: 

:10.8826
    :10.8684
     :10.8428
 ),:10.6417	prefix accepted: )
,:10.4112	rejected
 children:10.1697	prefix accepted: 
      :10.0878
 ::10.0222
                :9.99504
 in:9.86714	prefix accepted: 
       :9.82685

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []               

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []               
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []              
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.8827
 ,:16.2122	prefix accepted: 
  :13.8402
 end:13.0757	prefix accepted: 
   :12.4002
 (:11.5325	prefix accepted: 
,:11.2065	rejected
    :11.0921
 if:11.0889	prefix accepted: 
     :11.0471
 ):10.9972
 [],:10.8385	prefix accepted: 
 [:10.5582	prefix accepted: 

:10.4116
      :10.3327
                :10.1018
       :10.0184
 ),:9.98128	prefix accepted: )
end:9.87732	rejected
 children:9.67848	prefix accepted: 
 ::9.48177

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []               
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.7352
 ,:15.8866	prefix accepted: 
  :13.7362
 end:12.9282	prefix accepted: 
   :12.3496
,:11.6102	rejected
 (:11.1014	prefix accepted: 
    :11.0593
     :11.0148
 if:10.8611	prefix accepted: 
 [],:10.6408	prefix accepted: 
 ):10.5814
end:10.5214	rejected
 [:10.3322	prefix accepted: 
      :10.3294

:10.1675
                :10.0308
       :9.99399
 ),:9.60629	prefix accepted: )
 ::9.41352
 children:9.32958	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                 

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                 
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.7327
 ,:15.7897	prefix accepted: 
  :13.7379
 end:12.8651	prefix accepted: 
   :12.3776
,:11.5815	rejected
    :11.0966
     :11.0464
 (:10.9214	prefix accepted: 
 if:10.898	prefix accepted: 
end:10.6224	rejected
 [],:10.6038	prefix accepted: 
 ):10.3929
      :10.3818
 [:10.2375	prefix accepted: 
                :10.0646

:10.0577
       :10.0561
 ::9.53677
        :9.38246
 ),:9.38099	prefix accepted: )

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                  

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                  
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.7797
 ,:15.7644	prefix accepted: 
  :13.7737
 end:12.8215	prefix accepted: 
   :12.4582
,:11.3692	rejected
    :11.2023
     :11.1248
 if:10.9466	prefix accepted: 
 (:10.8949	prefix accepted: 
 [],:10.6397	prefix accepted: 
end:10.5288	rejected
      :10.4468
 ):10.3316
 [:10.1644	prefix accepted: 
       :10.1395
                :10.1362

:10.0762
 ::9.61432
        :9.47083
         :9.31353

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                   

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                   
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                  
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.8923
 ,:15.7925	prefix accepted: 
  :13.8884
 end:12.7848	prefix accepted: 
   :12.5976
    :11.3567
     :11.2428
,:11.2156	rejected
 [:11.1383	prefix accepted: 
 (:10.9819	prefix accepted: 
 if:10.8284	prefix accepted: 
 [],:10.6731	prefix accepted: 
      :10.512
 ):10.3455
end:10.2718	rejected

:10.2279
       :10.2119
                :10.2107
 ::9.5852
        :9.52153
 ),:9.37242	prefix accepted: )

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                    

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                    
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.9744
 ,:15.7886	prefix accepted: 
  :13.9953
   :12.7131
 end:12.6591	prefix accepted: 
    :11.486
     :11.351
,:11.2706	rejected
 [:11.0385	prefix accepted: 
 (:11.0228	prefix accepted: 
 [],:10.5787	prefix accepted: 
      :10.5706
 if:10.5036	prefix accepted: 

:10.3836
 ):10.312
       :10.2459
                :10.2371
end:10.026	rejected
        :9.52102
 ::9.44892
 ),:9.37407	prefix accepted: )

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                     

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                     
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                    
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.9763
 ,:15.7357	prefix accepted: 
  :13.997
   :12.7179
 end:12.5826	prefix accepted: 
    :11.5124
,:11.4867	rejected
     :11.3811
 (:10.9351	prefix accepted: 
 [:10.843	prefix accepted: 
      :10.5893

:10.4199
 [],:10.3947	prefix accepted: 
       :10.215
 ):10.1998
                :10.1939
 if:10.1682	prefix accepted: 
end:10.018	rejected
        :9.46281
 ::9.34485
 ),:9.29873	prefix accepted: )

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                      

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                      
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.9864
 ,:15.6999	prefix accepted: 
  :13.9474
 end:12.6659	prefix accepted: 
   :12.6557
,:11.7651	rejected
    :11.4661
     :11.3505
 (:10.8201	prefix accepted: 
 [:10.6929	prefix accepted: 
      :10.574

:10.3856
 [],:10.2726	prefix accepted: 
       :10.1713
end:10.1554	rejected
                :10.1281
 ):10.1038
 if:10.0573	prefix accepted: 
        :9.40235
 ::9.37265
 ),:9.20896	prefix accepted: )

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                       

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                       
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                      
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.0261
 ,:15.7019	prefix accepted: 
  :13.902
 end:12.8113	prefix accepted: 
   :12.5903
,:11.9675	rejected
    :11.4154
     :11.3116
 (:10.7825	prefix accepted: 
 [:10.6674	prefix accepted: 
      :10.5535

:10.3619
 [],:10.2877	prefix accepted: 
end:10.2744	rejected
       :10.1568
 if:10.1511	prefix accepted: 
 ):10.0874
                :10.0743
 ::9.49874
        :9.39196
 ),:9.15235	prefix accepted: )

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                        

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                        
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.0727
 ,:15.7307	prefix accepted: 
  :13.885
 end:12.9086	prefix accepted: 
   :12.5431
,:11.9755	rejected

:11.4158
    :11.3884
     :11.2795
 (:10.8318	prefix accepted: 
 [:10.7449	prefix accepted: 
      :10.5224
 [],:10.433	prefix accepted: 
 if:10.279	prefix accepted: 
end:10.264	rejected
 ):10.1498
       :10.1484
                :10.0327
 ::9.62771
        :9.42028
 ),:9.15173	prefix accepted: )

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                         

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                         
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                        
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.1042
 ,:15.7531	prefix accepted: 
  :13.8776
 end:12.9246	prefix accepted: 
   :12.4907
,:11.8318	rejected

:11.4498
    :11.349
     :11.2307
 (:10.9003	prefix accepted: 
 [:10.8557	prefix accepted: 
 [],:10.6392	prefix accepted: 
      :10.4566
 if:10.3642	prefix accepted: 
 ):10.2396
end:10.1367	rejected
       :10.1155
                :9.97399
 ::9.6772
        :9.43954
 children:9.2045	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                          

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                          
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                         
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.1328
 ,:15.7718	prefix accepted: 
  :13.8661
 end:12.9151	prefix accepted: 
   :12.4268
,:11.6339	rejected

:11.4686
    :11.2846
     :11.1633
 (:10.9506	prefix accepted: 
 [:10.9413	prefix accepted: 
 [],:10.8014	prefix accepted: 
 if:10.439	prefix accepted: 
      :10.3719
 ):10.3356
       :10.0711
end:9.97577	rejected
                :9.89777
 ::9.68855
        :9.44114
 find:9.35202	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                          
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.1738
 ,:15.8053	prefix accepted: 
  :13.8523
 end:12.9143	prefix accepted: 
   :12.3567

:11.468
,:11.4252	rejected
    :11.2022
     :11.0786
 (:11.0018	prefix accepted: 
 [:10.997	prefix accepted: 
 [],:10.8889	prefix accepted: 
 if:10.4979	prefix accepted: 
 ):10.4337
      :10.2711
       :10.0101
                :9.8016
end:9.78149	rejected
 ::9.71672
 find:9.6467	prefix accepted: 
        :9.4139

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                            

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                            
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.2219
 ,:15.8594	prefix accepted: 
  :13.8407
 end:12.9231	prefix accepted: 
   :12.2892

:11.4613
,:11.2067	rejected
    :11.1145
 (:11.0717	prefix accepted: 
 [:11.0384	prefix accepted: 
     :10.9843
 [],:10.9478	prefix accepted: 
 if:10.5458	prefix accepted: 
 ):10.5255
      :10.1558
 find:9.9455	prefix accepted: 
       :9.93114
 ::9.7675
                :9.68986
end:9.5211	rejected
        :9.35606

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                             

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                             
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                            
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.2639
 ,:15.9389	prefix accepted: 
  :13.83
 end:12.9422	prefix accepted: 
   :12.2303

:11.4693
 (:11.1586	prefix accepted: 
 [:11.0772	prefix accepted: 
    :11.0323
 [],:11.0229	prefix accepted: 
,:10.956	rejected
     :10.8941
 if:10.6266	prefix accepted: 
 ):10.6136
 find:10.2268	prefix accepted: 
      :10.0395
       :9.85088
 ::9.83904
                :9.58277
 ),:9.47009	prefix accepted: )
 children:9.36682	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                              

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                              
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                             
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.2896
 ,:16.0519	prefix accepted: 
  :13.8042
 end:12.9882	prefix accepted: 
   :12.1649

:11.5087
 (:11.2625	prefix accepted: 
 [:11.1249	prefix accepted: 
 [],:11.1175	prefix accepted: 
    :10.9425
     :10.8009
 if:10.7699	prefix accepted: 
 ):10.7188
,:10.66	rejected
 find:10.4438	prefix accepted: 
 ::9.9329
      :9.91789
       :9.7683
 ),:9.64651	prefix accepted: )
                :9.48745
 children:9.45448	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                               

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                               
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                              
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.2742
 ,:16.1765	prefix accepted: 
  :13.7338
 end:13.0526	prefix accepted: 
   :12.0678

:11.5708
 (:11.3657	prefix accepted: 
 [],:11.2193	prefix accepted: 
 [:11.1907	prefix accepted: 
 if:10.9587	prefix accepted: 
 ):10.8388
    :10.8231
     :10.6864
 find:10.5602	prefix accepted: 
,:10.3542	rejected
 ::10.0225
 ),:9.84755	prefix accepted: )
      :9.77518
       :9.66493
 []:9.58226	prefix accepted: 
 children:9.57368	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                               
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.2156
 ,:16.2759	prefix accepted: 
  :13.6171
 end:13.0979	prefix accepted: 
 ):12.0448
   :11.9393

:11.6252
 (:11.4429	prefix accepted: 
 [],:11.3059	prefix accepted: 
 [:11.2649	prefix accepted: 
 if:11.1524	prefix accepted: 
    :10.6769
 find:10.577	prefix accepted: 
     :10.5537
,:10.1009	rejected
 ::10.0791
 ),:10.0282	prefix accepted: )
 children:9.71282	prefix accepted: 
 []:9.70003	prefix accepted: 
      :9.61884
       :9.54001

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                 

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                 
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.1447
 ,:16.3456	prefix accepted: 
  :13.4867
 end:13.1236	prefix accepted: 
 ):12.1577
   :11.8077

:11.6558
 (:11.5015	prefix accepted: 
 [],:11.3498	prefix accepted: 
 if:11.3252	prefix accepted: 
 [:11.3243	prefix accepted: 
    :10.5299
 find:10.5072	prefix accepted: 
     :10.4268
 ),:10.1828	prefix accepted: )
 ::10.1221
,:9.92864	rejected
 children:9.8654	prefix accepted: 
 []:9.77681	prefix accepted: 
      :9.47665
       :9.41509

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                  

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                  
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.0677
 ,:16.4202	prefix accepted: 
  :13.3527
 end:13.2014	prefix accepted: 
 ):12.298
   :11.6832

:11.6741
 (:11.5771	prefix accepted: 
 if:11.4663	prefix accepted: 
 [:11.3486	prefix accepted: 
 [],:11.3438	prefix accepted: 
    :10.3899
 find:10.3651	prefix accepted: 
 ),:10.3562	prefix accepted: )
     :10.3096
 ::10.2117
 children:9.99943	prefix accepted: 
 []:9.80894	prefix accepted: 
,:9.79719	rejected
 ():9.40334	prefix accepted: 
      :9.35123

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                   

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                   
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                  
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.992
 ,:16.5065	prefix accepted: 
 end:13.3659	prefix accepted: 
  :13.2289
 ):12.4545

:11.6884
 (:11.6637	prefix accepted: 
   :11.5837
 if:11.5657	prefix accepted: 
 [:11.3155	prefix accepted: 
 [],:11.2899	prefix accepted: 
 ),:10.552	prefix accepted: )
 ::10.3519
    :10.2787
     :10.218
 find:10.1956	prefix accepted: 
 children:10.0724	prefix accepted: 
 []:9.79147	prefix accepted: 
,:9.67544	rejected
 ():9.48966	prefix accepted: 
 _,:9.37861	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                    

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                    
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.9393
 ,:16.5903	prefix accepted: 
 end:13.5798	prefix accepted: 
  :13.1346
 ):12.5881
 (:11.7333	prefix accepted: 

:11.7155
 if:11.6544	prefix accepted: 
   :11.5198
 [:11.2499	prefix accepted: 
 [],:11.2173	prefix accepted: 
 ),:10.7394	prefix accepted: )
 ::10.493
    :10.211
     :10.1618
 children:10.0864	prefix accepted: 
 find:10.0399	prefix accepted: 
 []:9.73964	prefix accepted: 
 ():9.57279	prefix accepted: 
,:9.55501	rejected
 _,:9.42764	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                     

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                     
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                    
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.9015
 ,:16.6668	prefix accepted: 
 end:13.8013	prefix accepted: 
  :13.0531
 ):12.689
 if:11.7921	prefix accepted: 
 (:11.7839	prefix accepted: 

:11.7725
   :11.4613
 [:11.2197	prefix accepted: 
 [],:11.1789	prefix accepted: 
 ),:10.8987	prefix accepted: )
 ::10.5998
    :10.1551
     :10.111
 children:10.0871	prefix accepted: 
 find:9.90947	prefix accepted: 
 []:9.70346	prefix accepted: 
 ():9.63457	prefix accepted: 
 _,:9.49212	prefix accepted: 
 |:9.48058	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                      

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                      
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.8834
 ,:16.7156	prefix accepted: 
 end:13.977	prefix accepted: 
  :12.9813
 ):12.7498
 if:11.9715	prefix accepted: 

:11.8415
 (:11.8092	prefix accepted: 
   :11.3986
 [:11.2442	prefix accepted: 
 [],:11.1856	prefix accepted: 
 ),:11.0012	prefix accepted: )
 ::10.6498
 children:10.1158	prefix accepted: 
    :10.0971
     :10.0595
 find:9.80864	prefix accepted: 
 []:9.70601	prefix accepted: 
 ():9.66564	prefix accepted: 
 |:9.58626	prefix accepted: 
 _,:9.55995	prefix accepted: 

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                       

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                       
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                      
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {children: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], f: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, child) ->
 acc @ find_all_widgets_of_type(child, f), 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.9409
 ,:16.7024	prefix accepted: 
 end:14.0504	prefix accepted: 
  :12.9788
 ):12.7518
 if:12.114	prefix accepted: 

:11.8807
 (:11.7848	prefix accepted: 
   :11.3923
 [:11.2791	prefix accepted: 
 [],:11.1987	prefix accepted: 
 ),:11.0222	prefix accepted: )
 ::10.6199
 children:10.1654	prefix accepted: 
    :10.0935
     :10.0681
 find:9.72885	prefix accepted: 
 []:9.72231	prefix accepted: 
 ():9.65306	prefix accepted: 
 |:9.63766	prefix accepted: 
 #:9.62964	prefix accepted: 
