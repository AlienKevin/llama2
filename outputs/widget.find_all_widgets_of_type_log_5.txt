

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
   


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
       


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go:


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget])


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) ->


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget]


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] =


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
           


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
               


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget)


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                   


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
               


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                   


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                   


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    |


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _)


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) =>


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                   


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    |


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _)


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) =>


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x ->


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))),


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                   


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    |


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _)


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) =>


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc ->


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)),


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                   


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    |


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _)


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) =>


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => [] 


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  #


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case:


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widget


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                   


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
       


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
       


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.rev


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.rev(


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.rev(go


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.rev(go(


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.rev(go(container


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.rev(go(container,


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.rev(go(container, []


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.rev(go(container, []))


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.rev(go(container, []))



================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.rev(go(container, []))
in


================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun container, f ->
        let rec go: (Widget, [Widget]) -> [Widget] = 
            fun widget, acc ->
                if f(widget) then
                    widget::acc
                else
                    match widget
                    | Container(child_widget, _) => go(child_widget, acc)
                    | Row(children, _) => List.fold_left((fun acc, x -> List.rev(go(x, acc))), acc, children)
                    | Column(children, _) => List.fold_right((fun x, acc -> go(x, acc)), children, [])
                    | Text(_, _) => []  # base case: text cannot have child widgets #
                    end
        in
        List.rev(go(container, []))
in


