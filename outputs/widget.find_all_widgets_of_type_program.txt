type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                       

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

# Find all widgets satisfying a given predicate function. #
# All widgets, including the nested ones, will be tested. #
let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, f ->
        case widget
            | Text(_ , _ ) => if f(widget) then [widget] else []
            | Column(children, _ ) => List.fold_left(fun acc, child -> acc @ find_all_widgets_of_type(child, f)  , []                                       
