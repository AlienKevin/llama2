

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Target types: ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:19.7245
 :17.0451
 fun:14.7637
  :14.6908
    :13.9412
                :12.5682
   :11.9667
     :11.9231
 function:11.8912	prefix accepted: fun
 #:11.8717	prefix accepted: 
	:11.7508	rejected
      :11.3313
        :11.2887
 (:11.2319
 \:10.8053	prefix accepted: 
       :10.7318
            :10.4447
 {:10.3739	prefix accepted: 
 ?:10.355	prefix accepted: 
 (*:10.3354	prefix accepted: (
         :10.1648

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Target types: ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:22.1907
 fun:15.4433
	:13.4994	rejected
 #:13.2769	prefix accepted: 
 (*:13.1709	prefix accepted: (
 function:12.3423	prefix accepted: fun
 (:13.1709
 {:11.7921	prefix accepted: 
 ?:11.4183	prefix accepted: 
 %:11.0231	prefix accepted: 
0:10.9235	rejected
 func:10.8929	prefix accepted: fun
1:10.3001	rejected
 ~:10.298	prefix accepted: 
 *:10.239	prefix accepted: 
 //:10.166	prefix accepted: 
 #(:10.0371	prefix accepted: 
 f:9.9375
 fn:9.89804	prefix accepted: f
 [:9.806	prefix accepted: 
 ##:9.72068	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Target types: ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 :19.9272
fun:18.8433
   :18.5107
	:15.9549	rejected
  :15.7537
 fun:14.7497
     :14.0669
let:14.0199
       :13.9358

:13.5288
    :13.4614
func:12.9562	prefix accepted:fun
(:12.9309
(*:12.2113	prefix accepted:(
#:11.7225	rejected
function:11.5469	prefix accepted:fun
{:11.4134	rejected
 let:11.2584
fn:11.2543	prefix accepted:f
      :11.1117
           :11.0116

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Target types: ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:20.589
 #:15.0764	prefix accepted: 
 (*:14.817	prefix accepted: (
 let:14.7148
 (:14.817
 function:13.0073	prefix accepted: fun
 |:12.1693	prefix accepted: 
 ~:11.9688	prefix accepted: 
 {:11.8939	prefix accepted: 
 ##:11.8916	prefix accepted: 
 func:11.8148	prefix accepted: fun
 *:11.692	prefix accepted: 
 match:11.5971	prefix accepted: 
 lambda:11.4494	prefix accepted: l
 f:11.2478
 fn:11.0228	prefix accepted: f
 ?:10.9154	prefix accepted: 
 ((:10.6636	prefix accepted: (
 //:10.6284	prefix accepted: 
 switch:10.5487	prefix accepted: 
 proc:10.4475	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
 play:17.8845
 (:16.091
 pl:15.5637
 p:14.2659
 current:14.2335
 old:13.966
 ((:13.6732	prefix accepted: (
 song:13.3376
 state:12.9287
 [:12.8009
 ([:12.7756	prefix accepted: (
(:12.3676
 list:12.3243
 pair:12.1187
 curr:12.0353
 pal:12.0188
 input:11.8974
 {:11.815	prefix accepted: 
 ({:11.7034	prefix accepted: (
 s:11.6732
 x:11.639

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {play: (PlayList, PlayListAction), update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: play
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: play
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
list:19.8943
List:16.2876
_:14.871
lists:13.678
,:13.6737
lst:13.0313
ist:13.0118
l:12.9416
ls:12.4074
state:11.8377
lis:11.7762
State:11.1292
lit:10.886
L:10.8052
S:10.7138
ListItem:10.692
 list:9.672	prefix accepted: 
able:9.65649
lt:9.54658
ilst:9.52744
ListView:9.42468

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: (PlayList, PlayListAction), update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:17.9116
 action:13.5709	prefix accepted: 
_:12.8952
 ,:11.9305
 ->:11.8309
1:11.2542
0:11.2059
 act:10.5168	prefix accepted: 
 play:10.4718	prefix accepted: 
_,:10.4303	prefix accepted:_
@:10.3563	rejected
 state:10.3254	prefix accepted: 
 actions:9.99614	prefix accepted: 
 and:9.94237	prefix accepted: 
 current:9.77539	prefix accepted: 
::9.52258	rejected
->:9.44494
 song:9.44354	prefix accepted: 
 pl:9.40999	prefix accepted: 
action:9.09445
',:8.98817	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: (PlayList, PlayListAction)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: (PlayList, PlayListAction)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Prod [(Var "PlayList"); (Var "PlayListAction")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 action:17.2811
 act:14.2407
 play:13.6316
 a:12.6684
 command:12.1228
 song:11.9453
 pl:11.712
 actions:11.6706
 new:11.5461
 current:11.4221
 p:11.3261
 event:11.2558
action:11.1139
 input:10.8066
 cmd:10.7615
 next:10.7445
 x:10.743
 player:10.6034
 update:10.2984
 Play:10.2661
 pa:10.0348

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Prod [(Var "PlayList"); (Var "PlayListAction")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: action
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Prod [(Var "PlayList"); (Var "PlayListAction")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:19.4094
->:15.1428
 :13.4779
 =>:13.3196	prefix accepted: 
_:12.9168

:10.7956
::10.6171	rejected
1:10.2559
 →:10.0194	prefix accepted: 
 in:9.93252	prefix accepted: 
':9.90452	rejected
 =:9.77244	prefix accepted: 
 -->:9.75445	prefix accepted: -
 -:9.75445
?:9.60496	rejected
0:9.5685
 ::9.3632	prefix accepted: 
  :9.2234
2:9.19655
 >>:8.95266	prefix accepted: 
,:8.77684	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:20.0614
 :18.1054
  :16.4708
    :15.257
 match:14.335	prefix accepted: ma
 case:13.8509
   :13.5174
                :13.3453
     :13.318
        :13.2018
      :13.0923
	:12.6523	rejected
 {:12.4425	prefix accepted: 
       :12.4114
 #:12.1369	prefix accepted: 
         :12.0308
 (*:11.9493	prefix accepted: (
            :11.777
          :11.6543
 begin:11.3392	prefix accepted: 
 let:11.2027

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
   :19.9236
     :17.7167
 :17.3136
  :16.5333
       :16.4851
    :16.3591

:14.438
	:14.2484	rejected
      :14.0302
case:13.7752
         :13.6827
match:13.5134	prefix accepted:ma
        :12.8523
           :12.7842
let:12.5957
if:11.5123
          :11.4506
#:11.0499	rejected
             :10.978
                :10.9741
(*:10.9656	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
   

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
   
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 case:19.2413
 let:18.2623
 match:17.7182	prefix accepted: ma
 #:14.57	prefix accepted: 
 if:14.1457
 switch:14.0654	prefix accepted: s
 (*:13.2279	prefix accepted: (
 print:12.837	prefix accepted: p
 (:13.2279
 play:11.9292
 fun:11.4317	prefix accepted: 
 {:11.3581	prefix accepted: 
 ((:11.1069	prefix accepted: (
 printf:10.8517	prefix accepted: p
 open:10.763	prefix accepted: 
 //:10.7216	prefix accepted: 
 Play:10.7169	prefix accepted: 
 begin:10.6896	prefix accepted: 
 Print:10.6652	prefix accepted: 
 cases:10.665	prefix accepted: case
 var:10.431	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:17.5655
 play:16.0633
 get:14.7352
 (:12.5056
 :11.2233

:10.7696
 current:10.7207	prefix accepted: c
 let:10.6471
 song:10.3672	prefix accepted: s
 act:10.3054
(:10.0765
 state:10.0674	prefix accepted: st
 player:10.0518	prefix accepted: play
 actions:9.96681	prefix accepted: action
 [:9.85061
 #:9.60148	prefix accepted: 
 {:9.52275	prefix accepted: 
play:9.22622
 *:9.00278	prefix accepted: 
 is:8.91043
 Play:8.8344

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListAction
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: action
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.6231
 :17.9219
,:15.8108
 of:15.5447	prefix accepted: 
  :15.3327
 with:14.34	prefix accepted: 
 |:13.9404
    :13.8815
     :12.5324
      :12.363
 {:12.3296	prefix accepted: 
                :12.3291
   :12.2958
 #:12.098	prefix accepted: 
::11.8557
        :11.7364
       :11.6196
 in:11.4259	prefix accepted: 
         :11.3571
;:11.196	rejected
            :11.0863

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListAction
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :19.5133
     :18.942
       :16.944
    :16.5959

:14.7518
      :14.6615
 :14.153
        :14.15
  :13.9816
         :13.4733
	:13.2405	rejected
           :12.4691
|:12.0903
          :11.6986
            :11.4065
#:11.3681	rejected
             :11.2699
 |:11.1977
                :10.9332
               :10.1407
              :9.708

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
   

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
   
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListAction
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.1844
 #:18.2487	prefix accepted: 
 (*:14.7296	prefix accepted: 
 match:13.1341	prefix accepted: 
 ~:13.1085	prefix accepted: 
 ##:12.827	prefix accepted: 
 /*:12.6711	prefix accepted: 
 +:12.5578	prefix accepted: 
 {:12.454	prefix accepted: 
 %:12.449	prefix accepted: 
 ||:12.3445	prefix accepted: |
 //:12.2062	prefix accepted: 
 ,:12.1852
 of:12.1273	prefix accepted: 
 #{:11.9279	prefix accepted: 
 *:11.8487	prefix accepted: 
 <:11.81	prefix accepted: 
 when:11.7172	prefix accepted: 
 /:11.6689	prefix accepted: 
 ::11.3001
 (:10.974	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Play:17.4976
 Add:17.2678
 P:16.3027
 Remove:15.3187
 No:13.9775	prefix accepted: 
 _:11.9747
 #:11.4948	prefix accepted: 
Play:11.4598
 (:11.1326
 Player:10.8809	prefix accepted: Play
 :13.9775
P:10.0243
Add:9.91898
 {:9.49381	prefix accepted: 
 Rem:9.47773
  :9.41093
 Stop:9.38759	prefix accepted: 
 Song:9.23529	prefix accepted: 
 Start:9.02216	prefix accepted: 
 App:8.99734	prefix accepted: A
 Get:8.90943	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | Play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | Play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:23.2711
ing:14.0816	rejected
P:13.8844	rejected
List:13.8339	rejected
(:12.6616	rejected
list:11.5244	rejected
_:11.1646	rejected
Current:11.0727	rejected
 song:10.9721	rejected
Sound:10.7533	prefix accepted:So
 Song:10.6313	rejected
ed:10.5026	rejected
Music:10.4327	rejected
song:10.357	rejected
p:10.1494	rejected
Sing:10.0316	prefix accepted:S
On:9.7075	rejected

:9.66782	rejected
 =>:9.4649	rejected
Play:9.2723	rejected
Audio:9.09103	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlayS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlayS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | Play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PlayS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PlayS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PlayS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PlayS
LSP: Generating Completions for prefix: PlayS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:28.3945
ongs:16.6821	prefix accepted:ong
song:13.5249	rejected
 song:13.2325	rejected
(:11.38	rejected
ongo:11.3003	prefix accepted:ong
on:10.8696
oup:10.4139	prefix accepted:o
ng:10.0265	rejected
ond:9.63445	prefix accepted:on
ug:9.56043	rejected
lide:9.31497	rejected
onic:9.28869	prefix accepted:on
ame:9.24935	rejected
n:9.21228	rejected
ONG:8.95707	rejected
ang:8.91768	rejected
one:8.86962	prefix accepted:on
oon:8.86457	prefix accepted:o
inger:8.75144	rejected
On:8.46079	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlayS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PlaySong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Id -> PlayListAction)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PlaySong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PlaySong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PlaySong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.7616
 id:15.1202	prefix accepted: 
 song:14.5029	prefix accepted: 
(_:13.9606	prefix accepted:(
 i:12.2988	prefix accepted: 
 new:11.34	prefix accepted: 
 sid:11.3386	prefix accepted: 
 x:11.308	prefix accepted: 
 s:11.1886	prefix accepted: 
 (:11.132
 _:10.8709	prefix accepted: 
 current:10.2754	prefix accepted: 
 idx:10.0439	prefix accepted: 
():9.9343	prefix accepted:(
 index:9.86646	prefix accepted: 
 =>:9.79453
 next:9.71893	prefix accepted: 
(-:9.55094	prefix accepted:(
((:9.50025	prefix accepted:(
 track:9.48628	prefix accepted: 
 selected:9.30235	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
id:18.6796
song:18.1325
x:15.3261
i:15.045
new:14.5255
s:14.283
idx:13.6369
current:13.4816
selected:13.0615
index:12.9439
Id:12.879	rejected
n:12.824
play:12.8096
next:12.2539
track:12.1191
a:11.5386
0:11.4723
target:11.4444
k:11.3303
curr:11.2092
some:11.083

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
_:19.4976
Id:18.0521
):17.2259
id:16.6511
ID:15.8361
s:12.8073
To:12.1898
)->:11.928	prefix accepted:)
Index:11.713
1:11.6591
),:11.0824	prefix accepted:)
_):10.9769	prefix accepted:_
)=:10.6383	prefix accepted:)
Name:10.6018
Num:10.0651
Number:9.87568
name:9.80365
){:9.56648	prefix accepted:)
 id:9.36041	prefix accepted: 
2:9.35229
0:9.30171

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songId
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):19.166
),:14.8678	prefix accepted:)
)->:14.2092	prefix accepted:)
To:13.5807
)=:13.2965	prefix accepted:)
x:12.5625
)::12.3258	prefix accepted:)
_:12.3228
1:11.9569
 as:11.708	prefix accepted: 
::11.4953	rejected
_):11.374	prefix accepted:_
 ):11.109
'):11.0559	rejected
2:10.5489
New:10.4244
In:10.0366
0:9.93747
){:9.89811	prefix accepted:)
 ::9.72492	prefix accepted: 
)|:9.67668	prefix accepted:)

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.2936
 ->:16.9002	prefix accepted: 
 when:14.9413	prefix accepted: 
  :13.5011
 :16.9002
     :12.8974
    :12.8729
      :12.6274

:12.4009
       :12.3712
   :12.0964
        :11.9872
         :11.9024
 if:11.5956	prefix accepted: 
                :11.461
          :11.4018
 as:11.3282	prefix accepted: 
           :11.0503
             :10.5781
            :10.5525
 =:10.3528

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:17.2115
 :16.3966
 (:14.9978
 if:14.1556
  :14.0665
 ([:13.5849	prefix accepted: (
 #:13.5276	prefix accepted: 
 play:13.4077
 [:13.2661
 match:12.9723	prefix accepted: ma
 let:12.9334
 update:12.8294
 ((:12.7972	prefix accepted: (
    :12.7327
 {:12.5706	prefix accepted: 
 get:12.5622
 <:12.3143	prefix accepted: 
                :12.2544
 (*:11.9373	prefix accepted: (
 [(:11.8306	prefix accepted: [
 List:11.6728

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:20.4639
 #:15.0049	prefix accepted: 
 (:14.9795
 if:14.7713
 [:14.0521
 play:13.9229
 (*:13.6856	prefix accepted: (
 <:13.2651	prefix accepted: 
 case:12.9738
 ([:12.8146	prefix accepted: (
 match:12.7399	prefix accepted: ma
 P:12.6359	prefix accepted: 
 ((:12.6237	prefix accepted: (
 begin:12.5634	prefix accepted: 
 let:12.5423
	:12.4536	rejected
 {:12.2442	prefix accepted: 
 List:11.5752
 song:11.4295
1:11.3711
 get:11.2886

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
       :20.3621
     :20.1101
      :16.3074
         :15.8555
           :15.4931
   :15.2355
        :15.0324
               :14.115
	:14.1033	rejected
    :14.048
                :13.6508
             :13.3355
          :13.2044
            :12.4487
              :12.3211

:11.9594
 :10.3119
  :10.262
#:10.1567	rejected
(:8.18576
if:8.04235

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 let:20.5504
 if:18.5712
 match:17.0492	prefix accepted: ma
 #:16.9819	prefix accepted: 
 case:16.7472
 (:16.7209
 begin:15.7992	prefix accepted: 
 (*:15.1695	prefix accepted: (
 ([:14.9029	prefix accepted: (
 play:14.3986
 ((:14.1851	prefix accepted: (
 [:14.1097
 get:14.0163
 Play:13.5636	prefix accepted: 
 update:13.5486
 [(:13.2403	prefix accepted: [
 <:13.0963	prefix accepted: 
 {:12.9956	prefix accepted: 
 P:12.9719	prefix accepted: 
 assert:12.8891	prefix accepted: a
 //:12.8816	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:17.6026
 current:13.5904
 song:13.4472
 _,:12.873	prefix accepted: _
 _:12.873
 new:12.1362
 ids:11.9949
 play:11.9624
 old:11.657
 all:11.641
 (:11.2532
 state:11.0223
 id:10.8958
 list:10.6681
 curr:10.5978
 cur:10.229
 xs:10.1941
 get:10.178
 prev:10.0326
 updated:10.0039
 is:9.93299

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:19.557
 =:17.0889
_:15.646
In:14.722
_,:13.3835	prefix accepted:_
 ,:13.3381
::12.7706
1:12.7209
',:12.7189	rejected
 ::12.6081
@:12.6011	rejected
=:12.4088
List:12.317
Ids:12.3119
To:12.2584
And:11.915
Id:11.5091
On:11.5015
Play:11.4822
  :11.4561
0:11.3792

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:17.1753
 _:16.795
 state:15.997
 old:13.688
 song:12.9954
 prev:12.1387
 curr:12.0936
 play:11.8431
 previous:11.7362
 playing:11.6439
_:11.1775
 status:11.0943
 cur:10.9289
 s:10.5951
state:10.4214
 id:10.1486
 songs:10.1251
 selected:9.98716
 states:9.97636
current:9.91884
 original:9.83556

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= new-tokens

Top 20 Logits:
 =:18.6773
state:15.6283	rejected
current:15	rejected
=:14.4568
old:13.7256	rejected
 :13.3727
 as:13.2031	prefix accepted: 
play:13.199	rejected
prev:12.5081	rejected
curr:12.4355	rejected
previous:12.3912	rejected
    :12.1825
  :12.0019
 ::11.25
      :11.0306
   :10.8242
:::10.8168
 ->:10.6711	prefix accepted: 
cur:10.6068	rejected
        :10.5281
     :10.5079

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "playlist" | "sin" | "songId" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:20.1099
 get:13.2894
 :13.2433
play:12.794
 List:12.4043
 (:11.6998

:11.6984
 current:11.3675	prefix accepted: c
 update:10.753
 action:10.6612
 pl:10.6143
 list:10.5903	prefix accepted: l
 Tu:10.5001	prefix accepted: T
 if:10.2316
 parse:10.1835
 match:10.1617	prefix accepted: ma
 split:9.98813	prefix accepted: s
 Play:9.70369
 p:9.46678
 tuple:9.34105	prefix accepted: t
  :9.33884

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:23.1868
List:14.6675	rejected
_:13.2554	rejected
ist:12.931	rejected
 list:11.8609	rejected
lists:11.7882	prefix accepted:list
lit:11.4686	prefix accepted:li
lis:11.2268
lst:11.0368	prefix accepted:l
l:11.0368
 in:10.0578	rejected
ls:9.93609	prefix accepted:l
L:9.6625	rejected
t:9.32629	rejected

:9.12392	rejected
ll:8.8068	prefix accepted:l
-:8.79397	rejected
.:8.70323	rejected
State:8.67655	rejected
link:8.52269	prefix accepted:li
S:8.48971	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:21.4082

:14.2721
 :14.0535
,:13.5462
;:13.1245	rejected
 and:12.7306	prefix accepted: 
.:12.1949	rejected
  :11.2257
                :10.2524
 #:10.1471	prefix accepted: 
 ,:9.69387
    :9.32732
 ;:9.28324	prefix accepted: 
 |:9.20882	prefix accepted: 
      :9.1422
	:8.98883	rejected
   :8.98597
 &&:8.93128	prefix accepted: 
 end:8.90039	prefix accepted: 
       :8.8146
 //:8.75643	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:19.5403
 :17.2758
  :15.6829
    :14.6298
      :13.7986
                :13.4373
        :13.3474
            :12.8903
 List:12.8783
   :12.8763
       :12.7923
     :12.6311
 (:12.4047
         :12.3719
 #:12.2868	prefix accepted: 
          :12.1204
              :11.8593
 (*:11.8155	prefix accepted: (
           :11.7466
             :11.7137
	:11.286	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
     :20.6417
       :18.4776
      :16.8451
         :15.804

:15.5272
    :15.5167
        :14.9204
	:14.5529	rejected
   :14.1732
           :13.8095
          :13.4253
  :13.0271
(*:12.4821	prefix accepted:(
            :12.2342
 :12.1561
                :12.0515
             :11.9586
#:11.8178	rejected
               :11.4996
              :10.8081
if:10.6572

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 if:19.0293
 (:18.1088
 ([:17.1955	prefix accepted: (
 let:17.154
 case:16.3917
 #:16.297	prefix accepted: 
 match:16.2445	prefix accepted: ma
 ((:15.4961	prefix accepted: (
 (*:15.4033	prefix accepted: (
 songs:15.2836
 List:14.6605
 begin:14.0292	prefix accepted: 
 Play:13.4663	prefix accepted: 
 assert:13.3793	prefix accepted: a
 play:13.215
 P:13.1755	prefix accepted: 
 get:12.8444
 [:12.6977
 song:12.5674
 update:12.228
 //:12.1189	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "String.reverse" | "String.starts_with" | "String.transform" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "songId" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:18.2467
 not:14.5757	prefix accepted: n
 contains:13.9247	prefix accepted: co
 song:13.5557
 (:13.3592
 get:13.0461	prefix accepted: 
 songs:12.6544	prefix accepted: song
 Song:11.7544	prefix accepted: S
 #:11.5071	prefix accepted: 
 Id:11.4324	prefix accepted: 
 !:11.3048
 String:11.169
 is:11.03
 list:10.9275	prefix accepted: l
 Songs:10.9212	prefix accepted: S
 Play:10.9192	prefix accepted: 
 Cont:10.8308	prefix accepted: 
 :13.0461
 ((:10.5567	prefix accepted: (
(:10.1424
 id:10.1418	prefix accepted: i

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".contains" | ".eq" | ".fold_left" | ".fold_right" | ".is_empty" | ".length"
root ::= completions

Top 20 Logits:
.:24.3588
.(:16.6179	prefix accepted:.
_:16.007	rejected
.@:12.6842	prefix accepted:.
s:12.6613	rejected
Contains:12.5582	rejected
contains:11.9426	rejected
 contains:11.8942	rejected
/:11.664	rejected
(:11.5168	rejected
@:11.2647	rejected
.<:11.2512	prefix accepted:.
.[:11.2353	prefix accepted:.
Util:11.0829	rejected
._:10.9025	prefix accepted:.
[:10.5683	rejected
:::10.4876	rejected
..:10.4528	prefix accepted:.
<:10.4467	rejected
 .:10.2742	rejected
x:9.89558	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "contains" | "eq" | "fold_left" | "fold_right" | "is_empty" | "length"
root ::= completions

Top 20 Logits:
contains:22.7895
eq:18.0382
length:17.7804
is:17.5711
filter:16.8771	prefix accepted:f
mem:16.43	rejected
exists:16.2917	prefix accepted:e
fold:15.185
includes:14.8296	prefix accepted:i
member:14.7426	rejected
rev:14.1362	rejected
in:13.9722	prefix accepted:i
equals:13.97	prefix accepted:eq
find:13.8749	prefix accepted:f
elem:13.5758	prefix accepted:e
cons:13.5554	prefix accepted:con
tl:13.5115	rejected
get:13.3766	rejected
starts:13.2671	rejected
Contains:13.0549	rejected
any:12.8394	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.contains>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (((? -> Bool), [?]) -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool;
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Unknown TypeHole), Bool));
                   (List (Unknown TypeHole))]),
              Bool))})))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  List.contains
Nature of error: Expecting type Bool but got inconsistent type (((? -> Bool), [?]) -> Bool)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: List.contains
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (((? -> Bool), [?]) -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: List.contains
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "then"
root ::= new-tokens

Top 20 Logits:
((:19.0509	prefix accepted:(
(:19.0509
 ((:13.667	prefix accepted: (
([:13.6332	prefix accepted:(
(_:13.6141	prefix accepted:(
(():13.4258	prefix accepted:(
(?:13.1985	prefix accepted:(
({:12.5163	prefix accepted:(
 (:13.667
($:12.281	prefix accepted:(
<:11.8658	rejected
(\:11.5212	prefix accepted:(
(|:11.2246	prefix accepted:(
(@:11.1132	prefix accepted:(
(&:10.4161	prefix accepted:(
?(:10.4037	rejected
(":10.3468	prefix accepted:(
(%:10.2319	prefix accepted:(
($(:10.0969	prefix accepted:(
[:10.0183	rejected
_:9.94685	rejected
Rejected the highest logit candidate (( with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "String.starts_with" | "bool_of_string" | "case " | "fun " | "if " | "is_finite" | "is_infinite" | "is_nan" | "let " | "type "
root ::= new-tokens

Top 20 Logits:
fun:15.4032
eq:13.9499	rejected
song:12.4274	rejected
id:12.3978	prefix accepted:i
equal:11.9654	rejected
x:11.9237	rejected
equals:11.4927	rejected
fn:11.4543	prefix accepted:f
Int:10.8193	rejected
s:10.7898	rejected
function:10.786	prefix accepted:fun
lambda:10.7431	prefix accepted:l
is:10.6936
func:10.6128	prefix accepted:fun

:10.5
<:10.329	rejected
a:10.2987	rejected
 (:10.2304
Id:10.0464	rejected
==:10.0309	rejected
Eq:10.0093	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun ? ->
 ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 id:16.046
 song:15.749
 x:15.4966
 s:13.9279
(:13.2033
 (:13.0565
 i:12.8335
 current:12.6357
 sid:12.5954
 a:12.5846
 other:12.4363
 el:12.3581
 e:11.5837
 elem:11.4953
 cur:11.4193
 n:11.101
 element:11.0503
 curr:10.7946
 y:10.6866
 it:10.615
 item:10.3764

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.0971
->:14.0419
 =>:12.9845	prefix accepted: 
_:12.3548
1:12.0984
::12.0908
,:11.9862
':11.6448	rejected
 ::11.4266
 :12.9845
2:10.3685
0:10.0513
 =:9.9803	prefix accepted: 
S:9.84958
In:9.76856
 ~:9.72841	prefix accepted: 
To:9.08294
Of:9.03041
 ==:9.01854	prefix accepted: 
 _:8.9986	prefix accepted: 
 song:8.97092	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id ->

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id ->
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songs songId action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "playlist" | "sin" | "songId" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 id:15.8626
 song:15.2921
 Int:12.2919	prefix accepted: 
 eq:11.7854	prefix accepted: e
 (:11.7615
 Id:11.6713	prefix accepted: 
 if:11.5719
 Song:10.946	prefix accepted: S
 :12.2919
 String:10.4363
 Bool:10.4181	prefix accepted: 
 (=:10.1251	prefix accepted: (
 fun:10.1145
 string:9.84077
 int:9.8333
 i:9.78672
 equal:9.77695	prefix accepted: e

:9.73475
 Eq:9.5571	prefix accepted: 
id:9.494
 Equ:9.45399	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songs songId action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ==:17.5041
 $:17.1924
 =:15.8046
 ===:14.8022	prefix accepted: ==
$:13.8953
==:13.2243
=$:13.0938	prefix accepted:=
=:13.0938
 $$:10.7369	prefix accepted: $
 is:10.4208	prefix accepted: 
 eq:10.2889	prefix accepted: 
===:10.2546	prefix accepted:==
 :10.4208
 =~:10.1346	prefix accepted: =
 equals:9.89231	prefix accepted: 
 #:9.8514	prefix accepted: 
 ~:9.83911	prefix accepted: 
 ^:9.75584	prefix accepted: 
 !=:9.72737
 ?:9.14996	prefix accepted: 
 %:9.04886	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id ==

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id ==
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id == ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id == ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id == ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: ==
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songs songId action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= completions | new-tokens

Top 20 Logits:
 song:21.1598
$:12.63	rejected
#:11.8726	rejected
?:11.7796	rejected
 (:11.0185
%:10.8641	rejected
*:10.8627	rejected
 :10.8537
 Int:10.7171	prefix accepted: 
 id:10.562
 Song:10.5	prefix accepted: 
@:10.4882	rejected
 Id:10.345	prefix accepted: 
^:10.3414	rejected
&:10.2379	rejected
<:10.1967	rejected
 [:10.0716	prefix accepted: 
 current:10.0232	prefix accepted: c
 play:9.77377	prefix accepted: 
song:9.75813
 $:9.67447	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id ==
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {id: ?, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id == song
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:23.0232
id:15.5617	rejected
_:14.3468	rejected
ID:14.2456	prefix accepted:I
,:11.9908	rejected
Ids:11.7916	prefix accepted:Id
 Id:10.5209	rejected
 id:10.4179	rejected
I:14.2456
Name:9.95234	rejected
(:9.81129	rejected
Index:9.68201	prefix accepted:I
Num:9.24868	rejected
Is:9.1911	prefix accepted:I
Info:9.05342	prefix accepted:I
-:8.99953	rejected
i:8.91268	rejected
[:8.76234	rejected
),:8.74647	rejected
Obj:8.73893	rejected
Int:8.72069	prefix accepted:I

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id == songId
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "," | "-" | "/"
root ::= new-tokens

Top 20 Logits:
,:18.0812
)(:14.927	prefix accepted:)
 ,:14.3159
 end:13.396	prefix accepted: 
):14.927
),:10.661	prefix accepted:)
 ):10.4292
 in:10.1966	prefix accepted: 
 &&:9.9405	prefix accepted: 
 ?:9.92662	prefix accepted: 
 *:9.78042
 ||:9.44563	prefix accepted: 
,(:9.39005	prefix accepted:,
 +:9.33533
(),:9.20624	rejected
?,:9.07087	rejected
 :13.396
 $:8.61412	prefix accepted: 
 _,:8.46823	prefix accepted: 
;:8.41416	rejected
$,:8.26761	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((? -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((? -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Unknown Internal), Bool)); (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "playlist" | "sin" | "songId" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:18.3669
 get:15.9464
 [:12.8175
 song:12.4853
song:12.1185
 :11.8682
 List:11.7694
 play:11.4173
 (:11.0039
 in:11.0027

:10.5249
get:10.0341
 list:9.81495	prefix accepted: l
 ):9.47622	prefix accepted: 
 Songs:9.43786	prefix accepted: S
 strings:9.21644	prefix accepted: string
 Song:9.1385	prefix accepted: S
 t:9.11618
 *:8.97125	prefix accepted: 
 []:8.73591
 [],:8.62949	prefix accepted: []

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Unknown Internal), Bool)); (List (Var "Id"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Unknown Internal), Bool)); (List (Var "Id"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):20.9253
 ):16.1541
 then:13.578	prefix accepted: 
 =:12.9446	prefix accepted: 
)::12.6728	prefix accepted:)

:12.2069
 @:12.0895	prefix accepted: 
)=:12.0262	prefix accepted:)
)(:11.9101	prefix accepted:)
),:11.9031	prefix accepted:)
 :13.578
){:11.4241	prefix accepted:)
=:11.4158	rejected
);:11.1773	prefix accepted:)
,:11.1421	rejected
[:10.7989	rejected
 as:10.7331	prefix accepted: 
)):10.7107	prefix accepted:)
)[:10.6892	prefix accepted:)
@:10.5815	rejected
).:10.4917	prefix accepted:)

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:19.9683

:18.0843
 :17.728
 #:15.4656	prefix accepted: 
 &&:15.3599
  :15.0838
 =:13.839	prefix accepted: 
    :13.2933
 ==:13.2627	prefix accepted: 
 ||:12.8652	prefix accepted: 
 {:12.8451	prefix accepted: 
 //:12.7173	prefix accepted: 
 (*:12.7162	prefix accepted: 
      :12.3355
                :12.2899
        :12.027
   :11.9718
 in:11.787	prefix accepted: 
 and:11.5609	prefix accepted: 
then:11.4158
 (:11.3447	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
     :22.9868
       :22.2288
         :19.6088
      :19.0626
        :18.969
           :17.1558
	:17.0423	rejected
          :16.5141
    :16.1307
                :16.1054
   :15.3674
               :15.3341
             :15.3081
            :15.2902

:14.5936
#:14.4499	rejected
              :14.1114
  :13.5792
 :12.9759
(*:11.3137	rejected
//:10.7236	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:24.4932
 #:19.1428	prefix accepted: 
 (*:16.8697	prefix accepted: 
 &&:15.684
 //:13.965	prefix accepted: 
 ||:13.739	prefix accepted: 
 (:13.5409	prefix accepted: 
 ##:13.4882	prefix accepted: 
 and:13.4331	prefix accepted: 
 {:13.0794	prefix accepted: 
 /*:12.9532	prefix accepted: 
 Then:12.8995	prefix accepted: 
 --:12.8362	prefix accepted: 
 let:12.7706	prefix accepted: 
 than:12.482	prefix accepted: th
 ~:12.2159	prefix accepted: 
 #(:12.1673	prefix accepted: 
 else:12.1414	prefix accepted: 
 =:12.1287	prefix accepted: 
then:11.9714
 ((:11.9263	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:19.1413
 ([:16.518	prefix accepted: (

:15.7598
 ((:15.6022	prefix accepted: (
 :15.3081
 #:14.881	prefix accepted: 
 play:14.708
 songs:13.8603
 [:13.2733
 let:12.7227
 P:12.3259	prefix accepted: 
 Play:12.2544	prefix accepted: 
  :12.0403
 (*:11.8881	prefix accepted: (
 {:11.6984	prefix accepted: 
 [(:11.6699	prefix accepted: [
 if:11.5901
 ({:11.3707	prefix accepted: (
 get:11.1691
 update:11.1505
 (_:10.8317	prefix accepted: (

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:18.9382
play:15.4985
get:14.2235
#:12.7429	rejected

:12.5616
 songs:12.1684
remove:12.0929	rejected
List:11.9399
let:11.8675
Play:11.6033	rejected
if:10.849
P:10.6632	rejected
sing:10.3573	prefix accepted:s
update:10.2511
list:10.2211	prefix accepted:l
add:10.1455	prefix accepted:a
 #:10.0556	prefix accepted: 
<:10.005	rejected
ignore:9.87423	prefix accepted:i
([:9.61209	prefix accepted:(
plays:9.57865	prefix accepted:play

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id" | "s"
root ::= completions

Top 20 Logits:
s:24.2863
Id:11.6807
,:10.5917	rejected
:::10.0225	rejected
sBy:9.99154	prefix accepted:s
_:9.1463	rejected
ss:8.46704	prefix accepted:s
sp:8.41001	prefix accepted:s
Ids:8.39322	prefix accepted:Id
st:8.307	prefix accepted:s
List:8.25127	rejected
[:8.12741	rejected
es:8.01573	rejected
sl:7.69741	prefix accepted:s
S:7.53454	rejected
.:7.41609	rejected
song:7.37383	prefix accepted:s
so:7.3203	prefix accepted:s
sn:7.23131	prefix accepted:s
=:7.10789	rejected
 =:6.95872	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:20.4914
 ,:14.8124
 @:14.7062
@:12.6316
::12.291	rejected
 ::11.8574	prefix accepted: 
 +:11.2773	prefix accepted: 
),:11.1923	prefix accepted:)
 as:11.1753	prefix accepted: 
,(:10.8192	prefix accepted:,
 |:10.5075	prefix accepted: 
,[:10.4886	prefix accepted:,
 ++:10.4628	prefix accepted: 
.:10.2886	rejected
:::10.2767	rejected
[:10.1758	rejected
 P:10.129	prefix accepted: 
 :::9.95209	prefix accepted: 
[@:9.73232	rejected
 #:9.55682	prefix accepted: 
 :11.8574

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 Play:18.7036
 P:16.7569
 (:13.2915
Play:13.036
 No:12.9632
 get:12.198
 :11.7467
 playing:11.7359	prefix accepted: 
 Player:11.5413	prefix accepted: Play
 state:11.0364	prefix accepted: 
 #:10.9653	prefix accepted: 
 {:10.7624	prefix accepted: 
 current:10.7373	prefix accepted: c
 new:10.7115	prefix accepted: 
 play:9.96597	prefix accepted: 
 [:9.95407	prefix accepted: 
 if:9.83767
 ((:9.82657	prefix accepted: (
 Song:9.74452	prefix accepted: 
 Current:9.51487	prefix accepted: 
 State:9.48083	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ing"
root ::= completions

Top 20 Logits:
ing:26.749
List:17.1316	rejected
S:16.521	rejected
(:14.9889	rejected
ed:13.9004	rejected
ling:13.8768	rejected
Play:13.4581	rejected
list:12.9195	rejected
State:12.9081	rejected
ING:12.6725	rejected
in:11.8905
ng:11.8742	rejected
Sing:11.8054	rejected
i:11.7453
P:11.7347	rejected
Music:11.47	rejected
L:11.353	rejected
ings:11.2475	prefix accepted:ing
able:11.2153	rejected
ting:11.0655	rejected
eing:10.9496	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Id -> PlayListState)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:21.7491
 song:17.3223	prefix accepted: 
 (:14.2069
((:13.1838	prefix accepted:(
({:12.5617	prefix accepted:(
([:12.442	prefix accepted:(
[:11.6396	rejected
{:11.603	rejected
($:11.3136	prefix accepted:(
()):11.3031	prefix accepted:(
):11.1266
(@:10.893	prefix accepted:(
(_:10.8609	prefix accepted:(
song:10.6606	rejected
(":10.4873	prefix accepted:(
)(:10.2663	prefix accepted:)
(-:10.1812	prefix accepted:(
 songs:10.093	prefix accepted: 
(`:9.97891	prefix accepted:(
(*:9.92362	prefix accepted:(
 {:9.76188	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
song:23.2817
0:16.0096
get:15.565	rejected
id:15.5359	prefix accepted:i
play:14.729	rejected
1:14.4297
 song:13.5776
current:13.1856	prefix accepted:c
action:12.9074	prefix accepted:a
5:12.8071
find:12.8053	rejected
index:12.5389	prefix accepted:in
2:12.4031
3:12.3112
S:12.2485	rejected
Int:12.21	rejected
Id:12.1276	rejected
i:15.5359
Play:11.8833	rejected
sound:11.8774	prefix accepted:so
sing:11.8472	prefix accepted:s

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:26.7355
id:16.2637	rejected
)):14.1317	rejected
 Id:13.6221	rejected
I:13.404
_:13.1838	rejected
Add:12.902	rejected
ID:12.8751	prefix accepted:I
Ids:12.6755	prefix accepted:Id
Num:11.741	rejected
Name:11.6787	rejected
If:11.6403	prefix accepted:I
Index:11.5993	prefix accepted:I
):11.5462	rejected
Info:11.4962	prefix accepted:I
In:11.3077	prefix accepted:I
 id:11.2412	rejected
List:11.2387	rejected
Is:11.1056	prefix accepted:I
s:10.975	rejected
To:10.657	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
)):24.6764	prefix accepted:)
)),:17.5543	prefix accepted:)
));:16.3575	prefix accepted:)
):24.6764
),:15.3096	prefix accepted:)
))::15.1396	prefix accepted:)
))):14.4063	prefix accepted:)
)).:13.9117	prefix accepted:)
)::13.4506	prefix accepted:)
::12.9145	rejected
 +:12.381
,:12.3504	rejected
 :12.227
 ::12.1635	prefix accepted: 
 @:12.0781	prefix accepted: 
))`:11.7567	prefix accepted:)
 -:11.5629
);:11.5321	prefix accepted:)
)))):11.413	prefix accepted:)
)){:11.3652	prefix accepted:)
))]:11.3134	prefix accepted:)
Rejected the highest logit candidate )) with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 ):17.2823
 as:14.7309	prefix accepted: 
 ::14.1549	prefix accepted: 

:13.4853
 end:13.1516	prefix accepted: 
 @:13.0042	prefix accepted: 
 else:12.4939	prefix accepted: 
 :14.7309
:::11.5544	rejected
  :11.3571
 :::11.0546	prefix accepted: 
 (*:11.0134	prefix accepted: 
@:10.9921	rejected
 #:10.928	prefix accepted: 
 /*:10.6348	prefix accepted: 
                :10.1373
    :9.99673
()):9.74089	rejected
   :9.68256
 (:9.59046	prefix accepted: 
 in:9.58887	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "else"
root ::= new-tokens

Top 20 Logits:

:19.3638
 else:17.9611
 :17.4871
  :16.6395
 #:16.6069	prefix accepted: 
    :15.1003
      :14.7647
 (*:14.4701	prefix accepted: 
 @:14.3534	prefix accepted: 
   :14.2072
        :13.6724
                :13.4393
       :13.4359
#:13.259	rejected
else:13.2544
     :12.7949
          :12.7196
         :12.6699
 as:12.5619	prefix accepted: 
            :12.4485
@:12.3831	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "else"
root ::= new-tokens

Top 20 Logits:
     :21.4561
       :17.2157
      :16.7137
   :15.1859
        :14.9791
    :14.9044
	:14.842	rejected
         :14.8276

:14.3517
          :14.1753
else:14.0868
                :14.0653
           :13.9624
#:13.6459	rejected
            :12.9186
 :12.7015
  :12.6823
              :12.5858
               :12.5488
             :12.5042
(*:11.8408	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "else"
root ::= new-tokens

Top 20 Logits:
 else:24.3998
 #:19.9366	prefix accepted: 
 end:16.7054	prefix accepted: e
 (*:16.0363	prefix accepted: 
 elif:14.7431	prefix accepted: el
 els:13.8211
 ##:13.5073	prefix accepted: 
 otherwise:13.4932	prefix accepted: 
 //:13.2457	prefix accepted: 
 !:12.6618	prefix accepted: 
 --:12.559	prefix accepted: 
 Else:12.2253	prefix accepted: 
 (:12.1121	prefix accepted: 
 /*:12.1013	prefix accepted: 
 fail:12.0927	prefix accepted: 
 |:11.9511	prefix accepted: 
 (**:11.8206	prefix accepted: 
 let:11.8124	prefix accepted: 
 []:11.7239	prefix accepted: 
 ~:11.649	prefix accepted: 
 %:11.627	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 play:16.6691
 (:14.8358
 raise:14.0412	prefix accepted: 
 fail:13.5532	prefix accepted: 
 :14.0412

:12.5248
 ((:11.9988	prefix accepted: (
 (*:11.3733	prefix accepted: (
 error:11.3318	prefix accepted: 
 (":11.2927	prefix accepted: (
 let:10.6062
 throw:10.3436	prefix accepted: t
 print:10.3425	prefix accepted: p
 if:10.3416
 #:10.2232	prefix accepted: 
 ([:10.1675	prefix accepted: (
 Error:10.1462	prefix accepted: 
 abort:9.99514	prefix accepted: ab
 {:9.97734	prefix accepted: 
 (-:9.94734	prefix accepted: (
  :9.85453

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:16.5938
play:14.2276
get:12.6056
 songs:12.18
List:11.7897
print:10.6542	prefix accepted:p
add:10.613	prefix accepted:a
[]:10.2396
 song:9.89184
 get:9.72712

:9.69909
 [:9.65992
if:9.53174
 (:9.45744
 play:9.19546
sing:9.03022	prefix accepted:s
[":8.8268	prefix accepted:[
Play:8.82086	rejected
 [],:8.80564	prefix accepted: []
error:8.40816	rejected
((:8.37343	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id" | "s"
root ::= completions

Top 20 Logits:
s:20.0628
Id:12.3254
List:12.2953	rejected
,:12.0453	rejected
Ids:11.1228	prefix accepted:Id
song:10.7673	prefix accepted:s
es:9.97128	rejected
:::9.94399	rejected
(),:9.87846	rejected
_:9.67364	rejected
 songs:9.5571	rejected
[:9.51869	rejected
sBy:9.36629	prefix accepted:s
(:9.36372	rejected
):9.36012	rejected
.:9.28546	rejected
State:9.07501	rejected
S:8.90587	rejected
ss:8.68451	prefix accepted:s
():8.46303	rejected
::8.43713	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:19.1439
 @:17.1248
 ,:14.8699
@:13.7376
 ++:12.462	prefix accepted: 
 +:12.1734	prefix accepted: 
 ::10.8953	prefix accepted: 
):10.5694
::10.5657	rejected
:::10.261	rejected
[@:10.0782	rejected
 :12.462
 :::9.894	prefix accepted: 
 //:9.77239	prefix accepted: 
                :9.7039
 (@:9.58004	prefix accepted: 
 |:9.57351	prefix accepted: 
 P:9.5598	prefix accepted: 
@@:9.33459	prefix accepted:@
 -:9.1404	prefix accepted: 
,[:9.08887	prefix accepted:,

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 No:18.5514
 get:13.7855
 current:13.7382	prefix accepted: c
 state:13.7345	prefix accepted: 
 P:13.5362
 Play:11.8716
 play:11.7733	prefix accepted: 
 :13.7345
No:11.2073
 no:11.0358	prefix accepted: 
 Current:10.5586	prefix accepted: 
 Not:10.4105	prefix accepted: No
 (:9.83176
 song:9.67618	prefix accepted: 
 Invalid:9.5367	prefix accepted: 
 Get:9.47578	prefix accepted: 
 Error:9.30574	prefix accepted: 
 Song:9.24461	prefix accepted: 
 None:9.19074	prefix accepted: No
 State:9.05268	prefix accepted: 
 Un:8.93005	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, No

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, No
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  No
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:22.1567
Current:12.5414	rejected
State:12.311	prefix accepted:S
Selected:12.0616	prefix accepted:S
_:11.9359	rejected
Play:11.9353	rejected
Action:11.5514	rejected
Sound:11.5378	prefix accepted:So
Selection:11.4895	prefix accepted:S
 Song:11.1663	rejected
P:11.1555	rejected
SON:11.0445	prefix accepted:S
New:10.5109	rejected
Sing:10.422	prefix accepted:S
C:10.1122	rejected
Music:10.0823	rejected
song:10.0326	rejected
Change:9.98659	rejected
 song:9.97842	rejected
Track:9.80811	rejected
Name:9.77544	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, No
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  NoS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:24.4989
on:15.0757
ongs:13.7457	prefix accepted:ong
ung:13.5261	rejected
one:13.1712	prefix accepted:on
ng:12.9752	rejected
ame:12.2737	rejected
oon:12.2274	prefix accepted:o
song:12.0118	rejected
ond:11.9155	prefix accepted:on
ang:11.4582	rejected
ue:11.3038	rejected
un:11.2482	rejected
uch:11.1588	rejected
ony:11.094	prefix accepted:on
ons:11.0763	prefix accepted:on
n:11.0392	rejected
onic:10.8758	prefix accepted:on
ion:10.8755	rejected
oup:10.7191	prefix accepted:o
pon:10.6676	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  NoSong
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:23.8365
Select:14.6202
Play:14.107	rejected
Se:13.6311
selected:13.5138	rejected
Available:13.3206	rejected
Found:12.805	rejected
Selection:12.6472	prefix accepted:Select
 Selected:12.4602	rejected
Error:12.1536	rejected
S:12.1269
P:11.8422	rejected
Is:11.7952	rejected
):11.7274	rejected
Selector:11.6129	prefix accepted:Select
SELECT:11.1902	prefix accepted:S
Pres:11.164	rejected
To:10.9892	rejected
Has:10.9671	rejected
Start:10.8591	prefix accepted:S
Exists:10.7998	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):18.7759
 ):17.5207
 :13.1473
()):12.55	rejected
():12.3105	rejected
 end:12.1688	prefix accepted: 
);:11.6305	prefix accepted:)
)):11.5397	prefix accepted:)
),:11.3942	prefix accepted:)
(:11.3194	rejected
(*:10.8249	rejected
 );:10.7422	prefix accepted: )
  :10.5748
 ::10.3932	prefix accepted: 
::10.2316	rejected
 ),:10.2279	prefix accepted: )
)::10.2171	prefix accepted:)
 ():10.177	prefix accepted: 

:10.1708
 (*:10.1126	prefix accepted: 
)]:9.25061	prefix accepted:)

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.9859
 :17.5565
 end:17.3145
  :17.3144
 #:17.1826	prefix accepted: 
      :16.357
 (*:16.0617	prefix accepted: 
    :15.8563
   :14.7201
        :14.7129
                :14.5462
       :14.334
            :13.807
     :13.7426
          :13.6171
         :13.6126
#:13.4001	rejected
 in:13.3707	prefix accepted: 
           :12.9737
              :12.85
	:12.5905	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.7366
    :15.7346

:15.0833
      :14.5159
  :13.7902
        :13.097
     :12.8567
 :12.0934
       :11.3121
          :11.2756
            :11.1175
                :10.8678
	:10.2904	rejected
         :9.94176
              :9.83784
in:9.44043	rejected
#:9.38679	rejected
|:9.17729
           :8.88685
(*:8.83572	rejected
             :8.81454

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
   

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
   
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:23.1774
 #:17.978	prefix accepted: 
 end:15.9611
 case:14.9773	prefix accepted: 
 (*:14.7715	prefix accepted: 

:13.792
 //:13.1358	prefix accepted: 
 ():12.3409	prefix accepted: 
 let:12.1336	prefix accepted: 
 (:12.0707	prefix accepted: 
 ||:11.844	prefix accepted: |
 <:11.7392	prefix accepted: 
 else:11.7094	prefix accepted: e
 if:11.6901	prefix accepted: 
 ~:11.6381	prefix accepted: 
 --:11.5441	prefix accepted: 
 []:11.4388	prefix accepted: 
 /:11.3877	prefix accepted: 
 match:11.3495	prefix accepted: 
 fun:11.2994	prefix accepted: 
 [:11.2479	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 P:20.5505
 Remove:17.8747
 Add:16.4038
P:12.5902
 Play:12.2981
 _:12.2228
 :11.6803
 Stop:11.5129	prefix accepted: 
Remove:11.2156
 #:10.9919	prefix accepted: 
 No:10.983	prefix accepted: 
 Rem:10.7561
 Res:10.232	prefix accepted: Re

:9.71919
 Change:9.6222	prefix accepted: 
 Next:9.53106	prefix accepted: 
 Delete:9.44394	prefix accepted: 
 Rest:9.32026	prefix accepted: Re
 Update:9.28661	prefix accepted: 
 pause:9.23132
 Move:9.18559	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "auseCurrentSong" | "laySong"
root ::= completions

Top 20 Logits:
ause:26.1397
aused:18.7776	prefix accepted:ause
aus:13.3588
au:13.1444
ulse:12.5964	rejected
urchase:12.5907	rejected
ush:12.4924	rejected
ose:12.3501	rejected
aste:12.2714	prefix accepted:a
rep:11.8604	rejected
ace:11.5652	prefix accepted:a
ase:11.1844	prefix accepted:a
p:11.0988	rejected
 pause:11.0572	rejected
ull:10.895	rejected
ipeline:10.7196	rejected
refix:10.6879	rejected
ending:10.6259	rejected
aint:10.4265	prefix accepted:a
uzz:10.3323	rejected
ouse:10.1625	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | Pause

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | Pause
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Pause>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Pause"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Pause
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Pause
LSP: Generating Completions for prefix: Pause
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "CurrentSong"
root ::= completions

Top 20 Logits:
Current:24.3532
S:14.4849	rejected
C:13.2283
On:13.0275	rejected
 =>:12.312	rejected
 Current:12.1867	rejected
(:11.8327	rejected
():11.5488	rejected
_:11.2522	rejected
Cur:10.8236
 current:10.5075	rejected
Play:10.3806	rejected
current:10.2951	rejected
 on:9.96682	rejected
Music:9.77587	rejected

:9.47595	rejected
 ->:9.28496	rejected
If:9.09549	rejected
 if:9.03846	rejected
 song:9.00552	rejected
Or:8.93181	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrent

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrent
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | Pause
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrent>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PauseCurrent"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PauseCurrent
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PauseCurrent
LSP: Generating Completions for prefix: PauseCurrent
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:24.2486
 Song:13.328	rejected
Sound:12.6746	prefix accepted:So
ly:12.2938	rejected
(:11.7327	rejected
():11.7054	rejected
 song:11.2986	rejected
State:10.5956	prefix accepted:S
Play:10.5685	rejected

:10.4765	rejected
song:10.4419	rejected
SON:9.92933	prefix accepted:S
_:9.71715	rejected
::9.44486	rejected
P:9.43326	rejected
 =>:9.42987	rejected
 :9.24875	rejected
 on:8.9436	rejected
Show:8.90971	prefix accepted:S
 (:8.81014	rejected
On:8.79949	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrent
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrentS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PauseCurrentS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PauseCurrentS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PauseCurrentS
LSP: Generating Completions for prefix: PauseCurrentS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:30.2629
ongs:20.0863	prefix accepted:ong
on:18.8765
ongo:16.4412	prefix accepted:ong
oon:15.0743	prefix accepted:o
song:15.0059	rejected
now:14.4132	rejected
ony:14.1963	prefix accepted:on
oup:13.3926	prefix accepted:o
play:13.3627	rejected
ond:13.0643	prefix accepted:on
ONG:12.8189	rejected
Play:12.7666	rejected
ung:12.5804	rejected
 song:12.54	rejected
ng:12.2451	rejected
one:12.1672	prefix accepted:on
og:12.1523	prefix accepted:o
ound:12.1322	prefix accepted:o
om:12.0212	prefix accepted:o
onic:11.9342	prefix accepted:on

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrentSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PauseCurrentSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: PauseCurrentSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.8082
=>:13.9377
 :13.559
  :12.4841
 when:11.4512	prefix accepted: 
 if:11.3858	prefix accepted: 

:11.2742
 ->:11.2259	prefix accepted: 
    :10.9761
   :10.3306
 as:10.0433	prefix accepted: 
      :9.96999
():9.75342	rejected
 :=:9.60127	prefix accepted: 
	:9.42984	rejected
       :9.31905
     :9.30863
        :9.28023
 =:9.18695
                :9.06954
 |:9.04593	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 :18.409

:18.1988
  :15.987
 match:14.8755	prefix accepted: ma
 (:14.7998
 #:14.2175	prefix accepted: 
 let:13.8921
 play:13.6207
    :13.38
 get:13.2613
 (*:13.2068	prefix accepted: (
 case:12.8967
 ((:12.4149	prefix accepted: (
   :12.3351
 update:12.2922
 if:12.2811
      :12.1426
                :12.0479
        :11.8503
         :11.6865
       :11.6386

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:22.122
 #:15.8585	prefix accepted: 
 match:15.7657	prefix accepted: ma
 case:14.8836
	:14.1891	rejected
 (:14.054
 let:13.9402
 (*:13.6877	prefix accepted: (
 play:12.0785
 get:12.0382
 state:11.9005	prefix accepted: st
 pause:11.7123	prefix accepted: p
 if:11.671
 ():11.6064	prefix accepted: (
 ((:11.3831	prefix accepted: (
 P:11.3826	prefix accepted: 
0:11.2823
 fail:11.201	prefix accepted: 
1:11.198
 {:10.9269	prefix accepted: 
 #(:10.9102	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
     :23.1542
       :21.4067
      :19.2254
    :18.3825
   :17.9879
         :17.9426
	:16.6292	rejected
           :16.6129
        :16.4004
          :14.8809
             :14.6836
               :14.6629
  :14.5942
                :14.5144

:14.4861
#:14.156	rejected
            :14.042
 :13.6828
              :13.3002
let:11.6445
(*:11.4752	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 let:21.5219
 case:20.3257
 match:19.6993	prefix accepted: ma
 #:18.6307	prefix accepted: 
 (:18.0546
 if:17.3737
 begin:16.7092	prefix accepted: 
 (*:16.5122	prefix accepted: (
 get:16.2562
 play:15.1885
 ((:14.6963	prefix accepted: (
 update:14.3823
 fun:13.6735	prefix accepted: 
 #(:13.5007	prefix accepted: 
 //:13.3532	prefix accepted: 
 switch:13.319	prefix accepted: s
 ():13.2708	prefix accepted: (
 fail:13.0351	prefix accepted: 
 assert:12.9279	prefix accepted: a
 try:12.7872	prefix accepted: t
 ([:12.7484	prefix accepted: (

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 get:18.2687
 play:15.6969
 (:13.7307
 action:11.5634
 s:11.5386
 state:10.9009	prefix accepted: st
 :10.6872
 let:10.4653
 List:10.3178
 current:10.2694	prefix accepted: c
 ((:9.70681	prefix accepted: (
 f:9.57858
 update:9.57369
 second:9.53343	prefix accepted: s
(:9.52065
 p:9.31905
 player:9.10733	prefix accepted: play
 next:8.9347	prefix accepted: ne
play:8.90231
 #:8.89946	prefix accepted: 
 Play:8.83109

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get"))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get
Nature of error: Variable get is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get
LSP: Generating Completions for prefix: get
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_songs" | "_state"
root ::= completions

Top 20 Logits:
_:24.6353
State:14.5722	rejected
Play:13.0854	rejected
(:12.0557	rejected
state:11.7913	rejected
 state:11.4257	rejected
S:11.1323	rejected
_(:11.1063	prefix accepted:_
P:10.8715	rejected
__:10.4217	prefix accepted:_
Current:10.4009	rejected
Player:10.2816	rejected
List:9.53902	rejected
-:9.47828	rejected
Status:9.22161	rejected
play:9.17066	rejected
Music:9.02665	rejected
Id:8.98771	rejected
<:8.69486	rejected
.:8.60438	rejected
p:8.43596	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get_"))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_
Nature of error: Variable get_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get_
LSP: Generating Completions for prefix: get_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "songs" | "state"
root ::= completions

Top 20 Logits:
state:27.8274
play:20.3187	rejected
song:19.3955
current:18.896	rejected
status:16.3194	prefix accepted:stat
id:15.9296	rejected
sing:15.6623	prefix accepted:s
player:15.3415	rejected
p:15.3165	rejected
states:15.031	prefix accepted:state
action:15.0141	rejected
s:15.6623
first:14.7251	rejected
State:14.7129	rejected
next:14.3592	rejected
list:14.3133	rejected
all:14.2816	rejected
music:14.1977	rejected
last:14.161	rejected
curr:14.1574	rejected
cur:14.0104	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (PlayList -> PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: get_state
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (PlayList -> PlayListState)
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: get_state
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:20.498
 play:16.8303	prefix accepted: 
 (:13.7374
():12.5238	prefix accepted:(
((:11.7575	prefix accepted:(
 player:11.1343	prefix accepted: 
(*:10.714	prefix accepted:(
_:10.2942	rejected
play:10.2456	rejected
({:9.95937	prefix accepted:(
 of:9.89836	prefix accepted: 
,:9.58086
(_:9.55016	prefix accepted:(
([:9.51259	prefix accepted:(
::9.49563

:9.4724
(@:9.24589	prefix accepted:(
 p:9.22273	prefix accepted: 
 song:9.19255	prefix accepted: 
 playing:9.15883	prefix accepted: 
 {:9.1456	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= completions | new-tokens

Top 20 Logits:
play:23.3545
 play:15.0045
pl:13.1976
action:12.9707	prefix accepted:a
player:12.8896	prefix accepted:play
p:12.6579
get:12.3417
pal:12.2058	prefix accepted:p
current:12.1199	prefix accepted:c
Play:12.08	rejected
update:11.6665
song:11.1874	prefix accepted:s
plays:10.8945	prefix accepted:play
self:10.4757	prefix accepted:s
x:10.4007	rejected
pay:10.2597	prefix accepted:p
new:10.1889	rejected
state:9.84106	prefix accepted:st
init:9.63173	prefix accepted:in
a:12.9707
my:9.49232	prefix accepted:m

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:24.6292
List:18.342	rejected
lists:14.5536	prefix accepted:list
lis:13.7809
ist:13.5642	rejected
lst:13.5354	prefix accepted:l
l:13.5354
_:12.5314	rejected
 list:12.2844	rejected
ing:12.1052	rejected
ls:11.7712	prefix accepted:l
lit:11.7653	prefix accepted:li
):11.3409	rejected
L:10.9465	rejected
ling:10.7133	prefix accepted:li
lista:10.6641	prefix accepted:list
ll:10.364	prefix accepted:l
State:10.0551	rejected
LIST:9.95807	rejected
back:9.90049	rejected
ilst:9.88202	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):22.1633
),:18.9814	prefix accepted:)
)::16.0765	prefix accepted:)
 ):13.6836
);:13.4225	prefix accepted:)
::13.3161	rejected
).:13.2297	prefix accepted:)
 =:13.1054	prefix accepted: 
)):12.7978	prefix accepted:)
)=:12.6534	prefix accepted:)
){:12.4824	prefix accepted:)
)?:12.4758	prefix accepted:)
)]:12.3708	prefix accepted:)
)(:12.126	prefix accepted:)
)|:12.1199	prefix accepted:)
,:11.9375	rejected
()):11.7561	rejected
)[:11.6707	prefix accepted:)
 of:11.4979	prefix accepted: 
)->:11.477	prefix accepted:)
):11.3929	prefix accepted:)

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.5482
 of:19.3424	prefix accepted: 
 :19.3424
  :16.1857
 with:14.9913	prefix accepted: 
    :14.3341
      :13.6317
 #:13.3815	prefix accepted: 
   :13.1382
 =:12.7576	prefix accepted: 
 as:12.7143	prefix accepted: 
                :12.6493
        :12.5895
       :12.488
     :12.1847
 //:12.0872	prefix accepted: 
         :11.9241
 ::11.806
          :11.7702
 {:11.495	prefix accepted: 
            :11.4796

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:23.2262
 of:18.1504	prefix accepted: 
 #:15.8446	prefix accepted: 
 with:15.291	prefix accepted: 
	:14.8837	rejected
 =:13.2741	prefix accepted: 
 as:13.1872	prefix accepted: 
 (*:12.711	prefix accepted: 
 //:12.3355	prefix accepted: 
 {:11.508	prefix accepted: 
 ::11.4438
    :11.3118
 =>:11.0998	prefix accepted: 
 :18.1504
 do:10.9344	prefix accepted: 
 |:10.8406
 ##:10.692	prefix accepted: 
1:10.6425	rejected
 ->:10.5928	prefix accepted: 
  :10.4146
0:10.3081	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :23.8194
       :22.4527
      :19.6936
         :18.9511
        :18.1006
	:18.0883	rejected
    :17.3122
   :17.1053
           :16.8689
          :16.6714
                :15.5791

:15.526
#:15.1418	rejected
               :15.0099
             :14.8641
            :14.8522
  :14.2473
 :14.0449
|:13.8905
              :13.4792
<<:11.4047	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.3751
 #:17.5764	prefix accepted: 
 with:14.5969	prefix accepted: 
 (*:14.4373	prefix accepted: 
 of:14.393	prefix accepted: 
 {:13.243	prefix accepted: 
 ||:12.4391	prefix accepted: |
 ~:12.398	prefix accepted: 
 <:12.1354	prefix accepted: 
 match:12.1328	prefix accepted: 
 //:11.927	prefix accepted: 
 /*:11.8889	prefix accepted: 
 %:11.6705	prefix accepted: 
 -:11.532	prefix accepted: 
 *:11.5243	prefix accepted: 
 let:11.4401	prefix accepted: 
 ::11.4059
 ,:11.397
 =:11.2679	prefix accepted: 
 case:11.0478	prefix accepted: 
 /:11.0304	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Play:17.1467
 P:15.6187
 No:15.237
Play:12.5302
 (:11.9025
 _:11.3169
 :11.1554
P:11.0884
 playing:10.6266
 Player:10.4553	prefix accepted: Play
 Song:9.94109	prefix accepted: 
 Some:9.6008	prefix accepted: 
 #:9.57155	prefix accepted: 
  :9.39887
No:9.29961
 no:9.22564
>:9.11769	rejected
 None:9.08208	prefix accepted: No
 _,:8.84574	prefix accepted: _
 :8.64738	rejected
 >:8.59806	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ing"
root ::= completions

Top 20 Logits:
ing:22.9299
S:15.5391	rejected
List:14.2572	rejected
ed:13.2109	rejected
State:12.249	rejected
(:12.0671	rejected
P:11.5535	rejected
list:11.5045	rejected
i:11.3947
Sing:11.3433	rejected
ling:11.322	rejected
On:11.0011	rejected
able:10.6051	rejected
ING:10.3194	rejected
ings:10.2121	prefix accepted:ing
ng:10.1885	rejected
Play:10.1548	rejected
in:10.0775
eing:9.8549	rejected
L:9.72871	rejected
Music:9.47553	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.7648
(_:17.2347	prefix accepted:(
 (:13.5925
 song:13.509	prefix accepted: 
 id:13.2343	prefix accepted: 
 current:12.3939	prefix accepted: 
 _:12.2713	prefix accepted: 
():12.027	prefix accepted:(
((:11.6558	prefix accepted:(
 s:11.6408	prefix accepted: 
 i:11.5076	prefix accepted: 
 x:10.9669	prefix accepted: 
 p:10.5858	prefix accepted: 
 =>:10.533
 sid:10.3395	prefix accepted: 
 (_:10.1527	prefix accepted: (
 :13.509
  :10.0044
 curr:9.91866	prefix accepted: 
 ->:9.85621	prefix accepted: 
(-:9.82324	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
song:17.4867
id:17.3088
current:16.0208
x:14.3952
curr:13.8765
i:13.5586
cur:13.2387
play:13.1623
s:12.7502
selected:12.6701
p:12.5049
Id:11.7827	rejected
a:11.7243
n:11.6732
now:11.4011
idx:11.3553
pid:10.9891
some:10.9232
old:10.7952
prev:10.6018
index:10.5777

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
Id:20.743
):17.3959
id:17.0622
ID:16.3846
_:15.5465
Index:13.3549
s:13.0254
1:12.979
I:12.9698
Play:12.9053
Ids:12.6045
),:12.3761	prefix accepted:)
Name:12.129
_):11.9158	prefix accepted:_
Num:11.4828
Number:11.2927
)->:11.2748	prefix accepted:)
)=:11.1844	prefix accepted:)
To:11.0452
A:10.9714
State:10.9132

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songId
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):20.4176
),:17.0383	prefix accepted:)
)=:15.4471	prefix accepted:)
 as:14.1618	prefix accepted: 
1:13.7244
)->:13.4881	prefix accepted:)
)|:13.0672	prefix accepted:)
 ):12.9684
2:12.5203
_):11.9946	prefix accepted:_
::11.8669	rejected
)::11.7595	prefix accepted:)
0:11.3594
'):11.335	rejected
P:11.2534
:::10.8643	rejected
)):10.6282	prefix accepted:)
 =>:10.4747	prefix accepted: 
_:11.9946
@:10.3566	rejected
On:10.24

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.2017
 :13.6173
  :13.5745
 as:12.7505	prefix accepted: 
 ->:12.6621	prefix accepted: 
    :12.3079
   :11.9291
 |:11.7157	prefix accepted: 
 ||:11.5388	prefix accepted: 
      :11.273
 when:11.1626	prefix accepted: 
     :10.7627
       :10.7163

:10.5345
	:10.1587	rejected
 =:10.15
        :10.1089
 :::10.0209	prefix accepted: 
 if:9.96084	prefix accepted: 
 :=:9.93419	prefix accepted: 
         :9.92284

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:19.1001
 :17.3499

:16.3619
 play:16.1498
 ((:15.0314	prefix accepted: (
  :15.0211
 let:14.9495
 ([:14.5618	prefix accepted: (
 if:13.7518
 [:12.7749
 get:12.7295
(:12.4165
 (*:12.3558	prefix accepted: (
 #:12.2905	prefix accepted: 
    :12.0677
 [(:11.9626	prefix accepted: [
 update:11.7202
   :11.3927
 return:11.3251	prefix accepted: 
      :11.1947
 List:11.0615

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
get:19.0921
song:14.2099
 get:13.1135
List:12.5452
let:12.5314
f:12.1832	rejected
play:12.096
in:10.7816
#:10.5534	rejected
Play:10.4043	rejected

:10.106
 (:10.002
 songs:9.82178	prefix accepted: song
s:9.79985
first:9.35384	rejected
 #:9.18461	prefix accepted: 
 let:9.04417
list:8.95662	prefix accepted:l
 List:8.84228
 play:8.81485
sing:8.74537	prefix accepted:s

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get"))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get
Nature of error: Variable get is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get
LSP: Generating Completions for prefix: get
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_songs"
root ::= completions

Top 20 Logits:
_:22.6207
S:13.2938	rejected
(:11.4127	rejected
<:11.1118	rejected
 songs:10.6706	rejected
__:10.6157	prefix accepted:_
-:10.3833	rejected
Play:10.2703	rejected
.:10.0787	rejected
song:10.042	rejected
_(:9.74138	prefix accepted:_
First:9.65304	rejected
 Songs:9.64438	rejected
List:9.49677	rejected
::9.2823	rejected
All:9.04659	rejected
1:8.73925	rejected
[:8.3436	rejected
App:8.22917	rejected
|:8.1879	rejected
:::8.18525	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get_"))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_
Nature of error: Variable get_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get_
LSP: Generating Completions for prefix: get_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "songs"
root ::= completions

Top 20 Logits:
song:25.5679
all:16.2636	rejected
play:16.1103	rejected
state:15.7003	prefix accepted:s
sing:15.4865	prefix accepted:s
current:15.3415	rejected
ids:14.6819	rejected
son:14.3616
id:14.092	rejected
album:13.6333	rejected
s:15.7003
S:13.2588	rejected
music:13.2132	rejected
 songs:13.1342	rejected
sound:13.1031	prefix accepted:so
first:13.0092	rejected
plays:12.9849	rejected
list:12.9286	rejected
p:12.9129	rejected
items:12.5848	rejected
at:12.3654	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get_song"))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_song
Nature of error: Variable get_song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get_song
LSP: Generating Completions for prefix: get_song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:23.5548
(:14.2535	rejected
_:13.6837	rejected
Ids:13.0659	rejected
ids:11.1446	rejected
(),:10.9757	rejected
List:10.7386	rejected
S:10.5794	rejected
,:10.5119	rejected
Id:10.4958	rejected
ID:10.0422	rejected
es:9.94599	rejected
ss:9.7568	prefix accepted:s
id:9.55768	rejected
sBy:9.35066	prefix accepted:s
st:9.34456	prefix accepted:s
():9.1186	rejected
((:9.02388	rejected
song:8.77126	prefix accepted:s
 (:8.64492	rejected
sl:8.51775	prefix accepted:s

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: (PlayList -> [Id])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList");
           syn = (Arrow ((Var "PlayList"), (List (Var "Id"))))})))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_songs
Nature of error: Expecting type PlayList but got inconsistent type (PlayList -> [Id])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: get_songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (PlayList -> [Id])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Arrow ((Var "PlayList"), (List (Var "Id"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: get_songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Arrow ((Var "PlayList"), (List (Var "Id"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:22.3304
 play:16.0626	prefix accepted: 
 (:14.4926
(),:13.0957	prefix accepted:(
,:12.9539	rejected
((:12.7114	prefix accepted:(
(@:11.1698	prefix accepted:(
(*:10.5517	prefix accepted:(
():10.4279	prefix accepted:(
::10.3244	rejected
([:10.278	prefix accepted:(
[:10.2055	rejected
_:10.1697	rejected
play:9.98297	rejected
(_:9.9236	prefix accepted:(
({:9.77008	prefix accepted:(
)(:9.42558	prefix accepted:)
(&:9.37766	prefix accepted:(
 ,:9.35877	prefix accepted: 
 player:9.27036	prefix accepted: 
.(:9.12818	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_songs(?)
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_songs(?)
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_songs(?)
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
play:21.5394
 play:15.3031
pl:13.613
Play:12.9849	rejected
p:12.7853
song:12.6643
pal:12.5439	prefix accepted:p
player:12.2335	prefix accepted:play
plays:11.9602	prefix accepted:play
current:11.4304	prefix accepted:c
x:11.2048	rejected
get:11.0809
pay:10.8039	prefix accepted:p
action:10.6527	prefix accepted:a
self:10.0453	prefix accepted:s
ps:9.96671	prefix accepted:p
pla:9.92645
init:9.80352	prefix accepted:in
my:9.79312	prefix accepted:m
a:10.6527
remove:9.67671	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_songs(play)
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:22.9227
List:19.0991	rejected
l:14.8463
),:13.9936	rejected
ist:13.1038	rejected
lst:12.6815	prefix accepted:l
lists:12.5707	prefix accepted:list
 list:12.5259	rejected
lis:12.3821
_:12.0289	rejected
let:11.9563	prefix accepted:l
ls:10.9516	prefix accepted:l
lish:10.688	prefix accepted:lis
last:10.6783	prefix accepted:l
line:10.4936	prefix accepted:li
ll:10.3767	prefix accepted:l
,:10.2558	rejected
lit:10.2336	prefix accepted:li
LIST:10.0719	rejected
link:10.0574	prefix accepted:li
 List:9.90124	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_songs(playlist)
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
),:23.5982	prefix accepted:)
):23.5982
),(:13.6924	prefix accepted:)
 ),:13.5199	prefix accepted: )
)),:13.487	prefix accepted:)
)):13.1126	prefix accepted:)
,:12.8338	rejected
 @:11.6978	prefix accepted: 
),\:11.6475	prefix accepted:)
::11.3061	rejected
)::11.2057	prefix accepted:)
).:11.035	prefix accepted:)
);:10.9693	prefix accepted:)
@:10.8419	rejected
()),:10.0344	rejected
],:9.8647	rejected
.:9.8058	rejected
)[:9.64593	prefix accepted:)
 as:9.53028	prefix accepted: 
 ::9.42996	prefix accepted: 
'),:9.37462	rejected
Rejected the highest logit candidate ), with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_songs(playlist)
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.4336
 @:14.5137
 ++:11.9215	prefix accepted: 
@:11.898
 :11.9215
 as:11.3357	prefix accepted: 
 +:11.1198	prefix accepted: 
 ::10.8619	prefix accepted: 
  :10.6687

:10.2888
 :::9.93373	prefix accepted: 
 -:9.90966	prefix accepted: 
    :9.64111
   :9.63289
:::9.49714	rejected
                :9.325
，:9.26491	rejected
 --:9.22742	prefix accepted: 
 |:9.17028	prefix accepted: 
 [],:9.16033	prefix accepted: 
 List:9.11064	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) ,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) ,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 P:18.6996
P:17.3097
 :13.9061
 (:12.452
  :11.5959
 paused:11.4948	prefix accepted: 
 Play:11.1153

:10.0309
 pause:9.82555	prefix accepted: 
 if:9.74276
 No:9.25791
 Some:9.22728	prefix accepted: 
Play:9.2253
(:9.05817
 #:9.02806	prefix accepted: 
   :8.91621
 song:8.87318	prefix accepted: 
    :8.83768
p:8.78258	rejected
 @:8.50558	prefix accepted: 
 new:8.3737	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) ,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ausedOn" | "laying"
root ::= completions

Top 20 Logits:
aused:27.1288
ause:16.2205
aus:14.3031
 paused:14.1968	rejected
ushed:13.1209	rejected
osed:12.6039	rejected
ased:11.8744	prefix accepted:a
au:11.434
ending:11.3231	rejected
leased:10.5507	prefix accepted:l
used:10.3286	rejected
icked:10.1037	rejected
P:9.87082	rejected
p:9.80534	rejected
ared:9.77099	prefix accepted:a
oused:9.59973	rejected
uzz:9.37346	rejected
ained:9.36017	prefix accepted:a
uted:9.26411	rejected
ued:9.18248	rejected
aled:9.00652	prefix accepted:a

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , Paused

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , Paused
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:25.9005
(:15.7572	rejected
on:12.9533	rejected
 On:12.7181	rejected
S:12.0853	rejected
 on:11.9298	rejected
 song:11.693	rejected
_:11.5717	rejected
O:11.5258
One:11.365	prefix accepted:On
At:11.2234	rejected
In:11.2126	rejected
By:11.1983	rejected
Of:11.1113	prefix accepted:O
ON:11.1073	prefix accepted:O
 (:10.9979	rejected
From:10.6037	rejected
To:10.219	rejected
Off:10.077	prefix accepted:O
Play:10.0616	rejected
Over:10.0303	prefix accepted:O

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , Paused
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Id -> PlayListState)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:22.0154
 song:17.516	prefix accepted: 
 (:15.2921
((:13.9309	prefix accepted:(
():11.4085	prefix accepted:(
(-:11.2438	prefix accepted:(
([:11.0252	prefix accepted:(
(@:10.9392	prefix accepted:(
({:10.7756	prefix accepted:(
song:10.7352	rejected
(_:10.7167	prefix accepted:(
()):10.6119	prefix accepted:(
 :17.516
($:10.4045	prefix accepted:(
 songs:10.1023	prefix accepted: 
[:9.93426	rejected
(*:9.87742	prefix accepted:(
(":9.8318	prefix accepted:(
(!:9.71945	prefix accepted:(
(&:9.52252	prefix accepted:(
(?:9.47451	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
song:22.1211
 song:16.6888
get:13.4383	rejected
0:12.4171
1:11.8639
play:11.4726	rejected
sound:10.967	prefix accepted:so
Int:10.9308	rejected
sing:10.823	prefix accepted:s
S:10.6037	rejected
Play:10.4019	rejected
id:10.3737	prefix accepted:i
current:10.3302	prefix accepted:c
s:10.823
son:10.0969
some:10.0775	prefix accepted:so
5:10.0203
2:9.95077
P:9.89831	rejected
 :9.84896
p:9.53014	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:26.1463
id:14.6696	rejected
I:14.4167
Add:13.4655	rejected
ID:13.3181	prefix accepted:I
 Id:13.2704	rejected
If:13.1054	prefix accepted:I
)):12.5226	rejected
):12.5143	rejected
Ids:12.4447	prefix accepted:Id
In:12.1433	prefix accepted:I
Is:12.1296	prefix accepted:I
It:11.9749	prefix accepted:I
_:11.8058	rejected
Info:11.3942	prefix accepted:I
Num:11.3598	rejected
Name:11.296	rejected
Item:11.2939	prefix accepted:I
.:10.9078	rejected
To:10.8586	rejected
(:10.8085	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
)):22.688	prefix accepted:)
):22.688
)),:15.6278	prefix accepted:)
));:15.3564	prefix accepted:)
 :14.0421
))):13.4935	prefix accepted:)
)).:13.1	prefix accepted:)
 ):13.0026
),:12.7587	prefix accepted:)
))::12.7262	prefix accepted:)
))]:12.6134	prefix accepted:)
)))):12.1151	prefix accepted:)
)));:11.9787	prefix accepted:)
  :11.5179
))`:11.4444	prefix accepted:)
)){:11.3032	prefix accepted:)
)|:10.9199	prefix accepted:)
);:10.6832	prefix accepted:)
))\:10.3225	prefix accepted:)
)]:10.068	prefix accepted:)
))$:10.0372	prefix accepted:)
Rejected the highest logit candidate )) with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 ):19.6868
 :15.5341
  :14.5559
 ),:14.0146	prefix accepted: )
 );:13.9746	prefix accepted: )

:12.2498
    :12.0445
   :11.8903
      :11.1867
       :10.8787
	:10.8378	rejected
     :10.8083
                :10.6525
 @:10.3535	prefix accepted: 
        :10.2742
          :10.0922
 :::10.0462	prefix accepted: 
 |:9.9978	prefix accepted: 
         :9.95356
 ::9.94888	prefix accepted: 
 as:9.79856	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:20.4644
 :18.114
  :17.4981
    :15.4317
      :15.3156
 #:15.1026	prefix accepted: 
   :14.3681
 (*:14.1609	prefix accepted: 
 end:13.9337
        :13.6661
       :13.5345
                :13.4101
     :13.1
#:12.8089	rejected
         :12.8003
            :12.6742
          :12.6399
	:12.501	rejected
 |:12.4808
           :12.1612
              :12.1173

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :22.1133
       :17.2016
      :16.6315
   :15.8907
                :15.8363
	:15.4495	rejected
    :15.3098
        :15.0262
#:14.7306	rejected
         :14.6277

:14.5875
           :14.3434
          :13.9978
            :13.467
               :13.3511
  :13.2593
 :13.1859
              :13.0775
             :13.0106
|:12.7626
(*:12.6486	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.9564
 #:20.1982	prefix accepted: 
 end:17.3166
 (*:16.6793	prefix accepted: 
 else:14.7233	prefix accepted: e
 //:14.4216	prefix accepted: 
 _:14.3857	prefix accepted: 
 /*:13.5595	prefix accepted: 
 ##:13.5534	prefix accepted: 
 *:13.2491	prefix accepted: 
 (_:13.2051	prefix accepted: 
 --:13.1196	prefix accepted: 
 in:12.8078	prefix accepted: 
 <:12.7676	prefix accepted: 
 ||:12.6247	prefix accepted: |
 case:12.5742	prefix accepted: 
 (**:12.4432	prefix accepted: 
 otherwise:12.3027	prefix accepted: 
 ~:12.288	prefix accepted: 
 (:12.2569	prefix accepted: 
 /:12.1615	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 _:17.3935
 P:15.2849
 No:14.1142
 other:12.5815
 otherwise:12.4772
 x:12.4475
 state:12.0208
 s:11.1115
_:10.5707
 :10.5526
 current:10.5449
 paused:10.4344
 p:10.3938
 others:10.188
 Play:10.0692
 rest:9.90819
 _,:9.42778	prefix accepted: _
 a:9.31286
 song:9.30122
 playing:9.07107
 Not:9.00234	prefix accepted: No

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: BidiCtx: Cls: Wildcard
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.8831
=>:14.0441
               :13.8334
 :12.5517
              :12.3567
 as:11.9312	prefix accepted: 
 ->:11.7808	prefix accepted: 
:::11.2946	rejected
 :=:11.2213	prefix accepted: 
  :10.6784
 then:10.6724	prefix accepted: 
 :::10.6507	prefix accepted: 
                :10.2837
 else:10.2418	prefix accepted: 
             :9.73823
      :9.6498
       :9.54356
    :9.53246
          :9.47843
else:9.43663	rejected
   :9.22394

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 play:19.1179
 (:15.361
 :13.0295
 fail:12.3358	prefix accepted: 
 raise:12.2641	prefix accepted: 
 let:11.7182
 get:11.1942
 no:10.979	prefix accepted: 
 ((:10.7565	prefix accepted: (
 error:10.7456	prefix accepted: 
 ([:10.4395	prefix accepted: (
  :10.3829
play:10.0887
 (*:9.9743	prefix accepted: (
 (":9.88972	prefix accepted: (

:9.85177
 #:9.58305	prefix accepted: 
 assert:9.52813	prefix accepted: a
 update:9.36654
 [:9.31025
 throw:9.22112	prefix accepted: t

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:22.8551
List:15.9578	rejected
ist:12.8235	rejected
l:12.2418
lists:12.1989	prefix accepted:list
_:11.9348	rejected
lis:11.9281
 list:11.9013	rejected
lst:11.8696	prefix accepted:l
lit:11.7638	prefix accepted:li
ls:10.9767	prefix accepted:l

:10.6464	rejected
li:11.7638
let:9.69651	prefix accepted:l
ll:9.57797	prefix accepted:l
play:9.40938	rejected
ilst:9.28732	rejected
state:9.21723	rejected
link:9.1459	prefix accepted:li
listen:9.00494	prefix accepted:list
L:8.97258	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.836
 end:18.744
 :17.0639
 #:16.4234	prefix accepted: 
  :15.9585
 (*:15.0615	prefix accepted: 
                :14.6842
      :14.5573
    :14.27
        :13.4801
       :13.2246
 in:13.1781	prefix accepted: 
   :13.1021
;:12.9209	rejected
            :12.7447
         :12.6296
          :12.6204
     :12.5107
#:12.4866	rejected
              :12.3896
(*:12.1236	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.4733
     :17.7481
    :14.6133

:14.054
      :13.5545
  :13.0085
       :12.347
 :12.2903
end:12.1231
#:11.29	rejected
in:11.2675	rejected
(*:11.2098	rejected
	:10.8909	rejected
        :10.8646
                :10.4377
|:10.057
          :9.74759
         :9.55193
           :9.30296
            :9.13073
 in:9.12368	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:23.2825
 #:16.4276	prefix accepted: 
 |:15.1661
 (*:14.3236	prefix accepted: 
 in:13.1963	prefix accepted: 
 case:12.9458	prefix accepted: 
 es:12.7356	prefix accepted: e
 ;:12.5928	prefix accepted: 
 End:12.3718	prefix accepted: 
 match:12.0393	prefix accepted: 
 let:11.8679	prefix accepted: 
 else:11.7351	prefix accepted: e
 if:11.6809	prefix accepted: 
 p:11.3772	prefix accepted: 
 //:11.3031	prefix accepted: 

:11.2153
 >:11.2112	prefix accepted: 
 END:11.2069	prefix accepted: 
 (:11.1419	prefix accepted: 
 pass:11.098	prefix accepted: 
 ():11.0549	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:20.5687
 :17.7022
  :17.2269
    :16.0902
      :15.9013
 #:15.3615	prefix accepted: 
        :14.5446
   :14.4593
       :13.7867
                :13.4154
	:13.3698	rejected
     :13.3253
 (*:13.2656	prefix accepted: 
          :13.0409
         :12.9281
            :12.8359
;:12.1783	rejected
           :12.0579
              :11.9191
#:11.8133	rejected
             :11.6801

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :20.1428
    :16.3645
  :15.3707

:15.1899
     :15.0684
      :14.5235
       :13.5415
 :13.4745
        :13.2494
#:12.8655	rejected
	:12.3725	rejected
         :11.6729
end:11.6394
          :11.2726
            :11.196
                :11.1055
(*:10.9121	rejected
|:10.7675
           :10.4482
in:10.3554	rejected
 #:9.96324	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
   

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
   
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.3315
 #:19.3502	prefix accepted: 
 (*:15.3927	prefix accepted: 
 end:13.9718
 //:13.1874	prefix accepted: 
 ##:12.4464	prefix accepted: 
 /*:12.405	prefix accepted: 
 <:11.998	prefix accepted: 
 case:11.9622	prefix accepted: 
 --:11.8509	prefix accepted: 
 in:11.6612	prefix accepted: 

:11.6193
 (:11.5502	prefix accepted: 
 (**:11.5003	prefix accepted: 
 ~:11.4222	prefix accepted: 
 let:11.3131	prefix accepted: 
 /:11.2451	prefix accepted: 
 *:11.184	prefix accepted: 
 else:11.1325	prefix accepted: e
 ...:11.1245	prefix accepted: 
 ():10.9443	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Remove:21.2696
 Add:18.1326
 _:13.2735
 P:13.1508
Remove:12.6064
 Rem:12.499
 :12.3207
 Play:11.438
 #:11.2184	prefix accepted: 
 No:11.2082	prefix accepted: 
 Res:10.8791	prefix accepted: Re
 Delete:10.7498	prefix accepted: 
 Update:10.3022	prefix accepted: 
 Re:10.8791
 Change:10.0056	prefix accepted: 
 Stop:9.78473	prefix accepted: 
 App:9.69287	prefix accepted: A
 remove:9.66371
 Move:9.58663	prefix accepted: 
 Un:9.56743	prefix accepted: 
 Replace:9.56003	prefix accepted: Re

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | Remove

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | Remove
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Remove>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Remove"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Remove
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Remove
LSP: Generating Completions for prefix: Remove
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:23.1741
(:13.0028	rejected
From:12.3261	rejected
All:12.0028	rejected
 Song:11.876	rejected
Current:11.7248	rejected
 song:11.5102	rejected
Selected:10.9957	prefix accepted:S
Last:10.0984	rejected
_:9.94686	rejected
Sing:9.52831	prefix accepted:S
song:9.49254	rejected
Play:9.47854	rejected
And:9.36198	rejected
First:9.30778	rejected
P:9.24417	rejected
(_:9.1841	rejected
T:9.13269	rejected
E:9.11963	rejected
SON:8.85185	prefix accepted:S
Sound:8.80089	prefix accepted:So

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | Remove
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "RemoveS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  RemoveS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RemoveS
LSP: Generating Completions for prefix: RemoveS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:28.8107
ongs:17.6995	prefix accepted:ong
on:14.3067
 song:13.6942	rejected
song:13.2325	rejected
ongo:13.0523	prefix accepted:ong
ng:12.36	rejected
ame:11.6574	rejected
ond:11.2826	prefix accepted:on
one:11.2636	prefix accepted:on
ONG:11.0707	rejected
oon:10.9909	prefix accepted:o
ang:10.8015	rejected
inger:10.5245	rejected
ug:10.4695	rejected
 Song:10.4353	rejected
n:10.3505	rejected
ung:10.2862	rejected
(:9.94294	rejected
ont:9.81469	prefix accepted:on
onic:9.48977	prefix accepted:on

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Id -> PlayListAction)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  RemoveSong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: RemoveSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RemoveSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:21.2804
(_:15.8355	prefix accepted:(
 song:15.4948	prefix accepted: 
 (:14.5737
 id:13.0312	prefix accepted: 
((:12.0296	prefix accepted:(
 =>:12.0189
():11.2766	prefix accepted:(
([:10.4803	prefix accepted:(
 _:10.3918	prefix accepted: 
 ->:10.2248	prefix accepted: 
ById:9.93589	rejected
 :15.4948
 s:9.40113	prefix accepted: 
 songs:9.34344	prefix accepted: 
song:9.32889	rejected
From:9.30788	rejected
(?:9.20951	prefix accepted:(
=>:8.98664
 (_:8.86049	prefix accepted: (
(@:8.82726	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
song:19.209
id:16.3617
remove:14.475
rem:13.9412
to:13.4203
current:12.5602
 song:12.5297
target:12.4087
x:11.9908
i:11.8734
play:11.562
invalid:11.5124
index:11.4545
idx:11.4371
s:11.4033
Id:11.248	rejected
old:11.2175
selected:11.1879
0:11.0646
delete:11.0469
sound:11.0189

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
Id:22.6506
ID:17.4509
To:17.4247
id:17.3196
_:15.8104
):15.3094
I:13.8413
Index:13.7904
Ids:13.7574
Rem:13.23
s:13.1709
Remove:12.569
d:12.4373
Key:12.3987
Name:12.292
In:12.2041
1:11.8428
2:11.8126
Number:11.4325
Num:11.4185
t:11.3924

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songId
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):20.5681
To:16.3603
)=:15.6856	prefix accepted:)
 ):13.7017
)->:13.041	prefix accepted:)
2:12.6545
1:12.4205
_:12.4196
'):12.3612	rejected
x:11.9815
),:11.4638	prefix accepted:)
In:11.1575
_):11.1204	prefix accepted:_
 as:11.0848	prefix accepted: 
For:10.7429
 =>:10.5763	prefix accepted: 
t:10.5353
Remove:10.4827
Rem:10.481
to:10.4223
0:10.3911

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.7059
 :15.1162
 ->:14.3244	prefix accepted: 
  :13.2454
 when:13.025	prefix accepted: 
 if:12.9943	prefix accepted: 

:12.7114
    :11.3299
=>:11.257
   :10.8381
	:10.5843	rejected
 :=:10.5569	prefix accepted: 
 =:10.3521
 as:10.2467	prefix accepted: 
 ==>:10.1998	prefix accepted: =
      :10.1494
 {:9.64005	prefix accepted: 
        :9.41457
 ==:9.37407	prefix accepted: =
 to:9.36774	prefix accepted: 
     :9.33836

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 :19.282

:18.4815
  :16.8812
 (:15.1333
 let:14.6782
    :14.0303
 #:13.8961	prefix accepted: 
 if:13.2696
      :13.177
 (*:13.1585	prefix accepted: (
   :13.0083
                :12.9427
        :12.8281
 ((:12.7628	prefix accepted: (
         :12.594
 {:12.5391	prefix accepted: 
       :12.3488
     :12.2114
          :11.7576
 update:11.6755
            :11.6621

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:22.735
 (:15.1355
 #:14.9919	prefix accepted: 
 let:14.452
	:14.3583	rejected
 (*:13.5905	prefix accepted: (
 if:13.5179
 ((:13.3165	prefix accepted: (
 filter:13.1078	prefix accepted: 
 List:12.2862
1:12.0751
 {:11.8246	prefix accepted: 
0:11.6343
 [:11.5259
 #(:11.4782	prefix accepted: 
 list:11.3457	prefix accepted: l
 case:11.2146
 begin:11.1381	prefix accepted: 
 ([:10.6877	prefix accepted: (
2:10.6294
 [(:10.4791	prefix accepted: [

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
     :23.3888
       :21.3716
      :19.8092
    :19.035
         :18.0681
   :17.8698
        :17.0181
           :16.8562
	:16.8131	rejected
          :15.3833

:15.1933
#:15.0759	rejected
             :15.0079
                :14.9849
  :14.9486
               :14.5841
            :14.5453
 :13.6305
              :13.5252
let:11.7594
(*:11.2318	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 let:24.1917
 if:20.3962
 case:19.5253
 #:19.504	prefix accepted: 
 (:19.4262
 match:16.9489	prefix accepted: ma
 (*:16.5281	prefix accepted: (
 ((:16.3902	prefix accepted: (
 begin:15.4206	prefix accepted: 
 {:14.949	prefix accepted: 
 List:14.8963
 #(:14.6093	prefix accepted: 
 ([:14.571	prefix accepted: (
 [:14.3469
 <:13.8135	prefix accepted: 
 list:13.7182	prefix accepted: l
 remove:13.7074	prefix accepted: 
 update:13.6748
 assert:13.5611	prefix accepted: a
 print:13.5226	prefix accepted: p
 get:13.4855

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:18.9794
 song:14.1546
 current:13.4696
 filtered:13.077
 new:12.8842
 all:12.6175
 ids:12.3675
 old:12.2927
 _,:12.1656	prefix accepted: _
 remove:12.0838
 (:11.4923
 cur:11.4509
 curr:11.3423
 list:11.2187
 filter:11.2148
 s:11.04
 id:10.9534
 play:10.9401
 xs:10.8859
 existing:10.8591
 updated:10.8278

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:21.3896
 =:19.1655
To:14.386
 ,:14.2643
_:14.2201
In:14.0089
_,:13.9201	prefix accepted:_
',:13.2383	rejected
List:13.0885
1:13.0255
=:12.4032
':12.1068	rejected
With:12.0543
2:11.8257
::11.7796
 :11.6566
Play:11.6514
0:11.5289
Before:11.5042
Left:11.3008
  :11.2666

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 state:18.386
 current:17.4627
 _:15.8555
 song:13.2086
 playing:12.9897
 curr:12.989
 play:12.813
 old:12.2572
 cur:11.9948
 s:11.9816
 status:11.7582
 st:11.0866
 states:11.0785
 p:11.07
 selected:11.0354
 new:11.0181
_:10.9494
 player:10.7173
state:10.6367
 id:10.6067
current:10.5951

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: ?, songs: ?, songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: state
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: state
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:22.7367
=:16.2954
 :14.8721
_:13.5575
1:13.2836
Play:12.8935
Current:12.2138
2:12.1586
Of:12.1326
0:12.1305
Id:12.0527
  :11.777
':11.705	rejected
 as:11.5034	prefix accepted: 
Old:11.3633
Before:11.1827
::11.1238
In:10.9925
S:10.9262
 ->:10.9164	prefix accepted: 
To:10.6044

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "playlist" | "sin" | "songId" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:20.545
 get:14.6587
 :14.4655
 (:13.9343
play:12.8631
 List:12.8202

:12.7481
 remove:11.3797	prefix accepted: 
 if:11.0674
 update:10.6607
  :10.644
 filter:10.2143	prefix accepted: f
 list:10.1797	prefix accepted: l
 ((:10.1271	prefix accepted: (
 delete:9.8511	prefix accepted: 
 let:9.60072
 Play:9.5863
 pal:9.50989	prefix accepted: pa
 pl:9.49382
 match:9.48471	prefix accepted: ma
 player:9.17046	prefix accepted: play

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:24.2965
List:15.1394	rejected
 list:14.2043	rejected
lst:13.7934	prefix accepted:l
l:13.7934
ist:12.9706	rejected
lit:12.9328	prefix accepted:li
link:12.0161	prefix accepted:li
_:11.5454	rejected
let:11.3517	prefix accepted:l
load:11.3485	prefix accepted:l
ls:10.9884	prefix accepted:l
lista:10.7694	prefix accepted:list
lists:10.7091	prefix accepted:list
line:10.4327	prefix accepted:li
listen:10.3564	prefix accepted:list
lot:10.271	prefix accepted:l

:10.2516	rejected
last:10.0622	prefix accepted:l
.:9.93039	rejected
,:9.87063	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:22.0032
 :14.4121

:14.2756
,:12.681
;:11.8533	rejected
  :11.8189
.:11.2877	rejected
 and:10.9275	prefix accepted: 
in:10.3894
    :9.698
 ;:9.56594	prefix accepted: 
	:9.47538	rejected
   :9.45034
 ,:9.39148
                :9.36125
 #:9.17585	prefix accepted: 
      :8.89351
       :8.55485
        :8.43888
     :8.28682
 with:8.28213	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:20.3811
 :17.4989
  :16.3901
    :15.3498
      :14.9989
        :13.7089
   :13.3163
       :13.2046
     :13.1658
                :13.0523
            :12.9184
          :12.8957
         :12.6053
 #:12.453	prefix accepted: 
	:12.3136	rejected
           :12.0842
              :11.9437
             :11.5863
 (:11.3717
 List:11.0375
               :10.9164

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
     :21.8875
       :19.1965
      :17.4382
    :16.5056
         :16.3984

:15.8008
        :15.3775
	:15.1329	rejected
   :14.9433
           :14.5392
  :13.8669
          :13.6224
#:13.3288	rejected
                :13.2262
 :13.0537
             :12.8441
            :12.4829
               :12.2845
if:11.6845
(*:11.6713	prefix accepted:(
              :11.1666

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 if:22.3351
 case:20.3984
 let:20.378
 (:20.2956
 #:19.2518	prefix accepted: 
 match:18.2975	prefix accepted: ma
 ((:18.1231	prefix accepted: (
 (*:16.7292	prefix accepted: (
 ([:16.1089	prefix accepted: (
 List:16.0194
 {:15.0071	prefix accepted: 
 filter:14.7383	prefix accepted: 
 songs:14.555
 song:14.227
 //:14.1517	prefix accepted: 
 remove:14.1335	prefix accepted: 
 ({:14.1275	prefix accepted: (
 Play:13.9858	prefix accepted: 
 get:13.8891
 #(:13.7921	prefix accepted: 
 list:13.6576	prefix accepted: l

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "String.reverse" | "String.starts_with" | "String.transform" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "songId" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:19.6723
 get:14.2359	prefix accepted: 
 not:13.774	prefix accepted: n
 (:13.6182
 song:13.4188
 state:13.3101	prefix accepted: st
 songs:13.2247	prefix accepted: song
 contains:12.9155	prefix accepted: co
 :14.2359
 Song:11.1489	prefix accepted: S
 list:11.0705	prefix accepted: l
 !:10.9848
 Songs:10.6732	prefix accepted: S
List:10.5278
 ((:10.4548	prefix accepted: (
 is:10.3423
(:10.3295
 String:10.0837
  :9.93358

:9.80041
 states:9.55378	prefix accepted: st

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".contains" | ".eq" | ".fold_left" | ".fold_right" | ".is_empty" | ".length"
root ::= completions

Top 20 Logits:
.:22.5234
.(:12.4381	prefix accepted:.
_:11.9216	rejected
(:11.7609	rejected
 .:10.6651	rejected
List:10.595	rejected
._:9.90323	prefix accepted:.
.<:9.35114	prefix accepted:.
.@:8.8063	prefix accepted:.
::8.74897	rejected
.[:8.55371	prefix accepted:.
():8.5474	rejected
().:8.52497	rejected
 (:8.35686	rejected
((:8.30532	rejected
[:8.30492	rejected
..:8.082	prefix accepted:.
:::8.02538	rejected
1:7.99692	rejected
Int:7.85417	rejected
s:7.82389	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "contains" | "eq" | "fold_left" | "fold_right" | "is_empty" | "length"
root ::= completions

Top 20 Logits:
contains:24.8709
length:18.7854
filter:18.3833	prefix accepted:f
is:17.6992
eq:17.3932
exists:17.0477	prefix accepted:e
mem:15.7371	rejected
equals:15.6422	prefix accepted:eq
includes:15.2987	prefix accepted:i
member:15.0566	rejected
find:14.9451	prefix accepted:f
remove:14.8256	rejected
filters:14.0908	prefix accepted:f
starts:13.9526	rejected
count:13.9017	prefix accepted:co
fold:13.6705
 contains:13.5799	rejected
isEmpty:13.5638	prefix accepted:is
members:13.3549	rejected
any:13.31	rejected
cons:13.2888	prefix accepted:con

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.contains>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (((? -> Bool), [?]) -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool;
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Unknown TypeHole), Bool));
                   (List (Unknown TypeHole))]),
              Bool))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  List.contains
Nature of error: Expecting type Bool but got inconsistent type (((? -> Bool), [?]) -> Bool)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: List.contains
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (((? -> Bool), [?]) -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: List.contains
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "then"
root ::= new-tokens

Top 20 Logits:
(:21.67
((:19.0325	prefix accepted:(
 (:16.0872
(_:14.3625	prefix accepted:(
 ((:13.9504	prefix accepted: (
($:13.7938	prefix accepted:(
(\:13.7311	prefix accepted:(
([:13.3175	prefix accepted:(
({:12.7637	prefix accepted:(
(?:12.7052	prefix accepted:(
(():12.6367	prefix accepted:(
(@:12.0759	prefix accepted:(
_:12.0335	rejected
($(:12.0144	prefix accepted:(

:11.9468
?(:11.915	rejected
(`:11.5928	prefix accepted:(
<:11.4994	rejected
():11.1683	prefix accepted:(
_(:10.8826	rejected
(-:10.8492	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "String.starts_with" | "bool_of_string" | "case " | "fun " | "if " | "is_finite" | "is_infinite" | "is_nan" | "let " | "type "
root ::= new-tokens

Top 20 Logits:
fun:20.1941
 fun:15.6911
song:13.1237	rejected

:12.3858
id:12.3595	prefix accepted:i
eq:12.0922	rejected
 (:11.8262
func:11.356	prefix accepted:fun
equal:11.2099	rejected
 song:10.5208	prefix accepted: 
f:10.0991
function:9.99608	prefix accepted:fun
 :10.5208
lambda:9.79992	prefix accepted:l
equals:9.76272	rejected
fn:9.3917	prefix accepted:f
==:9.11019	rejected
Fun:9.08965	rejected
List:9.08791
 id:9.03955	prefix accepted: i
 ((:8.94566	prefix accepted: (

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun ? ->
 ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 id:21.1481
 song:16.2391
 x:15.5746
 s:14.7384
 sid:14.3664
 current:13.7783
 (:13.4763
 i:13.3098
 other:12.7707
 a:12.5345
(:12.4917
 cur:12.4851
 curr:12.1631
 idx:12.1601
 Id:11.9846	prefix accepted: 
 el:11.9745
 ids:11.7747
 _:11.5144
 pid:11.3927
 index:11.3696
 element:11.3578

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:22.7203
->:15.6913
 :13.5299
1:12.9033
 =>:12.6396	prefix accepted: 
2:11.9875
 -:11.6608
_:11.4114
':11.1185	rejected
::11.0854
 ::10.6653
0:10.5616
 =:10.394	prefix accepted: 
  :10.387
 ~:10.1766	prefix accepted: 
,:10.1431
 -->:10.0274	prefix accepted: -
 →:9.99501	prefix accepted: 
 –:9.78314	prefix accepted: 
To:9.75927
 ==:9.69407	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id ->

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id ->
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id state songs songId action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt state string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "playlist" | "sin" | "songId" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 id:19.1675
 song:15.9959
 :12.8953
id:12.6753
 not:12.3018	prefix accepted: n
 (:12.1375
 if:11.385
 true:11.2936
 Song:10.9092	prefix accepted: S
song:10.3772
 Id:10.3284	prefix accepted: 
 false:9.9094
 i:9.89118

:9.63525
 return:9.34638	prefix accepted: 
 fun:9.25589
 !:9.18051
  :9.00924
 ids:8.74348	prefix accepted: id
 eq:8.61475	prefix accepted: e
 songs:8.56629

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id state songs songId action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt state string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ==:23.5557
 !=:17.5609
==:16.6512
 ===:15.9368	prefix accepted: ==
 =:15.7813
 :14.0887
 $:14.064
 <>:13.211	prefix accepted: <
 >:12.7932
$:12.551
 <:13.211
=:12.3533
 !==:12.1466	prefix accepted: !=
 ~:11.5957	prefix accepted: 
!=:11.4076
 is:11.4058	prefix accepted: 
 >=:11.3597
 -:11.173
 !:11.055
 <=:11.0447
=$:11.0224	prefix accepted:=

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id ==

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id ==
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id == ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id == ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id == ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: ==
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id state songs songId action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt state string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= completions | new-tokens

Top 20 Logits:
 song:23.9133
song:14.1446
 :13.3419
 Song:11.7454	prefix accepted: 
 (:11.1004
 get:10.2465	prefix accepted: 
 id:10.1026
 son:9.75204
 s:9.73797
 songs:9.67383	prefix accepted: song
 Int:9.63949	prefix accepted: 
 Id:9.35346	prefix accepted: 
 -:9.08141
  :8.86966
,:8.76233	rejected
 $:8.61736	prefix accepted: 
 state:8.60001	prefix accepted: st
 ,:8.56529	prefix accepted: 
 sid:8.45452	prefix accepted: s
 [:8.38277	prefix accepted: 
 &:8.31969	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id ==
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id == song
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:26.9285
id:15.9306	rejected
I:14.529
ID:13.9029	prefix accepted:I
 Id:13.7552	rejected
,:13.0867	rejected
Ids:12.8476	prefix accepted:Id
Ab:12.7524	rejected
If:12.7144	prefix accepted:I
In:12.4458	prefix accepted:I
Is:12.2311	prefix accepted:I
Ind:11.6035	prefix accepted:I
Var:11.5192	rejected
 id:10.9569	rejected
Im:10.8806	prefix accepted:I
_:10.842	rejected
Int:10.8072	prefix accepted:I
Name:10.7921	rejected
.:10.5124	rejected
(:10.4476	rejected
Index:10.2834	prefix accepted:I

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id == songId
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "," | "-" | "/"
root ::= new-tokens

Top 20 Logits:
,:19.7523
 ,:15.6043
 &&:13.8669	prefix accepted: 
):12.5657
)(:12.4303	prefix accepted:)
),:11.7052	prefix accepted:)
 ||:11.619	prefix accepted: 
 :13.8669
(),:10.8316	rejected
 and:10.6487	prefix accepted: 
 ):10.0426
 ?:9.99301	prefix accepted: 
,(:9.82015	prefix accepted:,
 in:9.61661	prefix accepted: 
 &:9.56424	prefix accepted: 
 *:9.3229
,,:9.27605	prefix accepted:,
  :9.09501
(:9.03053	rejected
 +:9.00914
 (:8.99378	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((? -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((? -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt state string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Unknown Internal), Bool)); (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "playlist" | "sin" | "songId" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:20.1208
 get:17.0311
song:13.7188
 (:13.2437
 :12.9565
 song:12.7969
 List:12.6241
 [:11.8482
 Songs:11.2173	prefix accepted: S
 play:10.9443
 list:10.7394	prefix accepted: l
get:10.3657
 state:10.0366

:9.43251
  :9.41251
 remove:9.1653	prefix accepted: 
 Song:9.03087	prefix accepted: S
 in:8.95159
List:8.86875
 Get:8.78172	prefix accepted: 
 tracks:8.77994	prefix accepted: tr

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Unknown Internal), Bool)); (List (Var "Id"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Unknown Internal), Bool)); (List (Var "Id"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt state string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):22.0133
 ):16.9137
 &&:14.3615	prefix accepted: 
),:14.0175	prefix accepted:)
){:13.3356	prefix accepted:)
 :14.3615
);:12.3771	prefix accepted:)
)=:12.0697	prefix accepted:)
 =:12.0148	prefix accepted: 
)):11.962	prefix accepted:)
)(:11.7564	prefix accepted:)
)]:11.665	prefix accepted:)

:11.4787
 ||:11.3467	prefix accepted: 
).:11.3139	prefix accepted:)
)\:11.1758	prefix accepted:)
):11.1404	prefix accepted:)
)::11.0444	prefix accepted:)
 and:10.9373	prefix accepted: 
=:10.8565	rejected
)?:10.8116	prefix accepted:)

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:

:20.3268
 then:18.7422
 :18.7203
 &&:18.0762
  :16.1708
 #:16.1629	prefix accepted: 
    :14.6198
      :14.5794
 and:13.9296	prefix accepted: 
        :13.3764
 ||:13.3033	prefix accepted: 
 =:13.2781	prefix accepted: 
   :13.0413
                :12.9513
       :12.683
         :12.5761
          :12.5394
            :12.4927
     :12.3952
 &:12.3195
 ==:12.0573	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
     :23.9126
       :21.3435
      :19.4004
        :19.0914
         :18.7771
	:17.3594	rejected
    :16.7415
           :16.6401
          :16.4102
   :15.4944
#:15.4433	rejected
                :15.222
            :15.1149

:14.8829
             :14.5505
               :14.29
  :13.9867
              :13.6937
 :13.6694
(*:11.6851	rejected
##:11.3602	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:24.6519
 #:19.1159	prefix accepted: 
 &&:16.8513
 and:15.3675	prefix accepted: 
 (*:15.0816	prefix accepted: 
 //:14.1222	prefix accepted: 
 else:14.1049	prefix accepted: 
 let:13.698	prefix accepted: 
 ||:13.4842	prefix accepted: 
 (:13.4287	prefix accepted: 
 ##:13.1654	prefix accepted: 
 #(:13.0703	prefix accepted: 
 case:12.811	prefix accepted: 
 than:12.5973	prefix accepted: th
 =>:12.4329	prefix accepted: 
 |:12.3782	prefix accepted: 
 *:12.3659	prefix accepted: 
 Then:12.1308	prefix accepted: 
 if:12.1241	prefix accepted: 
 the:12.0894
 {:12.0518	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:20.8716
 ((:17.7158	prefix accepted: (
 :17.105
 case:16.3262

:16.1337
 let:15.7072
 if:15.5891
 match:15.0484	prefix accepted: ma
 ([:14.7551	prefix accepted: (
  :14.2916
 #:13.7454	prefix accepted: 
 List:13.1851
 begin:12.839	prefix accepted: 
(:12.4707
 {:12.4473	prefix accepted: 
 remove:12.2287	prefix accepted: 
 songs:12.0907
 (*:11.6581	prefix accepted: (
    :11.6198
 ({:11.5399	prefix accepted: (
 get:11.1688

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "playlist" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
List:18.7048
 List:14.9121
song:13.772
filter:13.5905	rejected

:12.6927
remove:11.9961	rejected
get:11.977
 (:11.9594
play:11.8311
if:11.7542
 songs:11.5019
Play:11.1279	rejected
#:11.039	rejected
 #:10.96	prefix accepted: 
 :10.96
Filter:10.8404	rejected
 filter:10.686	prefix accepted: 
 [:10.5584
list:10.4178	prefix accepted:l
((:10.2037	prefix accepted:(
 remove:9.87353	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".length" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:21.1039
.(:14.56	prefix accepted:.
_:13.5377	rejected
:::11.6634	rejected
.@:11.5334	prefix accepted:.
filter:11.2356	rejected
/:11.1053	rejected
Filter:10.9979	rejected
(:10.6656	rejected
 filter:10.6335	rejected
@:10.616	rejected
.<:10.5653	prefix accepted:.
.[:9.97107	prefix accepted:.
 @:9.90056	rejected
::9.8663	rejected
2:9.84272	rejected
..:9.4195	prefix accepted:.
#:9.33373	rejected
s:9.32762	rejected
Util:9.27715	rejected
\:9.21831	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "filter" | "fold_left" | "fold_right" | "init" | "length" | "rev" | "tl"
root ::= completions

Top 20 Logits:
filter:23.8798
remove:17.7826	prefix accepted:re
rev:16.083
fold:15.5137
tl:15.0254
init:14.8041
delete:14.1516	rejected
Filter:14.0387	rejected
diff:13.9576	rejected
fil:13.7682
cons:13.1634
reverse:13.1539	prefix accepted:rev
sub:12.6603	rejected
tail:12.27	prefix accepted:t
ex:12.2552	rejected
drop:12.2536	rejected
list:12.0745	prefix accepted:l
List:11.9039	rejected
length:11.7974
re:17.7826
get:11.6688	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.filter>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: (((? -> Bool), [?]) -> [?])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList");
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Unknown TypeHole), Bool));
                   (List (Unknown TypeHole))]),
              (List (Unknown TypeHole))))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter
Nature of error: Expecting type PlayList but got inconsistent type (((? -> Bool), [?]) -> [?])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: List.filter
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (((? -> Bool), [?]) -> [?])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Arrow (
   (Prod [(Arrow ((Unknown TypeHole), Bool)); (List (Unknown TypeHole))]),
   (List (Unknown TypeHole))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: List.filter
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Arrow (
   (Prod [(Arrow ((Unknown TypeHole), Bool)); (List (Unknown TypeHole))]),
   (List (Unknown TypeHole))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:20.5799
((:19.1128	prefix accepted:(
 (:15.6269
(_:14.7817	prefix accepted:(
(\:13.8938	prefix accepted:(
 ((:13.83	prefix accepted: (
<:12.5316	rejected
({:12.3581	prefix accepted:(
(@:12.1865	prefix accepted:(
(?:12.1113	prefix accepted:(
([:12.0674	prefix accepted:(
(|:12.0055	prefix accepted:(
(!:11.6974	prefix accepted:(
_:11.2697	rejected
i:11.2128	rejected
{:11.1595	rejected

:10.9394
():10.9179	prefix accepted:(
(():10.8647	prefix accepted:(
($:10.7474	prefix accepted:(
[:10.5319	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod playlist songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "String.starts_with" | "bool_of_string" | "case " | "fun " | "if " | "is_finite" | "is_infinite" | "is_nan" | "let " | "type "
root ::= new-tokens

Top 20 Logits:
fun:18.4621
 fun:16.6236
id:13.2808	prefix accepted:i

:12.6608
 (:12.0676
func:11.53	prefix accepted:fun
song:11.3941	rejected
f:10.6384
fn:10.5758	prefix accepted:f
 :10.4733
not:10.3073	rejected
x:10.2715	rejected
a:9.9282	rejected
lambda:9.92418	prefix accepted:l
s:9.87224	rejected
function:9.57262	prefix accepted:fun
 id:9.33653	prefix accepted: i
i:13.2808
 ((:9.14062	prefix accepted: (
get:9.01284	rejected
Fun:8.93587	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  fun ? ->
 ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)  
Error in term:
  List.filter(fun ? ->
 ?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 id:18.2933
 x:15.9696
 s:14.9714
 song:14.8173
 sid:14.6739
 i:14.4835
 other:13.8319
 current:13.2533
 (:12.9927
 a:12.8682
 el:12.679
(:12.5031
 cur:12.181
 elem:12.1413
 ids:12.078
 curr:12.0123
 idx:11.865
 item:11.8606
 e:11.7451
 it:11.6822
 element:11.5522

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)  
Error in term:
  List.filter(fun id ->
 ?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:19.9435
->:15.6191
2:14.1886
1:13.9034
_:13.6425
 :13.6295
':13.1284	rejected
 =>:11.7364	prefix accepted: 
 -:11.2777
0:11.1105
::10.9813
  :10.8367
To:10.4777
d:10.3163
 ::10.2787
 =:10.179	prefix accepted: 
x:10.0659
 <-:9.90891	prefix accepted: 
In:9.90203
 ~:9.77023	prefix accepted: 
 -->:9.75406	prefix accepted: -

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id ->

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id ->
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)  
Error in term:
  List.filter(fun id ->
 ?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id state songs songId action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt state string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "playlist" | "sin" | "songId" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 id:17.9024
 not:16.0008	prefix accepted: n
 song:13.464
 :12.522
 if:12.1604
 (:12.1194
id:11.6534
 !:11.2557
 Song:10.4298	prefix accepted: S
 fun:10.0003
song:9.98651
 false:9.57056

:9.45397
 true:9.34459
 return:9.21625	prefix accepted: 
 ~:9.19989	prefix accepted: 
  :9.13859
 Not:9.11629	prefix accepted: No
 Id:9.03336	prefix accepted: 
 i:8.81659
not:8.78842	prefix accepted:n

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> ?)  
Error in term:
  List.filter(fun id ->
 id)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id state songs songId action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt state string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 !=:20.9479
 <>:18.2418	prefix accepted: <
 ==:16.3646
 !==:15.2309	prefix accepted: !=
!=:14.7438
 /:14.4259
 <:18.2418
 !:13.9941
 >:13.3666
 =:13.3364
 :13.1259
 $:12.6919
 ~:12.612	prefix accepted: 
<>:12.6016	prefix accepted:<
!:12.1122
==:12.0704
 >=:11.7054
 ?:11.6753	prefix accepted: 
 <=:11.5243
 ^:11.4857	prefix accepted: 
 ===:11.4007	prefix accepted: ==

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id !=

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id !=
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >!=<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Inequality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id != ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)  
Error in term:
  List.filter(fun id ->
 id != ?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Integer Inequality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id != ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)  
Error in term:
  List.filter(fun id ->
 id != ?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id != ?
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)  
Error in term:
  List.filter(fun id ->
 id != ?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: !=
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: !=
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id state songs songId action playlist update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt state string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= completions | new-tokens

Top 20 Logits:
 song:20.5444
song:13.2742
 :12.8354
 id:12.1741
 Song:10.9403	prefix accepted: 
 (:10.9079
=:10.3174	rejected
$:10.2494	rejected
 Id:10.1742	prefix accepted: 
?:10.0716	rejected
+:9.82856	rejected
 get:9.77347	prefix accepted: 
 s:9.73412
 $:9.5418	prefix accepted: 
&:9.53666	rejected
<:9.4906	rejected
 songs:9.24895	prefix accepted: song
@:9.15849	rejected
 Int:9.00734	prefix accepted: 
 son:8.98316
 -:8.95204

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id !=
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Variable song is not bound  
Error in term:
  fun id ->
 id != song
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)  
Error in term:
  List.filter(fun id ->
 id != song)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:23.2172
I:13.4627
id:13.3379	rejected
If:12.2913	prefix accepted:I
 Id:11.8155	rejected
In:11.4545	prefix accepted:I
_:11.4336	rejected
Ids:11.007	prefix accepted:Id
,:10.7964	rejected
 id:10.523	rejected
Is:10.4516	prefix accepted:I
ID:10.3865	prefix accepted:I
It:10.2755	prefix accepted:I
List:10.0736	rejected
By:10.0166	rejected
?:9.97711	rejected
Of:9.94348	rejected
Dir:9.92478	rejected
Name:9.67814	rejected
.:9.67708	rejected
To:9.40809	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  fun id ->
 id != songId
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (? -> Bool)  
Error in term:
  List.filter(fun id ->
 id != songId)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Unknown Internal), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "," | "-" | "/"
root ::= new-tokens

Top 20 Logits:
,:19.2996
 ,:17.1907
)(:12.172	prefix accepted:)
):12.172
),:11.9221	prefix accepted:)
 end:11.6087	prefix accepted: 
 :11.6087
 in:10.8772	prefix accepted: 
 ):10.5981
 ?:9.50429	prefix accepted: 
 ||:9.49545	prefix accepted: 
 songs:9.48942	prefix accepted: 
,(:9.41437	prefix accepted:,
(),:9.39405	rejected
 &&:9.35207	prefix accepted: 
 ->:9.26441	prefix accepted: -
  :9.12268
 (*:9.00951	prefix accepted: 
;:8.90782	rejected
 _,:8.6837	prefix accepted: 
 @:8.65107	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((? -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, ?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((? -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, ?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, ?)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt state string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Unknown Internal), Bool)); (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "playlist" | "sin" | "songId" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:19.0052
 get:16.2581
 song:13.1052
song:13.0898
 :13.0431
 List:12.3668
 (:11.7371
 [:11.3402
get:11.2506
 play:10.9871
 Songs:10.7222	prefix accepted: S
 Song:9.90845	prefix accepted: S
  :9.76007
 list:9.65709	prefix accepted: l
 Play:9.64153

:9.26288
 ):8.97303	prefix accepted: 
 in:8.82896
 Get:8.76204	prefix accepted: 
 plays:8.712	prefix accepted: play
 tracks:8.7111	prefix accepted: tr

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Unknown Internal), Bool)); (List (Var "Id"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Unknown Internal), Bool)); (List (Var "Id"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi playlist sin songId songs sqrt state string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
),:21.121	prefix accepted:)
):21.121
 ),:15.9633	prefix accepted: )
 ):15.9633
)):12.9211	prefix accepted:)
),(:12.0456	prefix accepted:)
)),:11.5073	prefix accepted:)
);:10.8469	prefix accepted:)
).:10.4113	prefix accepted:)
 :10.3406
)::10.2463	prefix accepted:)
)]:10.2353	prefix accepted:)
 @:10.0617	prefix accepted: 
,:9.94811	rejected
],:9.74392	rejected
))):9.50055	prefix accepted:)
),\:9.41958	prefix accepted:)
));:8.93891	prefix accepted:)
::8.81279	rejected
 ::8.81047	prefix accepted: 
)(:8.79012	prefix accepted:)
Rejected the highest logit candidate ), with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.2555	prefix accepted: 
 @:13.5187
 :18.2555

:11.6771
 ::10.6769	prefix accepted: 
  :10.5195
 ):10.1285
 :::9.62978	prefix accepted: 
 ++:9.49782	prefix accepted: 
@:9.39696
 as:9.28369	prefix accepted: 
 Play:9.20067	prefix accepted: 
 [],:9.15804	prefix accepted: 
 #:8.91031	prefix accepted: 
 [:8.82487	prefix accepted: 
 (*:8.53658	prefix accepted: 
   :8.53627
 List:8.48499	prefix accepted: 
    :8.48121
 ),:8.46447	prefix accepted: )
 |:8.46187	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs) 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs) 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.3575	prefix accepted: 

:17.4871
 @:15.9362
 ):14.1783
 #:13.8396	prefix accepted: 
 as:12.8966	prefix accepted: 
 ::12.8624	prefix accepted: 
,":12.7301	rejected
 (*:12.4876	prefix accepted: 
 ),:12.3476	prefix accepted: )
 :::11.9388	prefix accepted: 
 *:11.843	prefix accepted: 
	:11.7197	rejected
 [:11.6703	prefix accepted: 
 (:11.4624	prefix accepted: 
 ++:11.2886	prefix accepted: 
 List:11.2117	prefix accepted: 
 <:11.1944	prefix accepted: 
 (@:11.1337	prefix accepted: 
0:11.1273	rejected
 [],:11.0858	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)  

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)  
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs) 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.352	prefix accepted: 

:17.5611
 @:15.7621
 ):14.3304
 #:14.1004	prefix accepted: 
,":13.2281	rejected
 ::13.0322	prefix accepted: 
 as:12.5964	prefix accepted: 
 (*:12.5482	prefix accepted: 
 :::12.2347	prefix accepted: 
 *:12.1392	prefix accepted: 
 ),:12.0407	prefix accepted: )
 [:11.783	prefix accepted: 
	:11.7789	rejected
 (:11.7227	prefix accepted: 
 <:11.3277	prefix accepted: 
 List:11.2275	prefix accepted: 
 [],:11.2275	prefix accepted: 
 //:11.1179	prefix accepted: 
 (@:11.107	prefix accepted: 
 state:11.0673	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)   

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)   
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)  
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.6322	prefix accepted: 

:17.6085
 @:15.093
 ):14.9572
 #:14.9317	prefix accepted: 
,":13.0428	rejected
 (*:13.0384	prefix accepted: 
 ::12.9097	prefix accepted: 
 :::12.7253	prefix accepted: 
 ),:12.4775	prefix accepted: )
 *:12.237	prefix accepted: 
 (:11.9422	prefix accepted: 
 ;:11.9267	prefix accepted: 
	:11.8551	rejected
 state:11.7998	prefix accepted: 
 <:11.7968	prefix accepted: 
 //:11.7128	prefix accepted: 
 [:11.5911	prefix accepted: 
 &&:11.5263	prefix accepted: 
 &:11.4847	prefix accepted: 
 /*:11.3449	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)    

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)    
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.7597	prefix accepted: 

:17.1519
 #:15.1946	prefix accepted: 
 ):15.1434
 @:14.8902
 (*:13.1724	prefix accepted: 
 ::13.053	prefix accepted: 
 ),:12.8842	prefix accepted: )
 :::12.6266	prefix accepted: 
 *:12.4637	prefix accepted: 
 (:12.4602	prefix accepted: 
 <:12.3723	prefix accepted: 
 ;:12.2102	prefix accepted: 
,":12.0358	rejected
 [:11.9494	prefix accepted: 
 &:11.5668	prefix accepted: 
	:11.5129	rejected
 &&:11.4842	prefix accepted: 
 get:11.4419	prefix accepted: 
 //:11.432	prefix accepted: 
 (@:11.2847	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)    
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.6081	prefix accepted: 

:15.9559
 ):15.3702
 @:14.8076
 #:14.8032	prefix accepted: 
 ::13.2597	prefix accepted: 
 ),:13.2075	prefix accepted: )
 (*:12.6839	prefix accepted: 
 <:12.6386	prefix accepted: 
 (:12.3984	prefix accepted: 
 ;:11.9244	prefix accepted: 
 *:11.8995	prefix accepted: 
 [:11.7609	prefix accepted: 
 +:11.6964	prefix accepted: 
 :::11.5388	prefix accepted: 
 &:11.143	prefix accepted: 
 &&:11.1388	prefix accepted: 
 /*:11.0975	prefix accepted: 
	:11.0848	rejected
 --:11.0523	prefix accepted: 
 ():11.0472	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)      

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)      
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.3327	prefix accepted: 
 ):15.3494

:15.1088
 :20.3327
 #:14.0037	prefix accepted: 
 @:13.7019
  :13.077
 ::12.9645	prefix accepted: 
 ),:12.7055	prefix accepted: )
 (:12.3791	prefix accepted: 
 <:12.2018	prefix accepted: 
 (*:11.9869	prefix accepted: 
 ;:11.6733	prefix accepted: 
 *:11.3207	prefix accepted: 
 [:11.2263	prefix accepted: 
 +:11.2086	prefix accepted: 
 /*:11.1162	prefix accepted: 
 .:11.109	prefix accepted: 
 ():11.0135	prefix accepted: 
 song:10.9261	prefix accepted: 
	:10.8658	rejected
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)      
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.9843	prefix accepted: 
 :18.9843
  :15.6296
 ):13.9385

:13.3483
,:12.9672	rejected
   :12.8703
    :12.5178
 #:12.1051	prefix accepted: 
 @:11.7765
      :11.7595
 ::11.6236	prefix accepted: 
                :11.3835
       :11.3819
     :11.3654
 (:11.3559	prefix accepted: 
        :10.9804
 ),:10.7731	prefix accepted: )
         :10.7359
 <:10.4598	prefix accepted: 
 ;:10.435	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)        

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)        
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.632	prefix accepted: 
 :17.632
  :14.9265
,:14.8471	rejected
 ):12.6162
   :12.5164

:12.3023
    :12.252
      :11.5079
     :11.1273
       :11.0955
                :10.9934
 #:10.8927	prefix accepted: 
        :10.5932
 @:10.457
 (:10.4146	prefix accepted: 
 ::10.3939	prefix accepted: 
         :10.3623
#,:9.9986	rejected
          :9.85214
	:9.67723	rejected
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)         

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)         
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)        
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.2878	prefix accepted: 
 :17.2878
,:14.8752	rejected
  :14.8217
   :13.7708
    :12.3221
 ):12.2986

:12.2159
      :11.6047
     :11.2207
       :11.1819
                :11.1043
 #:10.9062	prefix accepted: 
        :10.6448
         :10.42
 (:10.3819	prefix accepted: 
 @:10.3026
 ::10.1901	prefix accepted: 
          :9.91197
	:9.90189	rejected
#,:9.84481	rejected
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)          

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)          
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)         
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.1183	prefix accepted: 
 :17.1183
  :14.8624
,:14.6877	rejected
   :13.8715
    :12.4679

:12.1294
 ):12.1157
      :11.767
     :11.3791
       :11.3501
                :11.249
 #:10.9193	prefix accepted: 
        :10.7708
         :10.5251
 (:10.4512	prefix accepted: 
 @:10.2302
 ::10.2027	prefix accepted: 
          :10.0853
	:10.0827	rejected
           :10.0192
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)           

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)           
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)          
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.2732	prefix accepted: 
 :17.2732
  :15.0806
,:14.3047	rejected
   :14.1053
    :12.7439

:12.1292
 ):12.0968
      :12.0288
       :11.6811
     :11.6525
                :11.4684
 #:11.329	prefix accepted: 
        :11.0429
         :10.775
 (:10.7549	prefix accepted: 
          :10.4234
 ::10.4204	prefix accepted: 
           :10.3478
 @:10.3379
	:10.1598	rejected
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)            

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)            
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.8889	prefix accepted: 
 :17.8889
  :15.3991
   :14.2668
,:13.1462	rejected
    :12.9213
 ):12.5184

:12.3852
      :12.2132
 #:12.1911	prefix accepted: 
       :11.941
     :11.8247
                :11.6834
 (:11.3362	prefix accepted: 
        :11.3107
         :11.0259
 @:10.9145
 ::10.8954	prefix accepted: 
          :10.7041
           :10.5804
            :10.3806
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)             

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)             
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)            
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.4419	prefix accepted: 
 :18.4419
  :14.8801
   :13.5349
 ):13.0973
 #:12.8169	prefix accepted: 

:12.7867
    :12.1576
,:11.8393	rejected
 (:11.807	prefix accepted: 
      :11.4646
 @:11.3321
 ::11.2834	prefix accepted: 
       :11.191
     :11.1261
                :11.0316
        :10.645
 _,:10.5373	prefix accepted: 
 ),:10.4789	prefix accepted: )
         :10.3489
 ;:10.2686	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)              

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)              
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)             
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.7323	prefix accepted: 
 :18.7323
  :13.9057
 ):13.5165
 #:13.0674	prefix accepted: 

:13.0238
   :12.5222
 (:12.0768	prefix accepted: 
 @:11.4343
 ::11.4232	prefix accepted: 
    :11.1551
,:11.1491	rejected
 ),:10.8328	prefix accepted: )
 _,:10.8266	prefix accepted: 
 end:10.7061	prefix accepted: 
      :10.479
 ;:10.4722	prefix accepted: 
 |:10.4662	prefix accepted: 
	:10.2676	rejected
 .:10.2405	prefix accepted: 
 ():10.2195	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)               

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)               
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)              
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.5628	prefix accepted: 
 :18.5628
  :14.0697
 ):13.4403
 #:12.821	prefix accepted: 

:12.7693
   :12.6356
 (:11.9035	prefix accepted: 
,:11.3992	rejected
    :11.3086
 ::11.203	prefix accepted: 
 @:11.1303
 end:10.7422	prefix accepted: 
 ),:10.7365	prefix accepted: )
 _,:10.63	prefix accepted: 
      :10.6262
     :10.329
       :10.3275
 ;:10.3175	prefix accepted: 
                :10.2981
 |:10.289	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)               
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.9365	prefix accepted: 
 :17.9365
  :14.9557
   :13.5516
 ):12.8464
,:12.5849	rejected
    :12.3121

:12.0933
 #:12.0921	prefix accepted: 
      :11.6152
 (:11.2745	prefix accepted: 
       :11.2588
     :11.1996
                :11.1824
        :10.8533
 ::10.7141	prefix accepted: 
         :10.4751
 @:10.4645
 end:10.363	prefix accepted: 
 ),:10.174	prefix accepted: )
          :10.1189
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.2471	prefix accepted: 
 :17.2471
  :14.9877
   :13.7727
,:13.7185	rejected
    :12.6334
 ):12.1682
      :11.9233

:11.6513
       :11.5504
     :11.4669
                :11.4268
 #:11.331	prefix accepted: 
        :11.1598
         :10.7669
 (:10.5678	prefix accepted: 
          :10.4374
 ::10.3025	prefix accepted: 
           :10.2917
            :10.2045
 end:9.96678	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                  

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                  
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.9134
 ,:16.8972	prefix accepted: 
  :14.9002
,:13.9429	rejected
   :13.7653
    :12.6481
      :11.9329
 ):11.7795

:11.573
       :11.5588
     :11.4745
                :11.4436
        :11.2039
 #:11.0103	prefix accepted: 
         :10.8063
          :10.5066
           :10.3546
            :10.2701
 ::10.2064	prefix accepted: 
 (:10.1788	prefix accepted: 
 end:9.85744	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                   

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                   
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                  
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.9537
 ,:16.8645	prefix accepted: 
  :14.9344
   :13.8366
,:13.8289	rejected
    :12.7153
      :12.0305
       :11.6702

:11.6533
 ):11.6074
                :11.5745
     :11.5547
        :11.3464
 #:11.0618	prefix accepted: 
         :10.948
          :10.6899
           :10.4998
            :10.4409
 ::10.2883	prefix accepted: 
 (:10.1046	prefix accepted: 
 end:9.98625	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                    

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                    
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.079
 ,:16.9858	prefix accepted: 
  :14.9998
   :13.9352
,:13.6014	rejected
    :12.8053
      :12.1561
       :11.8194

:11.7743
                :11.7316
     :11.6679
 ):11.5078
        :11.4985
 #:11.3059	prefix accepted: 
         :11.1054
          :10.8938
           :10.6635
            :10.613
 ::10.3853	prefix accepted: 
 (:10.2049	prefix accepted: 
 end:10.2004	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                    
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.2254
 ,:17.1702	prefix accepted: 
  :15.0843
   :14.0485
,:13.3842	rejected
    :12.9083
      :12.27
       :11.9661

:11.8794
                :11.8699
     :11.789
 #:11.6527	prefix accepted: 
        :11.6132
 ):11.4411
         :11.2217
          :11.0508
           :10.8088
            :10.7444
 ::10.4426	prefix accepted: 
 end:10.4214	prefix accepted: 
 (:10.4015	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                      

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                      
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.3435
 ,:17.3191	prefix accepted: 
  :15.162
   :14.145
,:13.2314	rejected
    :13.0063
      :12.3581
       :12.0768
                :11.9463

:11.9455
 #:11.9194	prefix accepted: 
     :11.8891
        :11.6821
 ):11.4177
         :11.2688
          :11.1178
           :10.9033
            :10.8274
 (:10.6013	prefix accepted: 
 end:10.5655	prefix accepted: 
 ::10.44	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                      
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.3789
 ,:17.3419	prefix accepted: 
  :15.1308
   :14.1239
,:13.1699	rejected
    :12.998
      :12.3383
       :12.0604
 #:11.9517	prefix accepted: 

:11.9334
     :11.8752
                :11.8519
        :11.6364
 ):11.3767
         :11.1854
          :11.0225
           :10.8565
            :10.778
 (:10.6591	prefix accepted: 
 end:10.6412	prefix accepted: 
 ::10.42	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                         

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                         
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:19.826	prefix accepted: 

:16.2793
 ):14.748
 #:13.6551	prefix accepted: 
 @:13.2839
 (:13.24	prefix accepted: 
	:13.0231	rejected
​:12.6643	rejected
 end:11.987	prefix accepted: 
 ),:11.8518	prefix accepted: )
 _,:11.8394	prefix accepted: 
 \:11.6994	prefix accepted: 
 ;:11.5517	prefix accepted: 
 ():11.4688	prefix accepted: 
 ::11.4441	prefix accepted: 
,":11.2068	rejected
 .:11.2061	prefix accepted: 
 songs:11.1643	prefix accepted: 
 [:10.9222	prefix accepted: 
)):10.9105	prefix accepted:)
 *:10.9019	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                          

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                          
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                         
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:19.0172	prefix accepted: 

:13.7811
 :19.0172
  :12.9681
 #:12.3885	prefix accepted: 
   :12.3284
 (:12.2993	prefix accepted: 
 ):12.2535
 @:12.0493
​:11.49	rejected
    :11.1179
 _,:11.0917	prefix accepted: 
 ::10.8784	prefix accepted: 
 ():10.8434	prefix accepted: 
	:10.8207	rejected
 end:10.6948	prefix accepted: 
 .:10.5682	prefix accepted: 
 ),:10.563	prefix accepted: )
,:10.4617	rejected
 \:10.3147	prefix accepted: 
 |:10.2979	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                           

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                           
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                          
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.7378	prefix accepted: 
 :17.7378
  :15.2593
   :15.0343
    :13.8134
      :12.6606

:12.5331
     :12.2226
       :12.0922
,:12.0317	rejected
        :11.8873
                :11.6768
         :11.2527
 ):11.2323
 (:11.2224	prefix accepted: 
 #:11.07	prefix accepted: 
          :11.001
            :10.8638
​:10.8122	rejected
           :10.7581
 @:10.2944
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                            

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                            
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.3192	prefix accepted: 
 :18.3192

:13.2154
  :13.2144
   :12.8535
 ):12.1801
 (:11.8762	prefix accepted: 
​:11.7403	rejected
 #:11.7387	prefix accepted: 
    :11.6182
 ::10.8	prefix accepted: 
 _,:10.6083	prefix accepted: 
      :10.564
 @:10.5354
 ():10.5217	prefix accepted: 
 ),:10.4978	prefix accepted: )
     :10.2625
 \:10.2579	prefix accepted: 
 ;:10.1972	prefix accepted: 
       :10.1558
 .:10.125	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                             

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                             
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                            
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.0727	prefix accepted: 
 :18.0727
  :13.5373
   :13.1558

:12.8461
 ):12.0756
    :11.867
 (:11.5981	prefix accepted: 
 #:11.4461	prefix accepted: 
​:11.3122	rejected
      :10.8459
 ::10.692	prefix accepted: 
     :10.5164
 ),:10.4263	prefix accepted: )
       :10.4227
 ():10.3825	prefix accepted: 
 _,:10.2951	prefix accepted: 
        :10.1578
 @:10.1435
 ;:10.1023	prefix accepted: 
 \:9.98854	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                              

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                              
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                             
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.5382
 ,:17.0733	prefix accepted: 
  :14.63
   :14.4478
    :13.1577
      :12.1345
     :11.7134

:11.681
       :11.6289
,:11.5493	rejected
        :11.2391
 ):11.1247
                :11.0089
         :10.7582
 (:10.5915	prefix accepted: 
          :10.5198
            :10.3774
           :10.3331
 #:10.2902	prefix accepted: 
 ::9.9649	prefix accepted: 
​:9.96256	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                               

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                               
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                              
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.0004
 ,:16.1231	prefix accepted: 
  :14.1128
   :13.9959
,:13.087	rejected
    :12.7395
      :11.6987
     :11.3343

:11.1403
       :11.1264
        :10.6789
                :10.4814
 ):10.2592
         :10.1981
          :10.0555
           :9.9226
            :9.86757
 (:9.71703	prefix accepted: 
 ::9.36883	prefix accepted: 
 #:9.22961	prefix accepted: 
              :9.20524

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                               
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.7607
 ,:15.7659	prefix accepted: 
  :13.8989
   :13.7669
,:13.2361	rejected
    :12.4837
      :11.457
     :11.1183

:11.0376
       :10.8755
        :10.4041
                :10.2916
 ):10.0302
         :9.94359
          :9.83934
           :9.72375
            :9.66532
 (:9.395	prefix accepted: 
 ::9.27954	prefix accepted: 
song:9.19262	rejected
              :9.06611

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.6552
 ,:15.6972	prefix accepted: 
  :13.8639
   :13.7502
,:13.1669	rejected
    :12.4164
      :11.4504
     :11.0776

:11.0401
       :10.8879
        :10.3848
                :10.3255
 ):10.0532
         :9.9493
          :9.87297
           :9.75488
            :9.70078
 ::9.35367	prefix accepted: 
 (:9.30506	prefix accepted: 
song:9.29967	rejected
              :9.13177

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                  

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                  
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.6781
 ,:15.874	prefix accepted: 
  :14.0202
   :13.8816
,:13.2239	rejected
    :12.4765
      :11.5986
     :11.1397

:11.0788
       :11.0376
        :10.4963
                :10.4601
 ):10.1538
         :10.0864
          :10.0449
           :9.91237
            :9.80568
song:9.51623	rejected
 (:9.47046	prefix accepted: 
 ::9.35571	prefix accepted: 
              :9.29823

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                   

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                   
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                  
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :16.8338
 ,:16.1695	prefix accepted: 
  :14.5002
   :14.207
,:12.9871	rejected
    :12.7416
      :11.9017
     :11.3474
       :11.3021

:11.1566
                :10.7286
        :10.7039
          :10.2956
         :10.2882
 ):10.2509
           :10.1898
            :10.0468
song:10.0383	rejected
 (:9.92748	prefix accepted: 
              :9.59967
 #:9.43701	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                    

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                    
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 :17.021
 ,:16.4623	prefix accepted: 
  :14.6863
   :14.4586
    :13.0617
,:12.3589	rejected
      :12.2236
     :11.6592
       :11.6154

:11.2147
                :11.0719
        :11.0045
          :10.5925
         :10.562
           :10.496
 ):10.4133
            :10.3691
 (:10.2164	prefix accepted: 
song:10.1264	rejected
              :9.86086
             :9.66873

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (songs, Playing(songId) )
      else (songs, NoSongSelected)
    | PauseCurrentSong => 
      case get_state(playlist) 
      | Playing(songId) => (get_songs(playlist) , PausedOn(songId) )
      | _ => playlist
      end
    | RemoveSong(songId) => 
      let songs, state = playlist in
      if List.contains(fun id -> id == songId, songs)
      then (List.filter(fun id -> id != songId, songs)                                    
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Unknown TypeHole))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], songId: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  List.filter(fun id ->
 id != songId, songs)
Nature of error: Expecting type PlayList but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Unknown TypeHole))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.2608	prefix accepted: 

:15.0599
 ):14.3586
	:13.0051	rejected
 (:12.977	prefix accepted: 
 songs:12.8277	prefix accepted: 
 @:12.8009
 #:12.5675	prefix accepted: 
 ),:12.2116	prefix accepted: )
​:12.0556	rejected
 ():11.6189	prefix accepted: 
 _,:11.5808	prefix accepted: 
 .:11.2588	prefix accepted: 
 [:11.1332	prefix accepted: 
 \:11.1055	prefix accepted: 
 play:11.0366	prefix accepted: 
 song:11	prefix accepted: 
,":10.8232	rejected
 ;:10.7839	prefix accepted: 
 state:10.5879	prefix accepted: 
 end:10.4978	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf
