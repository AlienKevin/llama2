
================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Model -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Model -> [Todo])
  LSP: Convex: Target types: (Model -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Model.get_todo_list ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_todo_list case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_todo_list" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:17.3296
 fun:14.1247
 :13.7321
 Model:12.7611
 (:12.2819
 model:12.0917
 {:10.9915
  :10.5888
 List:10.5797
    :10.2401
                :9.90856
 #:9.80518
   :9.61987
 let:9.34189
fun:9.26279
 (*:9.21952
 function:9.02298
 <:9.01626
 cur:8.98665
        :8.72945
 ":8.71008

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Model -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Model -> [Todo])
  LSP: Convex: Target types: (Model -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Model.get_todo_list ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_todo_list case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_todo_list" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
   :19.6921
 :19.3538
fun:17.007
  :14.3525
let:14.1065
       :13.5955
 fun:13.5161
     :13.353
	:13.2341
 let:12.3541
func:12.1815
#:12.1691
    :11.8936
(:11.5398

:11.2631
{:10.9011
model:10.7587
lambda:10.7089
fn:10.4713
(*:10.4522
match:10.3573

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
   

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
   
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Model -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Model -> [Todo])
  LSP: Convex: Target types: (Model -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Model.get_todo_list ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_todo_list case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_todo_list" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:17.388
 let:15.2213
 model:13.3417
 (:12.8491
 Model:12.833
 #:12.6335
 List:11.7223
 if:10.9461
 update:10.9414
 (*:10.909
 get:10.5604
 String:10.3899
 string:10.2797
 @:10.2445
 {:10.0926
 f:10.0523
 lambda:10.0468
 match:9.88958
 m:9.74924
 func:9.62082
 term:9.51397

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 model:16.8266
 (:16.3917
 buffer:15.8932
 m:14.3151
 state:12.7739
 todo:12.7358
 string:12.5065
 buf:12.3505
 {:12.1891
 x:12.0462
 text:11.8754
 ((:11.7622
 _:11.742
 b:11.6702
 input:11.5084
 s:11.4625
 old:11.3989
 current:11.2697
 [:11.1433
 description:10.9703
 desc:10.9055

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: model
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:16.8812
,:13.2092
 buffer:12.7081
 todo:12.1394
_:10.8621
->:10.7047
 =>:10.5483
 =:9.97284
 state:9.93265
 todos:9.88472
 x:9.36133
 :9.21422
 ~:9.1791
::9.10437

:8.9819
 t:8.94807
 (:8.66033
 desc:8.66024
@:8.65722
 current:8.55896
 _:8.54286

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:17.0804
 :14.0139
 List:14.0032
 (:13.9195
 model:13.677
 (":13.2556
 [:12.4559
 let:12.412
 Model:11.9596
 [":11.7596
 String:11.7352
 ":11.5913
 case:11.5626
 if:11.4218
 [(:11.3623
  :11.3503
 Tod:11.1848
 ((:11.097
 {:11.0188
 #:11.009
    :10.9786

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
       :18.909
   :16.6471
     :14.7993
      :12.9576
           :12.8554
    :12.8387
        :12.5487
let:11.7095
if:11.309
	:11.2898
         :11.2679
 :11.21
#:11.1322
  :10.8508

:10.7039
               :10.3944
(:10.0021
case:9.96208
model:9.80525
Model:9.48171
match:9.3699

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
       

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
       
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 let:17.9121
 case:16.863
 if:15.9081
 match:15.8786
 List:15.2386
 (:14.8153
 #:14.0821
 model:13.7211
 Model:13.5777
 (":13.0862
 Tod:12.8636
 [:12.5829
 String:12.3534
 [(:12.1978
 todo:12.0563
 ((:12.0226
 ":11.9153
 [":11.6582
 {:11.5407
 var:11.4595
 val:11.4509

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddTodo" | "App" | "RemoveTodo" | "Reverse" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 buffer:14.0268
 (:13.9555
 description:13.0567
 new:12.9267
 todo:12.4578
 desc:12.3809
 text:11.7388
 string:11.3029
 buf:11.2802
 todos:11.1278
 current:11.0389
 old:10.9664
 input:10.8796
 model:10.6191
 b:10.6134
 term:10.4952
 list:10.3891
 get:10.2697
 next:9.99616
 Model:9.83505
 title:9.70787

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: ?, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:19.0289
,:18.8386
::14.8592
_:14.8219
 ::13.7901
':13.5541
_,:13.3312
',:12.8582
$:12.6199
=:12.2729
     :12.1076
      :11.8771
 $:11.8269
 ,:11.817
  :11.8077
ed:11.8009
        :11.5047
    :11.4722
@:11.2609
 :11.2345
1:11.2326

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer =

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer =
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 Model:16.9767
 String:14.0069
 model:13.9228
 get:12.9585
 (:12.7141

:12.274
 List:11.679
 ":11.6162
 f:11.3738
 string:11.2563
 :11.0029
 s:10.9413
 Buffer:10.9314
 buffer:10.3957
 "":10.3414
 term:9.89589
 @:9.79687
 if:9.73184
 #:9.57066
 {:9.47546
 Tu:9.47077

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Model"))))
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  Model
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model
LSP: Generating Completions for prefix: Model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".eq" | ".get_buffer" | ".get_todo_list" | ".init"
root ::= completions

Top 20 Logits:
.:22.3852
(:13.1684
.(:12.3582
_:11.8426
._:11.4428
 .:10.7888
 get:10.7758
().:10.1064
_.:10.0114
.@:9.76304
{:9.49965

:9.49903
Get:9.49642
:::9.4143
[:9.37882
():9.34992
/:9.31669
(":9.18933
$:9.13502
@:9.07902
,:9.07839

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "Model."))))
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  Model.
Nature of error: "Model." isn't a valid token
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: Model.
LSP: Generating Completions for prefix: Model.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "eq" | "get_buffer" | "get_todo_list" | "init"
root ::= completions

Top 20 Logits:
get:22.8379
buffer:16.6721
init:16.5341
to:13.497
Get:13.4081
set:13.185
 get:12.474
update:12.463
model:12.3987
buf:12.2043
map:12.0533
g:12.0204
apply:11.8007
extract:11.6189
add:11.6185
Buffer:11.347
t:11.1487
remove:11.0637
de:10.9342
eq:10.8354
f:10.7757

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get"))
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  Model.get
Nature of error: Variable Model.get is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get
LSP: Generating Completions for prefix: Model.get
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_buffer" | "_todo_list"
root ::= completions

Top 20 Logits:
_:23.5136
Buffer:14.9832
(:14.3981
buffer:13.0527
 buffer:11.3587
-:10.6141
__:10.5906
_(:10.2842
.:10.0865
ter:9.71673
():9.3671
\_:8.85873
B:8.73953
T:8.73485
buf:8.61077
Model:8.56501
(":8.49426
 Buffer:8.32897
<:8.00021
(&:7.93396
((:7.86938

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_"))
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  Model.get_
Nature of error: Variable Model.get_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_
LSP: Generating Completions for prefix: Model.get_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "buffer" | "todo_list"
root ::= completions

Top 20 Logits:
buffer:28.2958
t:18.6631
input:16.72
buf:16.1602
text:15.7069
buff:15.6778
Buffer:15.5498
description:15.1362
new:15.1317
bu:15.0594
value:14.9569
string:14.7236
current:14.5953
model:14.3048
name:14.3006
des:14.1564
tod:14.0584
data:14.0553
b:13.7794
button:13.6033
state:13.5393

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Model -> String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: Model.get_buffer
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Model -> String)
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model.get_buffer
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
(:21.9004
 model:15.9573
 (:14.786
():13.5497
 in:12.7834
([:12.551
((:12.3514
($:12.2938
(@:12.1894
(":12.1354
(*:11.3418
(&:11.1618
({:10.9847

:10.934
[:10.793
(_:10.6765
(!:10.6032
(%:10.2871
 {:10.1611
!(:10.0846
$:9.81888

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.init String.reverse String.transform case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.init" | "String.reverse" | "String.transform" | "case " | "if " | "let " | "model" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= completions | new-tokens

Top 20 Logits:
model:23.0942
buffer:14.2428
 model:12.7175
Model:12.5481
#:11.7291
m:11.7162
mode:11.7013
0:11.3861
x:11.2397
Buffer:11.2394
term:11.2341
mod:11.2039
(":11.0951
**:11.059
String:10.9956
string:10.8762
List:10.7987
f:10.7141
state:10.5146
[":10.5094
t:10.4792

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Model
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.init String.reverse String.transform case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):24.0837
),:19.3201
);:15.9842
,:14.984
.:14.5272
)::13.7024
 in:13.52
).:13.2801
)(:13.0897
)$:12.7081
)[:12.1888
[:12.0884
 ):11.7337
)|:11.1308
)":11.1186
)):11.1067
_:11.0272
()):11.0163
)?:11.0028
)^:10.9608
)!:10.89

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $== ++ ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: $== ++ ::
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: $== ++ ::
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | "++" | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:20.0219

:14.4418
 and:12.6163
 :11.8612
 |:11.513
in:10.6982
                :10.3082
  :10.0204
    :9.93132
 #:9.71984
      :9.62081
        :9.61443
     :9.50473
            :9.14155
         :9.0629
   :8.98222
 &&:8.93428
 (:8.62732
       :8.56378
             :8.44105
 trim:8.38297

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:18.8631
 :14.1825
    :12.6632
  :12.5229
        :11.6087
 #:11.1283
            :10.997
                :10.81
     :10.5272
      :10.437
   :10.3694
 (:10.283
         :10.1753
 Model:9.79618
          :9.58349
           :9.33054
       :9.30566
 let:9.17106
 {:9.12883
 model:9.04244
             :8.89937

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
       :19.1785
           :15.5091
        :13.8693
   :13.7254

:13.4726
	:12.57
         :11.8488
    :11.6505
      :11.6236
     :11.4997
               :11.3442
            :11.2509
#:11.0492
if:10.9005
let:10.7638
                :10.4555
          :10.4093
case:9.94431
 :9.7724
  :9.76564
             :9.38761

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
       

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
       
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 if:18.0995
 let:17.2648
 case:16.3327
 List:15.6843
 (:15.29
 match:15.2542
 #:14.7268
 model:13.8458
 Model:13.642
 [:13.1281
 Tod:13.0934
 (":13.0619
 String:12.8686
 ((:12.6419
 [(:12.4729
 buffer:12.3355
 [":11.9238
 ([:11.8226
 fun:11.8191
 todo:11.7089
 Cons:11.6451

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "Bool.eq" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "Model.eq" | "Model.get_buffer" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 string:16.0049
 String:15.4647
 buffer:14.6367
 !:13.3248
 not:13.2037
 (:12.5486
 is:11.8035
 "":11.5296
 List:11.2906
 length:10.6094
 $:10.2183
 model:10.0898
 :10.0283
 ":10.0057
 str:9.63373
 Buffer:9.62685
 Model:9.33273
 bool:9.25819
 text:9.24903
 buf:9.17849
 empty:8.87157

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: ALL errors:
Error in term:
  string
Nature of error: Variable string is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string
LSP: Generating Completions for prefix: string
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_compare" | "_concat" | "_length" | "_of_bool" | "_of_float" | "_of_int" | "_sub" | "_trim"
root ::= completions

Top 20 Logits:
_:21.2145
.:11.9566
Length:11.4921
Is:11.4633
(:11.2064
__:11.1266
 length:10.6793
cmp:10.6622
-:10.563
length:10.4512
?:10.3318
 !=:10.2711
 ==:9.84539
Equals:9.83288
(":9.83169
2:9.80966
$:9.73962
1:9.68049
 $:9.66746
 =:9.65546
Empty:9.62234

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: ALL errors:
Error in term:
  string_
Nature of error: Variable string_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_
LSP: Generating Completions for prefix: string_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "compare" | "concat" | "length" | "of_bool" | "of_float" | "of_int" | "sub" | "trim"
root ::= completions

Top 20 Logits:
length:23.5382
equals:17.7383
eq:17.3703
equal:17.3624
is:16.8784
trim:16.8489
empty:16.7012
compare:16.2908
contains:16.271
sub:15.9936
starts:15.7906
isEmpty:15.3245
size:15.2567
len:15.0706
null:14.9333
to:14.3838
ends:14.192
not:14.0636
match:14.0446
cmp:14.0355
matches:13.9199

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_length>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (String -> Int)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Arrow (String, Int))})))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: ALL errors:
Error in term:
  string_length
Nature of error: Expecting type Bool but got inconsistent type (String -> Int)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: string_length
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (String -> Int)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: string_length
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "then"
root ::= new-tokens

Top 20 Logits:
(:21.4387
($:15.4643
(":14.7142
 (:14.433
 buffer:14.3284
(!:12.9556
((:12.8902
_:12.2712
(@:12.2229
([:11.3098
$:11.3093
():11.1743
!(:11.1233
(_:10.9777
s:10.9113
 $:10.7073
("<:10.5575
(&:10.3653
("#:10.1137
$(:10.0611
($(:10.0385

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = Int})))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else in
  LSP: Info: ALL errors:
Error in term:
  string_length(?)
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = Int})))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else in
  LSP: Info: ALL errors:
Error in term:
  string_length(?)
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else in
  LSP: Info: ALL errors:
Error in term:
  string_length(?)
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 String
  LSP: Convex: Target types: String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer ~STRINGLIT~ ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer String.reverse String.transform buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "String.reverse" | "String.transform" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
buffer:21.0146
String:17.8041
string:16.9148
trim:15.9202
Model:15.8729
List:13.8194
model:13.7074
Buffer:13.2219
strip:13.0486
term:12.861
buf:12.7756
text:12.322
s:11.5313
Text:11.5253
t:11.524
remove:11.5172
str:11.4512
T:11.4329
Term:11.2785
Tr:11.1558
input:11.1296

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else in
  LSP: Info: ALL errors:
Error in term:
  string_length(buffer)
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: ++
  LSP: Concave: Infix: Lookahead types: String
  LSP: Concave: Infix: Lookahead: ++
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: ++
  LSP: Concave: Infix: Lookahead types: String
  LSP: Concave: Infix: Lookahead: ++
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 String
  LSP: Convex: Target types: String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer ~STRINGLIT~ ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer String.reverse String.transform buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "++"
root ::= new-tokens

Top 20 Logits:
):20.3305
 $:14.5919
)>:14.0958
)$:14.0619
$):12.4925
)=:11.8404
$:11.7722
 ):11.7342
)::11.6416
 >:11.3568
.$:11.2973
.:11.0921
)):11.0823
 ==:10.9815
),:10.7265
 <=:10.5689
_:10.4657
 =:10.3542
).:10.2981
 |:10.1471
)]:10.0448

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = Int})))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: ALL errors:
Error in term:
  string_length(buffer)
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: == != <= >= < >
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= new-tokens

Top 20 Logits:
 >:20.3933
 ==:19.0266
 <=:19.0239
 <:17.0006
 >=:16.3739
 $:16.305
 <>:16.2722
 !=:16.2236
 =:15.569
 ===:14.8919
 then:12.5742
 is:12.3226
 !==:11.9363
 :11.7549
 /:11.4416
 +:11.4094
 -:11.2911

:11.2324
 %:11.01
 *:10.9799
 ~:10.8594

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) >

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) >
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Greater Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Greater Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: >
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: >
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "." | "=" | "=."
new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= completions | new-tokens

Top 20 Logits:
 :20.7844
  :13.8116
 (:13.7456
0:13.3467
 string:12.1694
 zero:11.9705
 ":11.4919
 -:11.4737
 $:11.3666
 {:11.1848
 String:11.1466
 Int:10.9496
 "":10.8861
 max:10.8125

:10.4653
 length:10.3818
 (":10.1227
=:10.1112
?:9.89581
 ((:9.80129
 int:9.77748

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) >
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
0:27.0259
1:23.1663
2:20.7852
3:20.3606
5:19.2976
4:19.02
6:17.3573
7:16.8616
8:16.5125
9:16.3857

:13.0705
 (:11.466
 {:11.2419
 -:10.3538
	:10.3197
 #:10.2886
 //:9.73619
 description:9.53683
 *:9.39811
 !:9.26302
 ":8.95374

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 0
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 then:19.618
 &&:14.9517

:14.6805
 :13.4977
 ||:11.0526
 #:10.4629
 {:10.1856
then:10.1732
 in:9.78774
 and:9.31314
  :9.11512
.:9.06918
 Then:8.92706
 &:8.69474
 =:8.64972
 |:8.54898
 <:8.38996
 THEN:8.25092
 //:8.10755
    :8.01852
 (:7.93857

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:17.7626
 (:14.9218
 :13.7255
 [:13.6245
 List:13.3314
 [(:13.0584
 #:12.4048
 Tod:12.3526
 ([:12.0035
 ((:11.8422
 model:11.6727
 Model:11.655
 {:11.6473
  :11.5598
    :11.4554
            :11.3644
        :11.3461
 begin:10.9073
 buffer:10.7207
 (":10.6985
 todo:10.5243

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
           :23.1706
         :18.1617
            :17.4247
          :17.3817
               :16.88
       :16.7261
             :15.5851
        :15.2315
	:14.7185
                :13.8024
              :13.6214

:13.6138
     :13.246
   :13.0024
    :12.7757
#:12.6142
      :12.4333
  :11.6438
[:11.2425
 :11.1337
(*:10.0928

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
           

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
           
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 let:15.6222
 List:15.3012
 (:15.2239
 Model:14.3528
 Tod:14.0896
 model:13.5215
 #:13.4385
 [:13.339
 [(:13.0054
 case:12.6969
 ((:12.6209
 buffer:12.4677
 todo:12.4145
 String:12.1324
 ([:11.9414
 match:11.891
 if:11.3421
 (":11.2255
 list:11.2109
 @:10.7608
 t:10.6874

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddTodo" | "App" | "RemoveTodo" | "Reverse" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 new:14.5458
 todo:14.0925
 todos:13.0931
 description:12.6783
 trim:12.5065
 desc:12.048
 current:11.6504
 list:11.6461
 buffer:11.5134
 rest:11.4591
 old:11.3327
 (:11.2179
 updated:11.1577
 next:10.7463
 existing:10.555
 text:10.4922
 t:10.3481
 ts:10.1386
 item:9.90984
 update:9.67982
 xs:9.67736

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new: ?, buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
_:19.8297
T:15.1624
t:14.5559
Item:12.9437
Buffer:12.761
Entry:12.6019
 =:12.5934
Model:12.5586
List:11.8397
est:11.4407
To:10.9825
tod:10.9561
Description:10.74
buf:10.6837
Element:10.5352
item:10.5169
::10.1954
list:10.037
buffer:10.0365
Task:9.812
bie:9.73593

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_: ?, buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
t:21.4302
item:18.5751
entry:17.587
buffer:16.9121
model:16.8244
tod:16.7586
list:16.0278
element:15.7319
description:15.2944
buf:14.7767
to:14.6663
td:14.5884
line:14.5561
items:14.5019
desc:14.2642
state:14.2237
term:14.2149
elem:14.0808
task:13.8578
value:13.6895
text:13.4855

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_t

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_t
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_t: ?, buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new_t
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_t
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
odo:20.957
odos:13.2607
oto:12.8671
up:11.999
os:11.4987
 =:11.4766
udo:11.2003
ods:11.1708
icket:11.0315
ogo:10.7721
oda:10.6624
weet:10.4464
ile:10.3237
ode:10.28
ople:10.2008
odox:10.1283
odor:9.51068
omo:9.49687
og:9.47733
oso:9.46519
icker:9.17177

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_t
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: ?, buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new_todo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_todo
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:20.0271
_:18.1759
::16.7025
 ::15.0306
 (:13.7768
=(:13.3856
:(:13.3499
,:13.2908
=:12.9089
 :12.7491
(:12.1064
1:12.0548
  :11.7685
 list:11.378
():11.1649
    :10.7928
 {:10.7768
     :10.653
 item:10.6472
 :=:10.5486
 ==:10.1777

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo =

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo =
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:19.5504
 Tod:15.8821
 buffer:14.112
 Var:13.5205
 ((:13.3325
 (":13.3025
 List:13.0503
 [:12.8001
 [(:12.5555
 Abs:12.5424
 ([:12.4068
 {:12.2444
 todo:12.1276

:11.9391
 (!:11.786
 :11.6288
 if:11.5107
 model:11.3929
 String:11.3437
 !:11.143
 Tu:11.1

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:17.5939
String:13.8519
Model:13.087
string:12.8407
model:12.5753
Var:12.304
T:11.9052
trim:11.6759
Buffer:11.5438
Term:11.0494
List:10.6578
 buffer:10.5695
if:10.481
term:10.4742
Ab:10.3952

:10.0593
buf:9.9856
var:9.73409
Tr:9.6537
make:9.62882
Text:9.40695

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $== ++ ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: $== ++ ::
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: $== ++ ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | ")" | "++" | "," | "::"
root ::= new-tokens

Top 20 Logits:
,:21.9573
,[:13.505
 ,:13.4003
 ::12.2438
 +:12.0866
 $:12.0025
_:11.8765
):11.851
,":11.7351
 |:11.6601
,(:11.5291
[:11.4479
::11.3476
.:11.3068
 @:11.1701
 ++:11.0551
 "",:10.3674
(),:10.223
 ^:10.0858
 :=:10.0464
,,:10.0058

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (String, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (String, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 false:20.3915
 true:17.3507
 False:15.8268
 True:12.9147
 !:12.3329
false:11.8939
 :11.6606
 (:11.6502
 not:10.8911
 FALSE:10.6862
 Bool:10.5446
 _):10.0974
 ~:9.81587
 {:9.74184
 bool:9.63361
 if:9.53235
 [:9.5119
 @:9.45949

:9.41967
 *):9.33712
 f:9.33162

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <false>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Boolean literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: false
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/ ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: && :: \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: && :: \/
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: false
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | ")" | "," | "::" | "\\/"
root ::= new-tokens

Top 20 Logits:
):21.9553
)::15.8201
);:14.6551
 ):14.5316
),:14.45
,:13.7361
 ::13.0783
::11.944
)^:11.792
 /*:11.6467
 |:11.5036
)[:11.4691
_:10.9622
)(:10.9585
 in:10.9229
).:10.7204
)!:10.6422
 :::10.6142
)|:10.5382
)$:10.5012
 ^:10.4456

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (String, Bool)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (String, Bool)
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:18.2221

:13.7402
 :12.3566
in:12.3173
 and:11.662
 :::11.6482
:::10.7852
 ::10.5052
 as:10.4194
 |:10.4024
 ++:10.0451
 #:9.82422
  :9.36629
 end:9.36498
 @:9.32585
                :8.81867
 $:8.79645
    :8.48498
 +:8.25888
 //:8.04963
 []:7.99024

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:18.9705
 :14.2956
 #:13.0369
  :12.7845
    :12.6552
            :12.337
        :11.6647
                :11.6135
 (:10.8777
     :10.8227
          :10.8134
   :10.7706
         :10.6578
 List:10.4673
      :10.22
             :9.96904
 (*:9.85204
 [:9.62168
           :9.57164
       :9.47907
               :9.38891

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
           :20.5202
               :16.5416
            :15.7893
       :14.6595
          :14.4405

:14.3658
             :14.0219
         :13.428
	:13.2569
                :13.216
        :13.1064
   :12.3781
              :12.3541
#:12.2789
    :12.046
let:11.2617
     :10.8611
      :10.8114
List:10.6446
(:10.6424
  :10.617

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
           

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
           
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 let:15.3681
 List:15.3117
 Model:14.3301
 new:14.2421
 model:13.3772
 #:13.2131
 [:12.9271
 Tod:12.9023
 (:12.8565
 case:12.8406
 todo:12.0368
 match:11.8856
 if:11.8203
 String:11.7877
 list:11.5165
 [(:10.9341
 ([:10.7784
 print:10.5057
 @:10.4734
 ((:10.3153
 Cons:9.98452

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddTodo" | "App" | "RemoveTodo" | "Reverse" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 old:15.7655
 todo:14.9255
 existing:14.0814
 current:13.9462
 todos:13.5899
 rest:13.3923
 new:12.8201
 list:12.2949
 previous:12.0985
 prev:11.7595
 updated:11.4606
 next:10.737
 buffer:10.6739
 cur:10.5868
 update:10.517
 curr:10.2894
 remaining:10.2539
 all:10.2446
 model:10.0575
 original:9.97916
 ts:9.84149

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old: ?, new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: old
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: old
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
_:22.2798
 =:15.4739
s:14.7104
list:13.7606
T:13.656
tod:12.5785
List:12.5234
t:12.1789
 todos:12.0022
__:11.5764
ies:11.4557
 todo:11.0028
 ::10.3021
TO:10.1717
::10.0455
l:9.92947
=:9.85476
-:9.85222
,:9.80508
 list:9.64832
Buffer:9.55738

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_: ?, new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: old_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: old_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
list:21.3927
tod:21.3186
t:21.1855
items:16.602
to:16.3116
state:15.5702
td:15.4989
model:15.4759
buffer:14.4094
ts:14.2126
entries:14.2118
tail:14.1677
tasks:13.8915
tl:13.7635
value:13.4458
ones:13.381
new:13.3242
l:13.2238
 todos:13.2217
task:13.0341
data:12.9283

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old_list>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: ?, new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: old_list
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: old_list
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:20.626
_:14.4459
 ::14.0045
::13.9785
 :13.605
,:13.1033
=:12.9625
  :11.9149
1:10.6147
 :=:10.5066
$:10.101
():9.62501
   :9.53084
 $:9.50757
    :9.37047
 ==:9.32684
 |:9.29699
':9.29016
     :9.11768
 -:9.04231
 <-:8.92244

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list =

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list =
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "new_todo" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 Model:18.7347
 List:13.7927
 get:13.0241
 model:12.9599
 todo:12.6044
 (:12.5968
 :12.5109
 Tod:12.0365

:11.3781
Model:11.285
 list:11.0718
 [:10.9311
 Mod:10.8958
 to:10.1553
 remove:9.82913
 t:9.60184
 s:9.59883
 Mode:9.35543
 String:9.22138
 f:9.20114
 #:9.05211

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Model"))))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model
LSP: Generating Completions for prefix: Model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".eq" | ".get_buffer" | ".get_todo_list" | ".init"
root ::= completions

Top 20 Logits:
.:22.5143
.(:12.6923
 .:11.4426
_:11.2378
(:11.0714
 get:10.9147

:10.6456
..:9.94606
().:9.641
[:9.52548
._:9.35354
get:9.25037
,:9.19592
.[:8.81961
.<:8.69329
/:8.68404
:::8.51784
Get:8.44283
_.:8.36038
#:8.21645
{:8.20934

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "Model."))))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.
Nature of error: "Model." isn't a valid token
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: Model.
LSP: Generating Completions for prefix: Model.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "eq" | "get_buffer" | "get_todo_list" | "init"
root ::= completions

Top 20 Logits:
get:23.4948
init:14.9197
t:14.3821
 get:13.8181
Get:13.4757
to:13.1813
set:12.7207
model:12.5653
filter:12.1692
g:11.9752
map:11.9398
eq:11.7789
list:11.697
tod:11.5891
remove:11.5447
update:11.4662
add:11.4454
delete:10.9632
ge:10.7433
find:10.7359
in:10.6247

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get"))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.get
Nature of error: Variable Model.get is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get
LSP: Generating Completions for prefix: Model.get
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_buffer" | "_todo_list"
root ::= completions

Top 20 Logits:
_:23.4132
(:12.1003
T:11.3778
-:11.0919
 todo:10.8333
.:10.423
__:10.2818
_(:9.43091
t:9.16722
buffer:8.85802
Buffer:8.7272
 t:8.68236
TO:8.25859
[:8.18541
 _:8.15258
List:8.11601
 buffer:8.09665

:8.04282
Model:7.99367
<:7.70997
.(:7.70409

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_"))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.get_
Nature of error: Variable Model.get_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_
LSP: Generating Completions for prefix: Model.get_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "buffer" | "todo_list"
root ::= completions

Top 20 Logits:
t:24.7369
buffer:17.1543
tod:15.4394
list:15.1608
to:13.4788
 todo:12.943
old:12.6848
model:12.5286
new:12.471
current:12.2277
state:12.2042
td:12.1475
T:12.0569
all:11.9354
value:11.898
b:11.8064
filter:11.7719
task:11.6977
f:11.6525
data:11.6258
buff:11.621

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_t

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_t
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_t"))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.get_t
Nature of error: Variable Model.get_t is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_t
LSP: Generating Completions for prefix: Model.get_t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo_list"
root ::= completions

Top 20 Logits:
odo:27.7034
oto:15.305
ogo:14.0043
udo:13.1797
ode:11.4324
oda:11.1681
 todo:11.0571
endo:11.0329
odox:10.5978
os:10.5974
olo:10.3232
omo:10.0993
icket:10.0543
oso:9.79709
ado:9.75701
owo:9.71728
icker:9.71282
_:9.68997
odos:9.52401
ogether:9.42198
odor:9.36513

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_t
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_todo"))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.get_todo
Nature of error: Variable Model.get_todo is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_todo
LSP: Generating Completions for prefix: Model.get_todo
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_list"
root ::= completions

Top 20 Logits:
_:23.8867
List:13.2208
 list:13.12
(:12.3077
-:11.7435
_(:9.91639
__:9.85894
 List:9.01242
 (:8.52277

:8.50932
.:8.33788
():8.31301
\_:8.23911
((:8.14973
ist:8.00307
$:7.98774
list:7.95407
 _:7.94507
::7.67372
(":7.3201
(!:7.24881

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_todo_"))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.get_todo_
Nature of error: Variable Model.get_todo_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_todo_
LSP: Generating Completions for prefix: Model.get_todo_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:29.4791
List:18.3125
lists:17.2857
lista:16.6561
lst:16.3211
l:15.7519
line:15.2506
 list:15.2405
LIST:14.7335
ls:14.6832
listen:14.1764
li:13.8637
s:13.8326
link:13.6554
listener:13.5325
layout:13.342
left:13.3312
lis:13.2344
ll:12.9474
last:12.7762
less:12.6829

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo_list>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Model -> [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: Model.get_todo_list
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Model -> [Todo])
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model.get_todo_list
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
(:21.9841
 model:15.8042
 (:14.3291
():13.4973
 in:12.5784
((:12.5522
($:12.3381
([:12.0792

:11.928
({:11.4541
(@:11.2082
[:11.0507
(!:10.628
!(:10.6124
(":10.5952
_:10.5253
.(:10.5229
.:10.293
(*:10.2076
(_:10.0136
::9.92419

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.init String.reverse String.transform buffer case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.init" | "String.reverse" | "String.transform" | "buffer" | "case " | "if " | "let " | "model" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= completions | new-tokens

Top 20 Logits:
model:22.4141
buffer:14.8181
Model:14.7464
 model:13.1369
List:12.5595
new:12.3993
mode:12.3752
state:11.81
T:11.687
t:11.6859
mod:11.4589
false:11.3797
true:11.2312
models:11.2118
string:11.1621
remove:11.1473
old:11.1274
m:11.12
Buffer:11.0735
init:11.073

:10.8935

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Model
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.init String.reverse String.transform buffer case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):22.6755
),:15.4611
);:15.0954
,:14.3775
)::13.5521
).:12.7533
)[:12.5179
)(:12.1522
::12.1489
 ):12.0838
.:12.0724
)|:11.8192
)$:11.7902
_:11.7473
 in:11.6268
[:11.4984
)):11.4385
()):11.3844
 |:11.242
)]:11.1313
)?:11.0014

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "in"
root ::= new-tokens

Top 20 Logits:
 in:19.8042

:14.2547
 :13.6876
in:13.5692
 |:12.6561
 @:12.0244
 ++:11.5
  :10.6301
 +:10.5228
    :9.52949
                :9.38302
   :9.18246
 #:9.02073
 as:8.86534
     :8.6399
      :8.62006
 :::8.59611
        :8.53419
 []:8.16661
 ::8.11461
@:8.11063

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "old_list" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:19.3721
 :15.0275
  :12.8624
    :12.7706
            :12.6055
 [:11.722
 #:11.6965
        :11.4723
 (:11.2488
                :11.1955
 List:10.7651
   :10.6063
     :10.5419
          :10.0235
         :9.93901
 new:9.88429
             :9.79675
      :9.76026
 ([:9.55134
 New:9.33887
           :9.08979

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "old_list" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
           :19.8512
               :15.2374
            :15.2002

:13.9437
          :13.508
       :13.2075
#:13.1613
             :12.8609
                :12.6131
        :12.5382
   :12.5375
         :12.4115
	:12.3689
    :11.4164
              :11.1285
let:10.242
 #:10.0959
      :10.029
     :9.8625
  :9.80671
if:9.58746

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
           

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
           
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "old_list" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 old:16.9018
 new:16.6833
 List:16.5836
 #:15.9184
 let:15.5974
 [:15.2885
 (:14.1006
 model:13.3299
 Tod:12.9197
 if:12.9038
 Model:12.8914
 Cons:12.8846
 String:12.6096
 todo:12.4384
 ([:12.3288
 list:12.1742
 case:11.8728
 @:11.326
 buffer:11.1545
 ((:11.108
 [(:11.0624

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "old"))
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: ALL errors:
Error in term:
  old
Nature of error: Variable old is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: old
LSP: Generating Completions for prefix: old
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_list"
root ::= completions

Top 20 Logits:
_:23.1485
 list:12.3655
List:10.719
list:10.5768
$:10.0395
 todo:9.71617
:::9.61219
-:9.60276
::9.10227
@:8.80492

:8.6784
__:8.46388
.:8.46286
t:8.45625
 $:8.27707
 in:8.26359
\_:8.21828
T:8.13033
[:8.11245
 _:8.02923
 @:7.97784

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "old_"))
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: ALL errors:
Error in term:
  old_
Nature of error: Variable old_ is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: old_
LSP: Generating Completions for prefix: old_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:26.2346
t:15.4949
 list:13.73
link:13.6202
lista:13.448
new:13.4204
set:13.2041
log:13.0606
lst:12.5937
token:12.3863
lists:12.3123
List:12.1936
index:12.0039
to:11.9195
loop:11.8265
listen:11.7968
listener:11.7832
store:11.6234
line:11.6181
array:11.5464
ist:11.4974

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old_list>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: old_list
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: old_list
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:
 @:20.2974
 ++:17.4317
@:14.5305
 +:14.3672
 :::14.1636
:::12.8214
 #:12.2575
 |:12.1839
 ::12.178

:12.0837
 &:12.0311
++:11.7884
 ^:11.7821
 :11.2024
 <>:11.1428
 $:10.949
 <:10.894
 --:10.7937
 `:10.71
.:10.623
 //:10.5171

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "old_list" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 [:21.4622
 List:16.5014
 new:16.1021
 [(:15.8848
 (:14.5284
 ([:14.0965
[:13.6909
 [[:12.2353
 {:12.2314
 <:12.1723
 #[:12.0889
 []:12.0442
@:11.9557
 ((:11.8126
 Cons:11.695
 @:11.5867

:11.542
 $:11.4109
 :11.4067
 list:11.3341
 :11.3016

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer String.reverse String.transform buffer case  if  let  new_todo string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "(" | "Model.get_buffer" | "String.reverse" | "String.transform" | "buffer" | "case " | "if " | "let " | "new_todo" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= completions | new-tokens

Top 20 Logits:
new:21.6696
 new:15.2714
T:12.7422
|:12.5609
add:12.0969
<:11.8584

:11.6221
((:11.4916
(":10.8143
@:10.7104
Tu:10.5987
List:10.5606
 (:10.523
model:10.4664
old:10.4214
Model:10.3672
#:10.285
buffer:10.2287
*:10.1956
Add:9.855
||:9.7354

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new"))
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else in
  LSP: Info: ALL errors:
Error in term:
  new
Nature of error: Variable new is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new
LSP: Generating Completions for prefix: new
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: ++
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer String.reverse String.transform buffer case  if  let  new_todo string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_todo"
root ::= completions

Top 20 Logits:
_:23.7067
 todo:13.6092
T:12.7914
t:12.0315
-:11.125
]:10.4213
 Tod:10.1753
(:9.44668
 TODO:8.94508
__:8.08662
\_:8.05219
 _:7.99235

:7.97257
To:7.9684
Buffer:7.90725
 (:7.90197
Model:7.8893
::7.86363
ly:7.51185
():7.27253
 todos:7.14732

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_"))
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else in
  LSP: Info: ALL errors:
Error in term:
  new_
Nature of error: Variable new_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_
LSP: Generating Completions for prefix: new_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: ++
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer String.reverse String.transform buffer case  if  let  new_todo string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "todo"
root ::= completions

Top 20 Logits:
t:25.6876
to:19.1683
tod:15.2745
no:15.085
buffer:14.7692
new:13.5819
 todo:13.4204
tol:13.2357
update:13.0789
token:12.6738
toggle:12.6069
task:12.4491
f:12.0055
T:11.9803
tid:11.9275
ton:11.8735
TO:11.8303
for:11.7907
tom:11.7746
two:11.5972
do:11.4422

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_t

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_t
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_t"))
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else in
  LSP: Info: ALL errors:
Error in term:
  new_t
Nature of error: Variable new_t is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_t
LSP: Generating Completions for prefix: new_t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: ++
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer String.reverse String.transform buffer case  if  let  new_todo string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:31.3213
udo:19.6679
oto:18.8951
ogo:17.9385
ado:16.832
olo:16.7262
oso:15.9498
ido:15.2402
uto:14.5138
odox:14.3829
endo:14.3709
owo:14.0336
omo:13.5836
odos:13.1913
add:13.1301
one:12.8649
imo:12.6544
odor:12.251
do:12.1841
odd:12.1833
oco:11.9752

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_t
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: (String, Bool)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: new_todo
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (String, Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String Bool
LSP: commas: self syn is (Prod [String; Bool])
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: new_todo
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String Bool
LSP: commas: self syn is (Prod [String; Bool])
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer String.reverse String.transform buffer case  if  let  new_todo string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "]"
root ::= new-tokens

Top 20 Logits:
]:24.4224
];:15.4755
],:15.1354
 ]:14.8272
,:14.6166
,]:14.1644
 |:14.0387
]):13.0335
]::12.755
]]:12.5901
](:12.2825
].:11.7233

:11.55
 :::11.5175
::11.4811
[:11.4144
}:11.3539
][:11.2982
:::11.2973
|:11.2857
():11.2739

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:

:18.4955
 :14.3467
 #:14.1967
  :14.0264
 else:13.7263
   :13.703
            :13.5465
    :13.3261
        :12.356
 |:12.2934
                :12.2507
 in:11.6286
      :11.588
     :11.5594
 @:11.4205
          :10.9413
         :10.6633
              :10.5256
 end:10.4922
             :10.3948
       :10.3042

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:
       :20.3121
   :15.5782
           :15.1833
        :14.7102
else:14.3082
         :14.0071
            :13.4483
      :13.3471
     :13.0799
               :12.8494

:12.7556
#:12.5707
          :12.1766
                :11.8644
    :11.8216
in:11.7061
	:11.5296
(*:11.3509
             :11.1795
end:11.0326
  :10.6103

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
       

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
       
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:
 else:25.7233
 end:17.2254
 #:16.9325
 elif:14.5555
 els:13.8377
 in:13.3318
 (*:12.9297
 otherwise:12.5425
 model:12.188
 |:11.929
 return:11.7369
 {:11.5198
 ##:11.2519
 el:11.1997
 then:11.0326
 let:10.9868
 Else:10.9166
 if:10.82
 //:10.7062
 !:10.4884
 <:10.3919

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:18.0301
 :14.3958
 old:14.2339
 model:13.72
 Model:12.4684
    :12.0788
 []:11.9503
  :11.8782
 #:11.7493
 todo:11.6106
                :11.3026
   :11.1482
 List:11.127
        :11.0635
            :11.0012
     :9.63777
 [:9.60147
 if:9.2641
 list:9.25632
      :9.02253
         :8.74022

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
           :22.0082
          :17.9256
            :17.3519
         :17.2149
               :16.3288
       :15.6617
        :15.4569
             :15.1721
   :15.0274
	:14.1365
              :13.9081
                :13.8151
#:13.2346
     :13.2239
    :13.1207
      :12.4921

:12.4167
  :11.7008
Model:11.5694
 :10.8698
let:10.3896

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
           

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
           
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 Model:18.0061
 model:17.2703
 old:17.0799
 #:16.2128
 todo:16.0163
 []:15.3596
 let:15.1672
 List:14.6563
 Tod:13.3919
 raise:13.3601
 fail:13.1931
 list:12.8712
 [:12.18
 (:12.1123
 print:11.8511
 error:11.7908
 "":11.6488
 case:11.3155
 return:11.1847
 (*:11.1301
 throw:11.0217

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Model"))))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model
LSP: Generating Completions for prefix: Model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".get_buffer" | ".get_todo_list"
root ::= completions

Top 20 Logits:
.:20.971
 get:12.1885
(:11.1103
.(:10.9148

:10.8097
#:10.2342
 model:9.95086
_:9.87632
[:9.62599
 #:8.9734
,:8.93573
().:8.72137
._:8.70125
get:8.66049
():8.65714
:::8.63495
 .:8.50764
..:8.37312
(":8.36712
::8.27713
$:8.0076

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "Model."))))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.
Nature of error: "Model." isn't a valid token
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: Model.
LSP: Generating Completions for prefix: Model.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "get_buffer" | "get_todo_list"
root ::= completions

Top 20 Logits:
get:21.9219
init:16.3192
t:13.9799
set:13.4244
Get:12.6249
model:12.4382
eq:12.2136
update:12.1987
 get:11.9785
add:11.954
T:11.8593
to:11.8174
empty:11.566
Model:11.0668
g:10.6948
in:10.6318
create:10.4186
tod:10.153
insert:10.1266
map:10.0948
Init:9.99061

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get
Nature of error: Variable Model.get is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get
LSP: Generating Completions for prefix: Model.get
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_buffer" | "_todo_list"
root ::= completions

Top 20 Logits:
_:22.6759
T:12.2968
(:11.8165
.:11.2992
__:10.7108
 todo:10.2328
-:9.75386

:9.03817
Buffer:8.74943
[:8.74886
Model:8.74876
 buffer:8.43861
 _:8.4021
 t:8.40007
<:8.37468
_(:8.30818
t:8.13101
buffer:8.08647
.(:8.02693
 model:7.97983
TO:7.95682

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get_
Nature of error: Variable Model.get_ is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_
LSP: Generating Completions for prefix: Model.get_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "buffer" | "todo_list"
root ::= completions

Top 20 Logits:
t:23.9583
T:16.5002
buffer:16.4442
tod:13.8629
list:13.2076
to:12.6235
model:12.1927
value:11.8048
b:11.6592
 todo:11.4206
tol:11.2936
buff:11.2841
TO:11.0799
string:11.0636
buf:11.0217
data:10.9908
button:10.8566
text:10.8495
Buffer:10.8265
state:10.7834
td:10.7468

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_t

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_t
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_t"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get_t
Nature of error: Variable Model.get_t is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_t
LSP: Generating Completions for prefix: Model.get_t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo_list"
root ::= completions

Top 20 Logits:
odo:27.3559
oto:18.3276
udo:17.6839
olo:15.9708
ogo:15.2751
oso:14.6714
ado:14.503
oro:13.6536
do:13.3552
omo:13.0975
odio:13.0539
ardo:13.0043
ivo:12.8832
ido:12.6748
oco:12.6461
endo:12.3716
ario:12.2359
ono:12.2027
one:12.121
odon:12.1117
ongo:11.9521

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_t
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_todo"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get_todo
Nature of error: Variable Model.get_todo is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_todo
LSP: Generating Completions for prefix: Model.get_todo
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_list"
root ::= completions

Top 20 Logits:
_:22.6873
(:11.1691
-:10.381
T:9.90381
_(:9.51276
.:9.46423

:9.30309
__:9.22389
[:9.05992
View:8.82698
_.:8.78288
 _:8.6162
(":8.40526
<:8.31782
\_:8.26472
 Tod:8.24216
():8.21442
 todo:8.09039
 -:8.01694
%:7.97716
*:7.96516

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_todo_"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get_todo_
Nature of error: Variable Model.get_todo_ is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_todo_
LSP: Generating Completions for prefix: Model.get_todo_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:27.4442
List:19.7214
let:16.286
load:16.2507
line:16.1231
 list:14.9013
l:14.6422
link:14.5602
log:14.3585
head:14.0546
like:13.5714
file:13.2016
left:13.1789
lst:13.1016
lo:12.9946
less:12.8745
long:12.8336
LIST:12.8199
 List:12.7956
label:12.7582
loop:12.6527

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo_list>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: (Model -> [Todo])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo"));
           syn = (Arrow ((Var "Model"), (List (Var "Todo"))))})))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get_todo_list
Nature of error: Expecting type [Todo] but got inconsistent type (Model -> [Todo])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: Model.get_todo_list
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Model -> [Todo])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model.get_todo_list
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "in"
root ::= new-tokens

Top 20 Logits:
(:22.5578
 model:17.5552

:14.4513
 (:14.4492
():14.0183
((:12.5804
[:12.1168
($:11.917
(":11.5879
({:11.1327
(@:10.9939
([:10.6873
(!:10.5127
(*:10.3956
.:10.2969
(_:10.1657
 #:10.0904
 {:10.0857
(%:10.085
(&:10.041
.(:9.97913

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.init String.reverse String.transform buffer case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.init" | "String.reverse" | "String.transform" | "buffer" | "case " | "if " | "let " | "model" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
model:22.9929
Model:15.5806
mode:14.2581
 model:14.1155
old:13.4964
m:13.4797
buffer:13.1513
mod:13.072
t:12.3732
x:12.251
init:11.9909
state:11.7575
models:11.7311
self:11.4315
T:11.1026

:10.9291
Buffer:10.8863
main:10.755
module:10.737
update:10.6511
#:10.3791

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Model
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.init String.reverse String.transform buffer case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):23.3902
);:17.1666
)):14.9316
),:13.9304
)::13.8261
 ):13.5031
::13.0199

:12.7692
,:12.6802
).:12.5266
)":12.2209
)]:11.7467
)!:11.6323
)[:11.5897
));:11.58
)`:11.4577
)\:11.3362
)*:11.312
)}:11.2353
))):11.0737
)$:11.0175

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:

:18.9452
 end:14.5668
  :14.5484
    :14.1525
 :14.1004
            :13.9038
 #:13.8813
        :13.8591
   :13.5763
      :12.4172
                :12.2696
     :12.1928
 in:11.8193
         :11.4426
          :11.4112
       :11.2909
end:10.7692
             :10.5215
           :10.4711
              :10.1898
 (*:10.1036

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model)


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model)

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:
in:19.7108
   :18.5273
       :17.3295
end:15.5952

:13.9665
        :13.0401
    :12.9654
           :12.6601
      :12.471
            :12.1192
let:11.9128
     :11.8483
  :11.6678
               :11.6188
 :11.5809
                :11.4244
#:11.42
         :10.7495
else:10.7287
 in:10.4906
and:10.3739

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model)
in

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model)
in
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.8981
 :15.2949
    :12.6071
  :11.9969
        :11.8101
 #:11.1975
   :11.0816
                :10.7858
            :10.5245
      :10.5168
 {:10.0966
     :10.055
 Model:9.70787
       :9.51617
;:9.4662
         :9.35986
	:9.28297
          :8.74867
             :8.61039
 model:8.46518
 [:8.10627

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model)
in


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model)
in

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            old_list @ [new_todo]
        else
            Model.get_todo_list(model)
in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:21.2026
#:18.3598
    :17.087
let:16.4802
        :16.2595
 :15.8143
            :15.5551
  :15.227
   :15.0264
                :14.9905
Model:13.8214
      :13.4126
     :13.1909
       :13.032
          :12.7172
             :12.6578
         :12.6441
 #:12.6271
fun:12.3997
               :12.3534
              :12.329
