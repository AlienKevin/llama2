
================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Model -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Model -> [Todo])
  LSP: Convex: Target types: (Model -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Model.get_todo_list ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_todo_list case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "Model.get_todo_list" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:17.6539
 fun:14.8206
 :14.7489
 Model:13.178
 model:13.0074
 (:12.5863
  :11.9176
    :11.6149
 {:11.0747
   :10.9343
                :10.8098
 function:10.2948
 let:10.1265
 List:9.84148
 #:9.82986
 cur:9.81324
     :9.80691
        :9.66448
fun:9.46472
            :9.41006
       :9.2247

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Model -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Model -> [Todo])
  LSP: Convex: Target types: (Model -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Model.get_todo_list ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_todo_list case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "Model.get_todo_list" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
   :20.4732
 :19.5562
fun:17.6689
  :14.8865
let:14.027
	:13.8946
 fun:13.8191
       :13.8181
     :13.6022
func:12.9765
    :12.6251
 let:12.2561
(:11.7022
fn:11.1784
#:11.029
(*:10.8674

:10.8441
{:10.8017
      :10.7961
function:10.6943
model:10.5122

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
   

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
   
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Model -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Model -> [Todo])
  LSP: Convex: Target types: (Model -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Model.get_todo_list ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_todo_list case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "Model.get_todo_list" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:17.3274
 let:15.3953
 model:13.5385
 Model:12.8065
 (:12.4023
 #:12.1523
 String:11.3346
 string:11.012
 List:10.7865
 (*:10.5219
 update:10.4643
 func:10.0945
 lambda:10.0606
 buffer:10.0038
 f:9.96756
 Buffer:9.95173
 m:9.92546
 if:9.85941
 get:9.8458
 fn:9.75724
 @:9.7378

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 model:16.7896
 buffer:16.0769
 (:15.6484
 m:14.2441
 string:12.6639
 todo:12.5992
 buf:12.4746
 state:12.0821
 _:11.9721
 {:11.9291
 text:11.7518
 b:11.6491
 [:11.6164
 x:11.5532
 _,:11.4663
 input:11.4192
 old:11.3343
 current:11.3126
 s:11.2317
 ((:10.774
 description:10.7339

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: model
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:16.9934
,:13.5247
 buffer:12.6758
 todo:12.1422
_:11.3219
 =>:11.2867
->:10.856
 =:10.3736
 todos:9.85885
 :9.7637
 state:9.75116
 ~:9.59939
::9.54008

:9.43767
 x:9.32463
 t:9.19056
 (:8.72644
 string:8.68486
 _:8.58986
 ::8.52312
@:8.52006

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:17.515
 :14.8965
 (:14.6955
 List:14.5487
 model:14.2387
 (":13.9641
 let:13.3336
 Model:13.1238
 [:12.8839
 case:12.8022
 #:12.7892
 String:12.5794
 [":12.4112
  :12.2897
 ":12.282
    :11.9622
 [(:11.8605
 Tod:11.6824
                :11.5493
 if:11.547
 {:11.5224

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
       :18.662
   :17.1111
     :14.7072
      :13.078
    :12.943
           :12.8042
        :12.3222
let:11.728
         :11.5592
	:11.449
 :11.3348
  :11.3063

:11.1514
if:11.1505
case:11.0957
#:10.4608
(:10.395
model:10.2383
Model:10.1406
               :10.0928
match:10.0312

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
       

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
       
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 let:17.7479
 case:16.8641
 if:15.6123
 match:15.3608
 List:14.9626
 (:14.5499
 #:14.0677
 Model:13.5431
 model:13.391
 (":12.9035
 String:12.8747
 [:12.5476
 Tod:12.5295
 todo:12.0388
 [(:12.0244
 [":11.8426
 ":11.8186
 {:11.6376
 val:11.5009
 cons:11.4628
 ((:11.355

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddTodo" | "App" | "RemoveTodo" | "Reverse" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 buffer:14.0785
 (:12.9034
 description:12.8763
 new:12.8267
 todo:12.5551
 desc:12.0541
 text:11.6065
 string:11.3734
 old:11.2208
 todos:11.1834
 current:11.0713
 buf:10.9667
 input:10.7203
 list:10.4689
 b:10.4379
 model:10.3999
 get:10.2873
 {:9.91894
 Model:9.86883
 xs:9.78598
 add:9.69281

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: ?, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:18.9879
,:18.4235
::15.3266
_:14.6795
 ::14.2169
':13.5423
_,:13.3129
     :12.7765
$:12.7625
  :12.5931
=:12.5392
      :12.4055
',:12.2938
 $:12.1137
    :12.0951
        :11.919
 :11.7407
         :11.5391
           :11.4989
ed:11.4813
 ,:11.4612

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer =

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer =
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 Model:16.9438
 String:14.5424
 model:14.2176
 (:12.605
 List:12.5965

:12.4529
 get:12.3546
 f:11.6533
 ":11.6036
 string:11.4176
 :11.2705
 s:11.2184
 #:10.7844
 "":10.5092
 Buffer:10.4597
 buffer:10.0134
 Tu:9.96586
 @:9.68183
 if:9.45268
 {:9.41999
 Mod:9.302

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Model"))))
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  Model
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model
LSP: Generating Completions for prefix: Model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".eq" | ".get_buffer" | ".get_todo_list" | ".init"
root ::= completions

Top 20 Logits:
.:22.5265
(:13.4699
.(:12.0141
_:11.77
._:11.336
 .:11.1267
 get:10.4859
().:10.1191
_.:9.99009
$:9.92041
:::9.87339
[:9.78325
{:9.77745
():9.70117
.@:9.69157

:9.6062
 (:9.36489
(":9.22195
.$:9.20442
/:9.18667
,:9.15113

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "Model."))))
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  Model.
Nature of error: "Model." isn't a valid token
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: Model.
LSP: Generating Completions for prefix: Model.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "eq" | "get_buffer" | "get_todo_list" | "init"
root ::= completions

Top 20 Logits:
get:23.0991
init:17.0987
buffer:16.6904
to:13.9611
Get:13.2436
set:13.0462
map:12.4357
 get:12.4125
update:12.3399
model:12.335
buf:12.2825
eq:12.1822
g:11.9241
extract:11.8019
add:11.7715
apply:11.7383
t:11.734
Buffer:11.4129
remove:11.3183
filter:11.0768
de:11.0066

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get"))
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  Model.get
Nature of error: Variable Model.get is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get
LSP: Generating Completions for prefix: Model.get
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_buffer" | "_todo_list"
root ::= completions

Top 20 Logits:
_:23.7076
Buffer:14.6424
(:14.2918
buffer:13.1598
 buffer:11.391
__:11.0292
-:10.399
_(:10.2715
.:10.03
ter:9.69539
():9.27378
\_:8.80881
B:8.68637
Model:8.68473
T:8.57501
buf:8.54648
(":8.43148
$:8.30972
<:8.29367
 Buffer:8.22589
 _:7.99261

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_"))
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  Model.get_
Nature of error: Variable Model.get_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_
LSP: Generating Completions for prefix: Model.get_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "buffer" | "todo_list"
root ::= completions

Top 20 Logits:
buffer:28.3292
t:18.9017
input:17.0369
buf:16.3134
text:16.0128
string:15.5868
buff:15.4779
bu:15.1943
Buffer:15.0651
new:14.9096
current:14.7346
description:14.6302
value:14.5384
name:14.2929
tod:14.0013
b:13.9435
model:13.8738
next:13.8547
button:13.8483
to:13.6953
data:13.6773

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Model -> String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: Model.get_buffer
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Model -> String)
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model.get_buffer
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
(:22.1409
 model:15.9655
 (:15.0025
():13.5708
($:12.854
 in:12.7185
([:12.6378
((:12.4484
(":12.1319
(@:11.871
(!:11.1732

:11.1372
[:11.0211
(*:10.9978
(&:10.9571
({:10.8197
(_:10.7488
!(:10.5873
$:10.4601
(.:10.1432
(%:10.1078

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer Model.init String.reverse String.transform case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "Model.get_buffer" | "Model.init" | "String.reverse" | "String.transform" | "case " | "if " | "let " | "model" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= completions | new-tokens

Top 20 Logits:
model:23.2363
buffer:14.1305
#:13.0095
 model:12.9138
Model:12.8761
String:12.1251
Buffer:11.4612
string:11.4552
mode:11.3979
0:11.2681
m:11.0507
x:10.991
**:10.8469
term:10.8113
mod:10.7609
(":10.7258
[":10.6402

:10.6046
List:10.4987
un:10.4979
f:10.3491

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Model
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer Model.init String.reverse String.transform case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):24.4289
),:19.78
);:16.4454
,:15.324
.:14.7572
)::14.608
)$:14.1206
)(:13.3371
).:13.0744
 in:12.8672
)[:12.2591
 ):11.9412
)?:11.8871
)^:11.8549
[:11.725
::11.6732
_:11.5884
)!:11.5811
)|:11.57
()):11.3024
)\:11.1838

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $== ++ ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: $== ++ ::
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: $== ++ ::
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | "++" | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:20.0837

:14.1662
 and:13.3554
 :11.907
 |:11.657
                :10.5427
in:10.3138
    :10.2672
 #:10.1726
  :10.0119
      :9.93728
        :9.83235
     :9.78292
 $:9.64711
            :9.35422
         :9.26317
 &&:9.23269
   :9.18029
 ?:8.97117
 @:8.93303
 as:8.86946

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:18.8757
 :14.3005
    :12.8185
  :12.6324
        :11.6316
 #:11.2622
                :11.1874
            :11.1605
     :10.7846
   :10.7058
      :10.6395
         :10.3774
 (:10.3251
 Model:10.2607
          :9.83976
 {:9.7808
           :9.57891
       :9.45056
 String:9.39771
 let:9.38588
             :9.302

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
       :19.356
           :15.4251
        :14.0493
   :13.64

:13.4372
	:12.6439
         :12.097
      :11.8565
    :11.7409
               :11.3665
     :11.2863
            :11.2521
if:10.9212
          :10.8443
                :10.7275
let:10.4544
#:10.348
case:10.1887
  :9.72593
(*:9.57477
             :9.54896

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
       

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
       
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 if:18.33
 let:17.0671
 case:16.6625
 List:15.6021
 (:15.3239
 match:14.8108
 #:14.6938
 model:13.7321
 Model:13.618
 [:13.5852
 (":13.4141
 String:13.1317
 cons:12.8279
 buffer:12.7562
 [":12.7192
 [(:12.6924
 Tod:12.5966
 ((:12.4427
 Cons:12.3879
 ([:11.8251
 ":11.7672

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "Bool.eq" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "Model.eq" | "Model.get_buffer" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 string:15.9411
 String:15.8642
 buffer:14.4605
 not:13.16
 !:13.0962
 (:12.5832
 "":11.8457
 is:11.1895
 List:10.8105
 length:10.785
 model:10.4048
 $:10.284
 ":10.1665
 :10.0448
 str:10.0067
 Buffer:9.88946
 Model:9.68468
 buf:9.65582
 text:9.22625
 Str:9.02239
 bool:8.78316

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: ALL errors:
Error in term:
  string
Nature of error: Variable string is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string
LSP: Generating Completions for prefix: string
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_compare" | "_concat" | "_length" | "_of_bool" | "_of_float" | "_of_int" | "_sub" | "_trim"
root ::= completions

Top 20 Logits:
_:21.7904
.:12.1116
Length:11.9124
__:11.6131
(:11.5849
-:11.1616
cmp:11.1394
length:11.0139
Is:10.9983
 length:10.7643
?:10.7182
1:10.5885
?(:10.2556
 !=:10.1587
Equals:10.1411
2:10.1383
_(:10.1273
 ==:10.0925
(":9.96096
Empty:9.9461
t:9.88055

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: ALL errors:
Error in term:
  string_
Nature of error: Variable string_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_
LSP: Generating Completions for prefix: string_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "compare" | "concat" | "length" | "of_bool" | "of_float" | "of_int" | "sub" | "trim"
root ::= completions

Top 20 Logits:
length:23.699
eq:17.7192
equals:17.5998
equal:17.2704
is:16.828
empty:16.0716
sub:16.038
contains:15.9406
trim:15.9318
compare:15.772
starts:15.5854
len:15.5745
null:15.3183
size:15.148
isEmpty:15.0159
match:14.6589
ends:14.452
matches:14.4185
to:14.3546
cmp:14.0938
not:13.9449

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_length>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (String -> Int)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Arrow (String, Int))})))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: ALL errors:
Error in term:
  string_length
Nature of error: Expecting type Bool but got inconsistent type (String -> Int)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: string_length
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (String -> Int)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: string_length
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "then"
root ::= new-tokens

Top 20 Logits:
(:21.3839
($:15.8125
 buffer:15.0268
 (:14.5467
(":14.2567
((:12.9166
(!:12.5124
_:12.1509
(@:12.1217
([:11.8938
 $:11.7613
(_:11.3467
$:11.0873
():11.0813
s:10.8033
(&:10.632
!(:10.5923
 buf:10.5248
($(:10.1977
("#:10.1968
 >:10.1714

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = Int})))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else in
  LSP: Info: ALL errors:
Error in term:
  string_length(?)
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = Int})))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else in
  LSP: Info: ALL errors:
Error in term:
  string_length(?)
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else in
  LSP: Info: ALL errors:
Error in term:
  string_length(?)
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 String
  LSP: Convex: Target types: String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer ~STRINGLIT~ ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer String.reverse String.transform buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "Model.get_buffer" | "String.reverse" | "String.transform" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
buffer:21.0083
String:17.7121
string:16.1408
Model:16.1351
trim:15.7919
List:13.4265
Buffer:13.4232
model:13.3069
buf:12.9223
term:12.6077
transform:12.5828
strip:12.2421
text:12.0446
Text:11.7641
 buffer:11.4555
T:11.4071
remove:11.3377
t:11.2951
s:11.189
#:11.1261
Term:11.0702

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else in
  LSP: Info: ALL errors:
Error in term:
  string_length(buffer)
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: ++
  LSP: Concave: Infix: Lookahead types: String
  LSP: Concave: Infix: Lookahead: ++
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: ++
  LSP: Concave: Infix: Lookahead types: String
  LSP: Concave: Infix: Lookahead: ++
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 String
  LSP: Convex: Target types: String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer ~STRINGLIT~ ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer String.reverse String.transform buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "++"
root ::= new-tokens

Top 20 Logits:
):20.2779
 $:14.309
)$:14.2115
)>:14.0487
$):12.6254
$:12.1194
)=:12.0956
)::11.9806
 ):11.6884
 >:11.4624
.:11.3808
.$:11.3271
),:11.0899
)):11.0269
 <=:10.9731
 ==:10.8715
 |:10.5986
 =:10.2898
_:10.1276
).:10.0399
)]:9.99497

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = Int})))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: ALL errors:
Error in term:
  string_length(buffer)
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: == != <= >= < >
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= new-tokens

Top 20 Logits:
 >:20.3987
 ==:19.0895
 <=:19.074
 <:17.2362
 $:16.5713
 >=:16.3404
 <>:16.2403
 !=:15.7173
 =:15.6112
 ===:15.2539
 is:12.849
 then:12.1077
 /:12.1008
 :11.8494
 !==:11.7068
 +:11.5399
 *:11.3693
 |:11.1606
 %:11.1578

:11.1486
 ~:11.1125

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) >

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) >
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Greater Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Greater Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: >
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: >
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "." | "=" | "=."
new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= completions | new-tokens

Top 20 Logits:
 :20.7982
  :13.9128
 (:13.687
0:13.2001
 string:12.6264
 zero:11.7621
 String:11.7333
 Int:11.5215
 $:11.4968
 ":11.3288
 -:11.3136
 "":11.1851
 {:11.0372
 max:10.5158
 length:10.2443

:10.2287
?:10.1079
=:9.91537
 .:9.91275
 (":9.90277
 trim:9.76093

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) >
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
0:26.4026
1:22.494
2:20.1693
3:19.6664
5:18.3714
4:18.2678
6:16.5543
7:15.9824
8:15.8629
9:15.546

:12.5072
 {:10.7623
 (:10.7255
	:9.68473
 #:9.60022
 -:9.1761
 //:9.15089
 description:8.84344
 !:8.67043
 *:8.55297
 ":8.34365

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 0
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 then:19.8479

:15.1426
 &&:15.0056
 :14.6539
 ||:11.0337
 #:10.632
 {:10.1869
then:9.97542
  :9.85991
 in:9.79262
 and:9.42658
 Then:9.26468
 //:9.20533
.:9.00864
    :8.91741
 &:8.80813
 |:8.71929
 THEN:8.66314
 <:8.56426
                :8.52054
 =:8.47915

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:17.9255
 (:15.07
 :14.3817
 [:13.6862
 List:13.5323
 #:13.1443
 {:12.7503
 [(:12.5701
    :12.1077
 Model:12.0962
 Tod:12.0538
  :12.0105
 ([:11.804
        :11.7798
 begin:11.6718
            :11.564
 Cons:11.5025
 ((:11.3998
 model:11.3692
 [{:11.307
 (":11.1146

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
           :23.3659
         :18.2726
            :17.5684
          :17.5173
               :16.827
       :16.5581
             :15.8111
        :15.2442
	:15.0871
                :14.1203
              :14.0185

:13.9643
     :13.1783
   :12.7864
#:12.6458
    :12.5768
      :12.476
  :11.4862
[:11.2312
 :11.0219
 #:9.99683

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
           

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
           
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 let:15.7973
 List:15.2845
 (:15.1406
 Model:14.3965
 Tod:13.871
 #:13.8627
 case:13.4965
 model:13.4939
 [:13.4821
 [(:12.7656
 cons:12.3667
 buffer:12.3659
 todo:12.1907
 ((:12.1669
 String:12.0688
 Cons:11.8703
 ([:11.723
 if:11.3257
 (":11.2785
 match:11.1655
 list:10.9332

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddTodo" | "App" | "RemoveTodo" | "Reverse" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 new:14.5085
 todo:14.1032
 todos:12.9288
 description:12.8671
 trim:12.6798
 desc:12.0747
 list:11.7394
 old:11.6127
 buffer:11.5459
 current:11.5059
 rest:11.2706
 updated:11.0497
 existing:10.6673
 text:10.654
 next:10.5146
 t:10.2287
 ts:10.1554
 (:10.1539
 item:9.91005
 xs:9.83211
 result:9.55506

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new: ?, buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
_:19.7216
T:15.2372
t:14.5268
Item:13.2552
Entry:12.7199
Model:12.6365
Buffer:12.4433
List:11.9574
 =:11.9571
est:11.4157
Description:10.9934
To:10.9035
tod:10.8675
item:10.6996
buf:10.3985
Element:10.38
bie:10.0731
list:10.0618
Line:10.0493
::9.8701
Desc:9.8317

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_: ?, buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
t:21.3417
item:18.6636
entry:17.5224
buffer:16.7741
tod:16.6548
model:16.5543
list:16.0889
element:15.425
description:15.3337
line:14.6464
td:14.6331
items:14.5962
buf:14.588
to:14.4916
desc:14.4025
state:13.8488
elem:13.7584
value:13.6971
des:13.6417
text:13.5173
task:13.482

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_t

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_t
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_t: ?, buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new_t
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_t
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
odo:20.9573
odos:13.3802
oto:12.8061
up:11.3405
os:11.3357
 =:11.2024
icket:11.157
ods:10.9347
udo:10.931
ogo:10.7966
oda:10.6845
weet:10.4856
ile:10.4309
ode:10.3127
odox:10.0873
ople:10.0636
odor:9.54864
omo:9.4921
oso:9.39632
icker:9.36827
og:9.33448

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_t
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: ?, buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new_todo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_todo
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:20.0708
_:18.2184
::16.6508
 ::15.38
 (:13.9171
,:13.4019
=(:13.1925
=:13.1369
:(:12.9445
 :12.8255
(:12.1298
  :12.0925
1:11.852
 list:11.4648
():11.3035
 {:11.2753
    :11.0648
 item:11.0273
     :10.9012
 :=:10.5336
={:10.5259

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo =

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo =
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:19.1448
 Tod:16.648
 buffer:13.692
 ((:13.2528
 (":13.1134
 [:13.1124
 Abs:13.0812
 {:12.8453
 Var:12.6594
 [(:12.4139
 List:12.3537
 #:12.3477
 Tu:12.2386
 ([:12.2066
 todo:12.0172

:11.8074
 String:11.7314
 model:11.3862
 :11.3188
 !:11.1531
 if:11.0362

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:16.8564
String:14.4639
Model:13.1076
string:12.5446
model:12.3605
T:12.2513
trim:12.1078
Var:11.8597
Buffer:11.6871
Ab:11.0727
#:10.8403
if:10.4703
 buffer:10.3872
Tr:10.3667
Term:10.3622
transform:10.2476

:9.82617
List:9.77123
buf:9.75684
Transform:9.73919
var:9.39646

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $== ++ ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: $== ++ ::
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: $== ++ ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | ")" | "++" | "," | "::"
root ::= new-tokens

Top 20 Logits:
,:21.8104
,[:13.5102
 ,:13.1059
 $:12.7226
 |:12.7165
 ::12.4265
_:12.1981
 +:11.8536
 @:11.8052
):11.7786
::11.5828
,":11.5591
,(:11.4771
 ++:11.3085
.:11.2659
[:11.2464
:::10.8394
 ^:10.5231
 -:10.4883
,,:10.441
 "",:10.4386

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (String, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (String, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 false:20.3344
 true:17.4312
 False:16.0117
 True:13.3179
 !:12.2099
false:12.0163
 :11.8703
 (:11.7894
 FALSE:11.2206
 not:11.0208
 ~:10.4468
 _):10.3377
 Bool:10.3241
 {:9.70968
 *):9.69038
 bool:9.68843
 #:9.52312
  :9.41082
 [:9.40971
 f:9.4074
 const:9.37091

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <false>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Boolean literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: false
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/ ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: && :: \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: && :: \/
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: false
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | ")" | "," | "::" | "\\/"
root ::= new-tokens

Top 20 Logits:
):22.1322
)::16.1471
 ):14.6128
);:14.525
),:14.3475
,:14.0231
 ::13.568
::12.5388
)^:12.3614
 /*:12.1802
 |:12.0994
 :::12.0852
:::11.67
)[:11.4052
)|:11.2166
)$:11.1563
)(:11.1393
 @:11.0629
_:11.0255
 ^:10.9244
)]:10.7034

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (String, Bool)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (String, Bool)
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:18.0074

:13.2183
 :::12.9135
:::12.5113
 :12.1323
in:11.6783
 |:11.6057
 ::11.3986
 and:11.2097
 ++:11.1346
 as:10.5498
 @:10.362
 #:10.1323
 end:9.68413
 $:9.30075
 cons:9.27603
 //:9.06176
  :9.05783
 +:8.93913
                :8.62438
 --:8.49472

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:18.8406
 :14.1736
 #:13.1535
  :12.7643
    :12.6906
            :12.3167
                :11.9185
        :11.6162
   :11.0414
     :10.8881
          :10.8711
         :10.7953
 List:10.7072
 (:10.6744
      :10.2257
             :10.1956
 (*:10.1481
           :9.73268
               :9.69556
 [:9.66392
       :9.5866

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
           :20.9532
               :16.8908
            :16.2009
          :14.7923
       :14.7687
             :14.627

:14.5842
         :13.8751
                :13.8071
	:13.7008
        :13.4764
              :13.017
   :12.5308
    :12.172
#:12.0108
     :11.2151
      :10.9695
let:10.8912
  :10.5815
(:10.4971
[:10.3831

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
           

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
           
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 let:15.8515
 List:15.6771
 new:14.9001
 Model:14.668
 #:13.8206
 case:13.722
 model:13.5951
 [:13.4704
 (:13.1956
 Tod:12.8474
 if:12.1211
 Cons:12.1157
 todo:11.8552
 match:11.69
 list:11.4404
 [(:11.4207
 String:11.3328
 cons:11.2646
 Console:11.071
 ([:10.9207
 val:10.8392

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddTodo" | "App" | "RemoveTodo" | "Reverse" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 old:15.6432
 todo:14.8427
 existing:13.9079
 current:13.8308
 todos:13.3071
 rest:13.3055
 new:12.8814
 list:12.1756
 previous:11.9303
 prev:11.6772
 updated:11.3393
 next:10.6606
 cur:10.5553
 buffer:10.5209
 update:10.3865
 all:10.1695
 curr:10.1461
 remaining:10.1413
 _:10.1069
 original:10.0631
 other:9.90495

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old: ?, new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: old
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: old
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
_:22.5231
 =:15.3935
s:14.7104
list:13.6224
T:13.472
List:12.4985
tod:12.4154
 todos:12.0737
t:12.027
__:12.0135
ies:11.6391
 todo:11.2288
 ::10.3745
TO:10.2001
::9.95536
l:9.92819
=:9.90027
-:9.72737
 list:9.67244
,:9.32477
 Tod:9.31836

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_: ?, new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: old_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: old_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
list:21.4149
tod:21.3332
t:21.2571
items:16.7505
to:16.3364
td:15.6657
model:15.3194
state:15.2131
ts:14.362
entries:14.2693
tail:14.2539
tl:14.246
buffer:14.1186
tasks:13.5994
new:13.5039
ones:13.3441
l:13.3165
value:13.1938
 todos:13.1623
task:12.8766
ls:12.7618

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old_list>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: ?, new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in else in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: old_list
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: old_list
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:20.6488
_:14.2839
 ::14.0327
::13.8907
 :13.6767
=:12.9653
,:12.1729
  :12.0549
1:10.9047
 :=:10.2755
$:9.84302
():9.74481
   :9.52376
 ==:9.39162
 $:9.37364
 |:9.33474
    :9.26912
':9.23507
 ():9.12535
ing:9.10579
 <-:8.99589

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list =

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list =
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "new_todo" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 Model:18.9007
 List:14.5382
 model:13.1494
 get:12.7124
 (:12.6665
 todo:12.5941
 :12.5418

:11.58
 Tod:11.533
Model:11.3306
 #:11.3158
 list:11.123
 [:11.0728
 Mod:10.7397
 String:10.3581
 t:10.3399
 to:9.98406
 Array:9.39709
 reverse:9.35946
 s:9.35308
 f:9.34758

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Model"))))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model
LSP: Generating Completions for prefix: Model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".eq" | ".get_buffer" | ".get_todo_list" | ".init"
root ::= completions

Top 20 Logits:
.:22.5474
.(:12.4079
_:11.297
 .:11.2763
(:10.9861
 get:10.5873

:10.3263
..:9.95868
[:9.72554
$:9.35353
().:9.22155
._:9.09727
.[:9.06335
,:8.92993
get:8.90685
?.:8.71225
.<:8.52511
{:8.45134
/:8.40883
:::8.26335
_.:8.25301

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "Model."))))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.
Nature of error: "Model." isn't a valid token
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: Model.
LSP: Generating Completions for prefix: Model.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "eq" | "get_buffer" | "get_todo_list" | "init"
root ::= completions

Top 20 Logits:
get:23.4443
init:14.6907
t:14.6139
 get:13.7281
Get:13.3406
to:13.076
filter:12.9325
set:12.8146
eq:12.7643
model:12.3933
map:12.1831
g:11.7764
remove:11.6437
fold:11.6416
add:11.5129
list:11.4147
update:11.3509
tod:11.2143
delete:11.0825
ge:10.8895
find:10.8496

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get"))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.get
Nature of error: Variable Model.get is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get
LSP: Generating Completions for prefix: Model.get
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_buffer" | "_todo_list"
root ::= completions

Top 20 Logits:
_:23.5041
(:11.8088
-:11.2278
 todo:11.0048
T:10.9383
__:10.4758
.:10.4111
_(:9.33884
t:9.07944
 _:9.03964
buffer:9.01605
 t:8.92921
Buffer:8.44632
Model:8.23451
 buffer:8.22249
TO:8.17266
List:7.98944
[:7.98318
$:7.69521
<:7.67905
.(:7.63198

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_"))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.get_
Nature of error: Variable Model.get_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_
LSP: Generating Completions for prefix: Model.get_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "buffer" | "todo_list"
root ::= completions

Top 20 Logits:
t:24.7666
buffer:17.0282
tod:15.2193
list:15.0267
to:13.205
 todo:12.8571
model:12.5474
old:12.3643
new:12.2662
state:12.0291
T:12.0185
value:12.0031
b:11.9937
td:11.878
current:11.7714
filter:11.6934
TO:11.6118
tol:11.6028
data:11.5736
button:11.5383
all:11.5331

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_t

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_t
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_t"))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.get_t
Nature of error: Variable Model.get_t is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_t
LSP: Generating Completions for prefix: Model.get_t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo_list"
root ::= completions

Top 20 Logits:
odo:25.8666
oto:16.1794
udo:15.949
ogo:13.9362
ode:12.4036
od:11.8827
 todo:11.8536
owo:11.7791
oda:11.4146
ou:11.2911
os:11.1398
omo:10.897
odor:10.8312
olo:10.7768
oder:10.7284
oso:10.6544
og:10.5175
ogether:10.4168
ado:10.3655
odel:10.3177
odio:10.3111

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_t
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_todo"))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.get_todo
Nature of error: Variable Model.get_todo is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_todo
LSP: Generating Completions for prefix: Model.get_todo
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_list"
root ::= completions

Top 20 Logits:
_:23.9327
 list:13.2289
List:12.8526
(:12.5187
-:11.4671
_(:10.0271
__:9.79261
 List:8.76477
 (:8.75957
():8.61662
 _:8.39711
((:8.21471
$:8.14102
\_:8.09146

:8.03513
.:7.98586
ist:7.93133
list:7.92458
::7.67436
(!:7.57948
($:7.32893

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_todo_"))
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: ALL errors:
Error in term:
  Model.get_todo_
Nature of error: Variable Model.get_todo_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_todo_
LSP: Generating Completions for prefix: Model.get_todo_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:27.7319
List:20.2392
left:15.7417
log:15.3165
l:15.2131
last:15.0433
lists:14.886
less:14.8624
line:14.5876
lst:14.4692
lis:14.3265
let:14.3214
listen:14.1816
li:14.1032
 list:13.987
label:13.6408
items:13.4396
lista:13.3931
all:13.2684
length:13.2519
link:13.0795

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo_list>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Model -> [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: Model.get_todo_list
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Model -> [Todo])
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model.get_todo_list
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
(:22.2239
 model:15.6801
 (:14.2201
($:13.4703
():13.3845
((:12.5119
 in:12.3141
([:12.2076

:11.8895
({:11.4535
[:11.354
(@:11.1132
(!:10.9391
!(:10.8742
.:10.625
(":10.5373
::10.5361
.(:10.5001
_:10.3617
(_:10.2925
?(:10.108

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer Model.init String.reverse String.transform buffer case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_todo buffer model add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string buffer case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity new_todo parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "Model.get_buffer" | "Model.init" | "String.reverse" | "String.transform" | "buffer" | "case " | "if " | "let " | "model" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= completions | new-tokens

Top 20 Logits:
model:22.6182
Model:15.355
buffer:14.1285
 model:13.2596
List:12.516
new:12.5038
#:12.2716
mode:12.2208
old:12.0334
state:11.7233
t:11.5299
T:11.5118
string:11.4205
mod:11.2598
false:11.1957
init:11.1902
remove:11.1251
true:11.0641
m:11.0172
String:11.0036
models:10.9424

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in else in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Model
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer Model.init String.reverse String.transform buffer case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):23.0954
),:15.6622
);:15.1601
,:14.6104
)::14.0654
).:12.8451
::12.677
)[:12.4584
)$:12.4144
)(:12.3459
 ):12.3281
_:12.2018
)|:12.1788
.:12.143
 |:11.9522
)?:11.5596
 in:11.274
)):11.2616
()):11.0821
)':11.0659
)]:11.0601

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in else in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "in"
root ::= new-tokens

Top 20 Logits:
 in:19.7368

:13.9484
 :13.6248
 |:13.1126
in:13.0795
 @:13.06
 ++:11.452
 +:10.9758
  :10.5401
    :9.62376
 #:9.56185
                :9.48708
   :9.06807
 as:9.04481
 ::8.8072
     :8.74508
      :8.70177
@:8.6189
 :::8.60494
 //:8.5255
 $:8.48337

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "old_list" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:19.3548
 :14.8486
    :12.8608
  :12.8104
            :12.7042
 #:12.4077
 [:11.6633
                :11.5335
        :11.5324
 (:10.9591
     :10.7939
   :10.7857
 List:10.5172
          :10.2243
         :10.1864
             :10.1582
 new:10.0548
      :9.87507
           :9.31891
 ([:9.18754
       :9.1249

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "old_list" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
           :20.1478
               :15.6063
            :15.3809

:14.1454
          :13.7574
       :13.3051
             :13.2003
                :13.0658
#:12.8206
        :12.7823
	:12.7652
         :12.5672
   :12.4575
              :11.6502
    :11.5595
      :10.1828
     :10.157
 #:10.0562
let:9.76663
  :9.6631
if:9.40893

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
           

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
           
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "old_list" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 new:17.0507
 old:16.8539
 List:16.7266
 #:16.4324
 let:15.6893
 [:15.5069
 (:14.3191
 Cons:13.8335
 model:13.2837
 if:12.8844
 Model:12.8379
 String:12.7785
 case:12.5386
 Tod:12.4623
 ([:12.2401
 todo:12.0934
 list:11.8032
 {:11.78
 cons:11.7736
 buffer:11.7719
 reverse:11.4402

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new"))
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: ALL errors:
Error in term:
  new
Nature of error: Variable new is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new
LSP: Generating Completions for prefix: new
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_todo"
root ::= completions

Top 20 Logits:
_:22.5886
 todo:12.3722
 List:11.1714
 Tod:10.9775
T:10.5411
t:9.98073
 [:9.90636
List:9.83725
(:9.39005
 _:9.29654
 TODO:9.23337
-:9.09356
 old:8.95219
 (:8.90167
:::8.86043
=:8.84215
 todos:8.82434
 list:8.75388
 String:8.73097
::8.49579
 :::8.43052

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_"))
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: ALL errors:
Error in term:
  new_
Nature of error: Variable new_ is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_
LSP: Generating Completions for prefix: new_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "todo"
root ::= completions

Top 20 Logits:
t:24.9279
to:14.6531
list:14.259
token:13.7998
tuple:13.5332
value:12.9587
tod:12.3523
tol:11.9182
no:11.7587
buffer:11.7144
model:11.6438
toString:11.6349
empty:11.6275
new:11.4616
tensor:11.3887
l:11.2754
d:11.2598
data:11.2279
tail:11.1842
tt:11.1268
result:11.0762

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_t

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_t
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_t"))
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: ALL errors:
Error in term:
  new_t
Nature of error: Variable new_t is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_t
LSP: Generating Completions for prefix: new_t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:27.7583
udo:18.6226
ado:18.0157
oto:17.5974
ido:16.658
olo:15.83
ogo:15.2976
oso:14.7912
uto:14.1908
go:13.4419
ulo:13.2276
odox:13.0376
owo:12.8888
ivo:12.2698
endo:12.232
oro:11.9655
do:11.6624
os:11.611
 todo:11.5255
ato:11.4083
imo:11.3961

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_t
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: (String, Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo")); syn = (Prod [String; Bool])})))
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: ALL errors:
Error in term:
  new_todo
Nature of error: Expecting type [Todo] but got inconsistent type (String, Bool)
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: new_todo
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (String, Bool)
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: new_todo
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "::" | "else"
root ::= new-tokens

Top 20 Logits:
:::20.2244
 :::18.9583
 @:13.9416
 +:13.1759
@:12.263
 ++:11.9703
 ::11.7435
::11.4092

:11.2079
,:11.2071
 &:11.1087
 List:10.9277
 in:10.8455
 cons:10.8307
 *:10.5832
 #:10.5811
 ~:10.3851
++:10.2518
 |:10.2329
 //:10.2166
.:10.1982

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Generating Completions for prefix: ::
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "new_todo" | "old_list" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
old:22.1425
List:15.7537
Model:15.0194
(:14.4535
model:13.3037
 old:12.973
olds:12.931
@:12.6009
[:12.5606
t:11.6343
Old:11.4097
#:11.0323
((:10.9767
list:10.7436
reverse:10.672
[]:10.6106

:10.3842
tail:10.2557
::10.246
$:10.1628
re:10.1602

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "old"))
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: ALL errors:
Error in term:
  old
Nature of error: Variable old is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: old
LSP: Generating Completions for prefix: old
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_list"
root ::= completions

Top 20 Logits:
_:23.7695
 list:12.2628
List:11.4372

:10.5603
$:10.3671
-:10.2005
__:9.5671
list:9.34586
@:9.07978
(:9.05321
.:8.95283
 $:8.84163
::8.82568
 in:8.55981
:::8.55356
 @:8.38266
 List:8.34384
 :8.17221
 _:8.10037
#:7.92887
[:7.74705

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "old_"))
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: ALL errors:
Error in term:
  old_
Nature of error: Variable old_ is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: old_
LSP: Generating Completions for prefix: old_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:30.9711
List:20.3124
listen:18.2773
 list:16.4962
l:15.9876
log:15.935
ll:15.9196
lista:15.7004
line:15.6146
link:15.2962
LIST:14.8339
lst:14.6962
loop:14.265
let:13.9564
t:13.865
listener:13.7555
map:13.7479
load:13.6389

:13.3761
lists:13.3596
less:13.336

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <old_list>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: old_list
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: old_list
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: old_list [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  new_todo old_list string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:

:18.5842
 :14.0071
 #:13.8383
  :13.4321
 else:13.2566
            :13.076
 @:13.052
    :13.0394
   :12.8584
 |:12.6235
                :12.1763
        :12.0949
 $:11.8482
      :11.4256
 in:11.3571
;:11.3416
     :11.2044
          :10.5657
 (*:10.4258
         :10.2915
 ::10.1965

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <old_list>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:
       :21.2013
           :15.3318
        :15.1943
   :14.7846
         :14.4821
            :13.8679
               :13.7132
      :13.6742
else:13.3859

:13.1351
     :13.0227
                :12.7061
          :12.4843
	:12.363
    :12.0218
#:11.9943
             :11.9659
(*:11.1581
              :10.718
  :10.4644
 :10.0609

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
       

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
       
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <old_list>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {old_list: [Todo], new_todo: (String, Bool), buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:
 else:26.1486
 end:16.4643
 #:16.1143
 elif:14.4714
 els:14.0387
 (*:12.9916
 otherwise:12.3953
 |:12.2382
 in:11.9585
 //:11.9392
 {:11.5919
 Else:11.0576
 model:11.0505
 el:10.9645
 ##:10.948
 return:10.8938
 /*:10.827
 if:10.6862
 then:10.5505
 --:10.548
 ::10.4155

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:18.2801
 :14.6132
 old:14.2824
 model:13.6951
    :12.569
 []:12.2977
  :12.0682
                :11.9369
 Model:11.8933
   :11.6599
 List:11.6394
        :11.5252
            :11.5153
 #:11.4868
 todo:11.3093
     :10.0278
 [:9.92434
 if:9.5911
 list:9.57996
      :9.22888
         :9.11724

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
           :22.4906
          :18.0781
            :17.7185
         :17.1865
               :16.4071
        :15.5694
       :15.5435
             :15.4224
   :15.011
	:14.6251
                :14.2108
              :14.1164
    :13.3568
     :13.2773

:13.0832
#:12.9595
      :12.4787
  :11.6715
Model:11.08
 :10.9508
(*:10.293

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
           

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
           
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "add" | "buffer" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 Model:18.2748
 old:17.6269
 model:17.5868
 #:16.9146
 todo:15.9899
 []:15.9543
 List:15.4184
 let:15.2742
 Tod:13.5348
 [:13.2804
 raise:13.1759
 list:13.0213
 fail:12.7696
 (:12.4053
 "":12.3673
 case:12.1559
 print:11.8595
 (*:11.6109
 Mod:11.4257
 Old:11.4204
 error:11.2177

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Model"))))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model
LSP: Generating Completions for prefix: Model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".get_buffer" | ".get_todo_list"
root ::= completions

Top 20 Logits:
.:21.0142
 get:11.3502
(:10.9293

:10.9099
.(:10.4234
 model:10.0994
_:9.86922
#:9.45203
[:9.07782
 $:8.88719
 #:8.62004
,:8.51588
():8.43215
$:8.41935
 .:8.35444
().:8.21057
._:8.08819
get:8.04756
..:8.03128
(":7.98235
::7.96335

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "Model."))))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.
Nature of error: "Model." isn't a valid token
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: Model.
LSP: Generating Completions for prefix: Model.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "get_buffer" | "get_todo_list"
root ::= completions

Top 20 Logits:
get:22.0821
init:15.9161
t:13.9157
set:13.1925
Get:12.4452
eq:12.4273
model:12.2653
 get:12.2214
add:12.0674
update:11.924
to:11.7547
T:11.6606
empty:11.4683
Model:10.8201
g:10.7204
in:10.6742
create:10.3023
fold:10.1244
tod:10.0943
map:10.0845
new:10.0789

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get
Nature of error: Variable Model.get is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get
LSP: Generating Completions for prefix: Model.get
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_buffer" | "_todo_list"
root ::= completions

Top 20 Logits:
_:23.0373
T:11.8945
(:11.7413
.:10.946
__:10.6317
 todo:10.5843
-:9.60089
t:9.25577

:9.13035
 _:8.64953
 t:8.58999
<:8.53349
Buffer:8.47368
[:8.44087
 buffer:8.33347
_(:8.30183
Model:8.25383
buffer:7.9385
::7.74936
TO:7.63471
$:7.6258

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get_
Nature of error: Variable Model.get_ is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_
LSP: Generating Completions for prefix: Model.get_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "buffer" | "todo_list"
root ::= completions

Top 20 Logits:
t:24.4006
buffer:16.0817
T:15.1103
tod:13.9196
list:13.6237
to:12.5695
model:12.1461
 todo:12.1186
value:11.7084
b:11.6214
tol:11.5914
TO:11.2294
data:11.0536
buf:11.0108
buff:10.9126
string:10.902
td:10.8929
button:10.8869
text:10.6746
new:10.6429
tail:10.5872

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_t

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_t
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_t"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get_t
Nature of error: Variable Model.get_t is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_t
LSP: Generating Completions for prefix: Model.get_t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo_list"
root ::= completions

Top 20 Logits:
odo:27.5973
oto:19.1103
udo:17.5965
ado:16.7651
oso:15.7103
olo:15.6077
oro:15.2496
do:14.3395
ardo:14.3175
odio:14.2873
ario:14.1637
ogo:14.1355
ido:13.6401
ore:13.5974
omo:13.5778
endo:13.5193
ordo:13.3885
ando:13.3815
odon:13.3215
ivo:12.9461
odox:12.7745

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_t
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_todo"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get_todo
Nature of error: Variable Model.get_todo is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_todo
LSP: Generating Completions for prefix: Model.get_todo
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_list"
root ::= completions

Top 20 Logits:
_:22.9888
(:11.7835
-:10.5863
.:9.75359
_(:9.50534
T:9.43855

:9.38754
View:8.96015
():8.95788
\_:8.76458
[:8.62163
__:8.60863
 _:8.35844
(":8.35078
 todo:8.3397
*:8.3016
(_:8.26017
_.:8.22015
(':8.0715
%:8.04427
<:8.03053

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "Model.get_todo_"))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get_todo_
Nature of error: Variable Model.get_todo_ is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model.get_todo_
LSP: Generating Completions for prefix: Model.get_todo_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:29.0474
List:21.1036
LIST:16.8694
 list:16.6233
lista:16.0663
let:15.1534
log:14.9507
link:14.6751
lst:14.5915
lists:14.2109
line:14.1051
listen:14.0779
lit:14.0652
liter:13.4987
load:13.4453
listener:13.3638
live:13.0877
 List:12.9145
light:12.6699
label:12.5314
lo:12.4128

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.get_todo_list>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: (Model -> [Todo])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo"));
           syn = (Arrow ((Var "Model"), (List (Var "Todo"))))})))
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  Model.get_todo_list
Nature of error: Expecting type [Todo] but got inconsistent type (Model -> [Todo])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: Model.get_todo_list
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Model -> [Todo])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model.get_todo_list
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "in"
root ::= new-tokens

Top 20 Logits:
(:22.8177
 model:17.028

:14.4652
 (:14.3436
():13.8598
($:12.6726
((:12.6068
[:11.8888
(":11.5964
(!:10.8577
({:10.8323
(*:10.4953
(@:10.4361
([:10.4104
#:10.3974
.:10.3787
(_:10.2989
 #:10.2804
::10.2088
{:10.0687
.(:10.0311

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer Model.init String.reverse String.transform buffer case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] add buffer case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "Model.get_buffer" | "Model.init" | "String.reverse" | "String.transform" | "buffer" | "case " | "if " | "let " | "model" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
model:23.2829
Model:15.8331
 model:14.2072
mode:13.8884
buffer:13.0939
m:13.0676
mod:12.9533
old:12.7894
#:12.4776
t:12.127
x:12.066
init:11.5802
new:11.5189
models:11.4152
state:11.219

:11.1674
self:11.135
T:10.8267
module:10.6076
main:10.5908
md:10.5039

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Model
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Model
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List (Prod [String; Bool]))
LSP: commas: self syn is (Var "Model")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Model
String <= Model
String <= Model
  LSP: Convex: Target types: String, Model
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model Model.init ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer Model.init String.reverse String.transform buffer case  if  let  model string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):22.9855
);:16.7215
)):14.1769
)::13.6843
 ):12.9813
::12.8046
),:12.6653
).:12.2776

:12.2713
)$:11.8873
,:11.8513
)*:11.5431
)!:11.4141
)\:11.2483
)":11.2464
 ::10.9022
)[:10.8554
)^:10.7667
)`:10.6845
)|:10.5081
s:10.4346

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:

:19.3019
  :14.4779
 end:14.3977
    :14.3157
            :14.1627
 :14.1067
        :14.0895
 #:13.8373
   :13.6535
                :12.6656
      :12.607
     :12.2617
         :11.5741
          :11.4791
       :11.4637
 (*:11.3255
end:11.265
 in:11.1681
 |:10.9203
             :10.75
           :10.6609

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model)


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model)

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, model: Model, add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: (Model -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:
in:21.2385
   :18.2106
       :18.2105

:15.4744
end:15.3332
        :13.8328
    :13.5509
let:13.5265
           :13.2558
            :13.0212
else:12.9841
      :12.8586
                :12.2112
               :12.1871
     :11.8918
  :11.8884
and:11.8483
#:11.669
         :11.2871
 in:11.0853
if:10.9941

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model)
in

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model)
in
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.1137
 :14.1016
    :12.8044
  :12.1663
        :11.9903
   :11.2475
                :10.97
      :10.7454
            :10.7312
 {:10.4075
     :10.3992
 #:9.73616
       :9.64815
         :9.61938
	:9.41155
          :8.91132
             :8.89568
 Model:8.75751
;:8.60857
 %:8.42756
               :8.20888

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model)
in


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model)
in

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Add a todo item #
let add: Model -> [Todo] =
    fun model ->
        let buffer = Model.get_buffer(model) in
        if string_length(buffer) > 0 then
            let new_todo = (buffer, false) in
            let old_list = Model.get_todo_list(model) in
            new_todo::old_list
        else
            Model.get_todo_list(model)
in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {add: (Model -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: (([?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: add Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:20.6436
    :16.6173
        :16.031
#:15.6016
 :15.204
            :15.0607
let:14.9664
                :14.6909
  :14.518
   :14.3528
Model:12.6671
      :12.6145
             :12.6023
     :12.5042
       :12.2865
         :12.0859
List:12.0653
	:12.0417
          :11.9454
              :11.9169
               :11.6042
