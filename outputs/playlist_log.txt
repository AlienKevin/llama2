
================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList
LSP: Process Zipper: No serialized zipper, processing string
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Target types: ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:19.605
 :16.6743
 fun:14.557
  :14.2336
    :13.7491
                :11.9292
 #:11.9188
   :11.7421
     :11.7288
      :11.1513
        :11.1317
 function:11.1011
	:10.9258
 (:10.8248
       :10.6226
 (*:10.2705
 {:10.214
            :10.1747
 \:10.1112
fun:9.94334
         :9.91505

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Target types: ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 :20.1856
   :17.8016
fun:17.1424
  :15.0758
 fun:14.7121
	:14.3419
     :13.651
       :13.3023

:12.9288
let:12.5612
#:12.4127
func:12.3712
    :12.1657
 let:10.968
function:10.8396
 func:10.7857
(:10.6715
(*:10.6119
{:10.3634
           :10.3497
      :10.2784

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Target types: ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:20.8221
 #:15.1303
 let:14.2711
 (*:13.5051
 |:12.5336
 function:12.1638
 (:12.0551
 *:11.7422
 ##:11.7109
 +:11.6496
 match:11.6445
 func:11.5962
 {:11.3137
 f:11.3014
 ~:11.2758
 mut:11.0974
 update:10.8203
 @:10.7568
 add:10.7048
 [:10.6143
 if:10.5636

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 play:18.4902
 (:16.4648
 pl:15.5375
 old:14.7855
 state:14.5953
 p:14.007
 song:13.699
 current:13.3512
 [:13.2759
 ((:13.0799
 list:12.8558
 pair:12.7071
(:12.663
 ([:12.5623
 prev:12.5295
 curr:12.3253
 tuple:12.2977
 action:12.2213
 args:12.1785
 {:12.0375
 ({:11.8752

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {play: (PlayList, PlayListAction), update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: play
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "PlayList") (Var "PlayListAction")
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: play
LSP: commas: p_ana is prod: (Var "PlayList") (Var "PlayListAction")
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
list:20.8167
_:14.7296
lists:14.4992
ist:14.3019
List:14.0719
,:13.603
l:13.5302
state:12.5821
lis:12.4988
ls:12.425
lst:12.3764
lit:12.282
ilst:10.8178
 list:10.1596
back:9.92185
able:9.6279
a:9.61956
State:9.61384
lista:9.53078
st:9.5229
al:9.22564

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: (PlayList, PlayListAction), update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "PlayList") (Var "PlayListAction")
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
LSP: commas: p_ana is prod: (Var "PlayList") (Var "PlayListAction")
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:18.0451
 action:14.7225
_:13.2179
 ->:11.6495
 play:11.6225
 ,:11.3409
1:11.0332
 act:10.9768
0:10.7232
 actions:10.66
 and:10.649
 song:10.1954
2:10.1119
_,:9.9155
@:9.91183
 pl:9.7659
 state:9.70423
action:9.33479
 p:9.27635
 current:9.04665
 update:9.04044

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: (PlayList, PlayListAction)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: (PlayList, PlayListAction)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Var "PlayList") (Var "PlayListAction")
LSP: commas: self syn is (Prod [(Var "PlayList"); (Var "PlayListAction")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 action:18.344
 play:14.4562
 act:14.0612
 a:12.9362
 song:12.8941
 command:12.4327
 actions:12.1901
 new:11.6391
 pl:11.6126
 p:11.5031
action:11.3686
 event:11.3654
 next:11.3153
 x:11.0069
 Play:10.9914
 update:10.839
 player:10.4801
 cmd:10.4337
 input:10.4275
 current:10.3923
 (:10.3552

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "PlayList") (Var "PlayListAction")
LSP: commas: self syn is (Prod [(Var "PlayList"); (Var "PlayListAction")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: action
LSP: commas: p_ana is prod: (Var "PlayList") (Var "PlayListAction")
LSP: commas: self syn is (Prod [(Var "PlayList"); (Var "PlayListAction")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:19.6982
->:14.7481
 =>:13.4251
 :13.1721
_:11.3092
 =:11.3085
::11.2467

:11.1874
 in:10.4734
2:10.3307
1:10.0322
 $:10.02
 -:10.0007
 â†’:9.93092
?:9.77788
$:9.68465
 ::9.67826
 -->:9.60258
 {:9.35754
':9.31552
0:9.09878

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:

:19.8055
 :16.5173
  :14.814
    :14.1507
 case:13.2181
 match:12.8905
        :12.1223
   :12.0971
                :12.008
 #:11.9258
 {:11.8046
     :11.7563
      :11.7171
       :11.0738
            :10.9203
	:10.9088
 (*:10.7801
          :10.6267
         :10.5908
 play:10.4777
 fail:9.96455

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
   :19.8521
     :17.4726
       :16.3105
 :16.155
  :15.6432
    :15.5687
	:13.6964

:13.6941
      :13.4912
         :13.3502
case:13.1605
           :12.4219
match:12.2653
        :12.2501
let:11.7529
#:11.3592
          :10.6986
               :10.5231
             :10.4501
                :10.2552
if:10.1793

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
   

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
   
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
 case:20.0117
 let:18.4284
 match:17.9968
 #:14.4541
 if:14.0886
 switch:13.3804
 play:13.1393
 (:12.8115
 print:12.7615
 test:12.3036
 (*:12.0012
 {:11.9754
 Play:11.4413
 fun:11.3768
 var:11.3515
 cases:11.3334
 ((:10.7045
 open:10.6827
 un:10.6606
 do:10.3968
 use:10.3609

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_current_song get_songs string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_current_song" | "get_songs" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:18.8612
 play:16.484
 get:14.5065
 (:12.8744
 song:12.1123

:11.7864
 :11.634
 actions:11.1422
(:10.6382
 let:10.6041
 songs:10.6033
 act:10.5585
 current:10.2648
 {:10.2486
 List:10.0521
 [:10.0098
 player:9.79964
 is:9.68493
 Action:9.53314
 list:9.42748
play:9.27346

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListAction
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: action
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_current_song get_songs string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.3333
 :17.4704
 of:15.2122
,:15.1905
  :14.8982
    :14.0503
 |:13.7686
 with:13.3832
      :12.6451
::12.6185
 {:12.5802
                :12.4749
     :12.474
 #:12.1909
        :12.086
   :12.0707
       :11.6662
 ::11.4112
;:11.3895
         :11.2065
            :11.2017

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListAction
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :20.2433
   :19.8202
       :17.3748
    :16.6214
      :15.1672

:14.4284
        :14.2376
         :14.2361
  :14.0698
 :14.0038
	:13.5976
           :12.9467
|:12.3473
          :12.1172
#:12.0814
             :11.7274
 |:11.669
            :11.629
                :11.1185
               :10.5808
              :9.9541

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListAction
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.4739
 #:17.4211
 +:14.6867
 Play:12.886
 P:12.6311
 (*:12.259
 when:12.0843
 ##:11.7592
 ~:11.5173
 //:10.836
 {:10.5934
 (+:10.5801
 Add:10.5774
 *:10.5252

:10.3344
 -:10.2218
 Player:10.1421
 (:10.1386
 play:10.1176
 ::10.1004
 /*:10.0473

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Play:18.4362
 Add:17.3898
 P:16.7684
 Remove:15.5529
 _:12.4161
Play:12.09
 (:11.5896
 :11.187
 Player:10.7941
 #:10.6798
 {:10.4117
 Get:10.1308
 App:9.8077
P:9.78537
 Rem:9.64762
Add:9.56659
 play:9.48036
 Stop:9.44182
 Song:9.38466
 Start:9.34386
  :8.91141

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | Play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | Play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:22.8296
(:13.6314
P:13.19
_:11.6316
 song:11.3992
List:11.0811
Next:10.9913
song:10.828
list:10.7019
 Song:10.5946
Current:10.3559
ing:10.259
Sound:10.1478
p:10.0628
(_:9.53196
ed:9.45551

:9.40598
 =>:9.22807
Sing:8.98225
Action:8.93931
Or:8.82864

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlayS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlayS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | Play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PlayS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PlayS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PlayS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PlayS
LSP: Generating Completions for prefix: PlayS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:28.0321
ongs:16.7442
song:13.9138
 song:13.27
on:11.823
ongo:11.7378
(:11.6223
oup:9.81818
ug:9.70527
oon:9.52692
n:9.43986
ame:9.40105
one:9.11488
ng:9.05065
ONG:9.02028
ond:8.91885
ony:8.8061
ang:8.7631
onic:8.63369
 Song:8.47959
ou:8.417

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlayS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PlaySong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Id -> PlayListAction)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PlaySong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PlaySong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PlaySong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.7864
 id:15.4816
 song:14.4884
(_:14.4534
 i:12.2769
 new:12.116
 x:12.0541
 (:11.8369
 sid:11.3436
 next:11.1444
(-:11.0476
 s:11.0313
 _:10.9066
(":10.7292
 index:10.0778
():10.0088
  :9.97845
 track:9.90962
 :9.80363
((:9.74763
 =>:9.72211

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
id:19.3851
song:18.5793
x:15.9536
new:15.3931
i:15.3653
s:14.3234
current:14.0838
next:13.8262
play:13.6141
idx:13.4873
Id:13.4301
index:13.3586
n:13.177
track:12.7052
0:12.4039
value:11.7919
a:11.6921
pid:11.4329
p:11.4162
1:11.2998
k:11.2723

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):19.1396
),:15.0541
_:14.072
)=:13.4354
 as:12.7066
1:12.6347
)->:12.6064
)::12.5662
_):12.3323
'):12.2458
2:11.9722
::11.2626
To:11.0855
=:10.9415
 =:10.6848
 ):10.4041
0:10.3377
t:10.2715
)|:10.0425
:::9.81186
,:9.78441

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.7247
 ->:14.2397
 when:13.6387
 if:13.5984
  :13.274
    :13.0857
      :12.9588
       :12.8551
 :12.5609
   :12.3362
        :12.328
         :12.2994

:12.0352
     :12.0226
          :11.7311
           :11.2515
                :11.2311
             :10.6403
            :10.5673
 as:10.4963
              :10.2549

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:

:16.6486
 (:15.3665
 :15.3124
 play:14.0505
 ([:13.8692
 if:13.4036
 [:13.3326
 let:13.2895
 #:12.9356
 ((:12.6859
 <:12.5135
  :12.4604
 get:12.3878
 {:12.3553
 id:12.3102
 List:12.2526
 (*:12.0477
 update:11.5855
 [(:11.5521
    :11.321
 tuple:11.0389

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
       :20.1074
         :19.1913
           :15.8597
        :15.633
          :14.1311
     :14.1227
	:13.9314
      :13.7544
             :13.6121
            :12.7062
                :12.4559
               :12.2144

:11.5278
              :11.1342
#:11.1126
   :10.9809
    :10.6534
 :9.80067
  :9.70114
if:7.83327
 #:7.83015

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
 let:18.1005
 if:17.9736
 #:16.4067
 (:16.1075
 case:14.9745
 match:14.7522
 get:14.5947
 play:14.5798
 ([:14.4204
 (*:13.8859
 ((:13.257
 [:13.126
 test:12.9646
 List:12.7345
 update:12.4033
 tuple:12.3887
 {:12.3845
 begin:12.3779
 <:12.1854
 id:12.1719
 Play:12.0973

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:16.9538
 _,:14.9356
 _:13.9749
 song:13.0355
 current:12.4021
 new:12.261
 ids:12.201
 id:11.8803
 play:11.8497
 (:11.7912
 old:11.7138
 all:11.1456
 list:10.9269
 curr:10.2141
 is:10.1297
 xs:10.0991
 un:10.0797
 next:10.0231
 s:9.96085
 prev:9.93044
 other:9.80986

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:20.4368
 =:16.5599
_:14.9434
_,:14.1846
 ,:13.9156
@:13.7006
1:13.3537
',:12.8248
 @:12.6755
 ::12.2424
2:12.2223
::12.0379
=:11.441
0:11.4363
  :11.2025
$:11.1691
 _,:11.1036
$,:10.8555
 :10.7214
 $:10.5749
      :10.4909

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 _:19.754
 current:18.0846
 old:14.1784
 id:13.9312
_:13.7269
 curr:13.4069
 playing:13.3179
 song:12.6931
 prev:12.5035
 paused:12.4798
 previous:12.3997
 c:12.3762
 cur:12.3154
current:11.8349
 __:11.6901
 x:11.6736
 currently:11.3558
 play:11.1025
 :11.0593
 mut:11.0288
 maybe:10.8797

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= new-tokens

Top 20 Logits:
 =:19.3109
current:16.564
=:14.504
 as:14.1805
 :13.5675
    :13.2292
old:13.1972
  :12.9013
curr:12.7306
      :12.1729
previous:11.9016
   :11.8208
play:11.8095
prev:11.7715
cur:11.6623
id:11.416
     :11.3991
        :11.3925
p:11.0074
         :10.9763
_:10.8099

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_current_song" | "get_songs" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:20.4675
 :12.8859
 get:12.8435
play:12.5281

:12.4976
 List:12.4338
 (:11.6686
 action:11.4859
 pl:10.8766
 list:10.778
 current:10.7563
 if:10.6502
 Tu:10.3565
 split:10.3218
 update:10.2866
 tuple:9.87936
 p:9.83248
 song:9.81445
 old:9.63986
 parse:9.53152
 pal:9.47637

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:23.191
ist:14.0938
_:13.9453
List:12.4693
l:12.4158
 list:12.3786
lis:11.8789
lists:11.708
lit:11.2344
lst:10.8038
ls:10.5236
 in:9.99095
t:9.91946

:9.75628
 =:9.7345
link:9.68229
ll:9.3393
play:9.06149
line:8.99065
.:8.94714
ilst:8.92886

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:19.4045

:14.3911
 :13.0215
;:12.9151
 and:12.8487
,:12.7587
.:12.0007
  :10.4212
 end:10.3673
 #:10.3429
                :10.1004
 &&:9.00502
      :8.84559
    :8.80031
 ,:8.77284
 |:8.63076
 ;:8.54165
in:8.49935
   :8.49073
 +:8.45044
 as:8.44933

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:

:18.9184
 :15.5653
  :13.6093
 (:13.3948
    :12.8179
        :12.0278
      :11.9067
 [:11.749
 ([:11.7127
 (*:11.6157
            :11.5659
                :11.5599
 #:11.5428
 id:11.499
 List:11.4882
 play:10.8824
   :10.8707
         :10.7391
 songs:10.7243
          :10.7198
     :10.6583

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
       :19.5318
         :16.6092
        :15.5334
           :14.2056

:14.0375
	:13.915
      :13.5628
          :12.5933
     :12.3567
             :11.8962
            :11.7255
    :11.536
   :11.5315
                :11.3295
#:11.1051
  :10.7591
               :10.6778
(*:10.585
 :10.2958
(:10.2527
              :10.0123

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
 (:18.6249
 if:17.6
 ([:17.3626
 let:16.4701
 songs:15.9496
 #:15.8083
 List:15.4099
 (*:14.4738
 case:14.3585
 ((:14.2046
 match:13.6116
 [:13.4208
 get:13.2393
 song:12.9242
 play:12.6028
 assert:12.4691
 (_:12.3084
 list:12.2815
 update:12.2545
 add:12.2431
 [],:12.1323

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
song:20.2174
play:14.233
remove:13.6124
get:13.3633
List:13.3032
add:12.2841
if:12.1131
 songs:11.9098
id:11.5325

:11.5173
update:11.2663
filter:11.2608
sing:11.1041
append:10.151
list:10.1275
set:10.1071
insert:9.85325
ids:9.85275
delete:9.76458
Id:9.72948
s:9.65488

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:18.777
_:15.9684
ing:12.9329
ers:12.1249
List:11.619
lists:11.6187
.:11.5797
song:11.252
able:11.1865
ed:10.6414
,:10.3386
ist:10.2546
(:9.92371
back:9.53518
 list:9.50293
 songs:9.41826
::9.41182
:::9.36968
queue:9.28561
-:9.22077
lst:9.17956

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
,:14.009
.:13.9349
[:13.6001
_:13.008
 @:12.0196
 ++:11.1183
 with:10.891
 +:10.7713
):10.4675
(:10.4041
:::10.2848
 $:10.2553
 |:10.2093
::10.0746
 =:9.81831
 :=:9.73572
 songs:9.68481
.(:9.56984
 :::9.40241
),:9.36732
 ::9.30379

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:15.59
 @:14.101
 #:12.5039
 if:12.5026
@:12.3842
 :12.2178
 +:11.9158
 ::11.4569
 with:11.0972
:::10.9993
  :10.9984
 $:10.9865
 =:10.9738
 where:10.819
 in:10.7668
 (:10.7208
 {:10.7027
 |:10.6229
    :10.5747
#:10.4296
 :::10.4135

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :18.1199

:15.1342
      :14.8643
in:14.8446
   :14.4855
end:14.4541
        :14.41
    :13.9257
       :13.723
         :12.9496
 :12.7608
  :12.6615
          :12.5107
            :11.9062
#:11.6755
           :11.5241
	:11.1806
                :11.1274
|:10.8927
```:10.0038
              :9.78356

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:19.1559
 #:14.6929
 end:14.1666
 (*:12.4755
 else:11.6485

:11.5791
 if:11.1995
 <:11.1473
 ||:11.1109
 P:11.0137
 //:10.9213
 when:10.9046
 (:10.5713
 _:10.4819
 Play:10.4262
 case:10.3429
 @:10.1948
 !:10.0288
 ...:9.98273
 ~:9.95772
 ():9.94281

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 P:19.7679
 Remove:16.4737
 Add:16.2191
 _:13.3928
 :11.2881
 Stop:11.2258
 Play:11.0619
 Res:10.654
 ...:10.5649
 Current:10.533
P:10.4691

:10.3696
 Get:9.97985
 Rem:9.83628
 Next:9.82391
 pause:9.73138
 #:9.68641
 Change:9.58702
 Set:9.41816
 Rest:9.36253
Remove:9.25239

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "auseCurrentSong" | "laySong"
root ::= completions

Top 20 Logits:
ause:23.8225
aused:14.1466
au:13.5015
aus:13.0142
ase:10.9874
ulse:10.5573
aste:10.5308
use:10.2436
ush:10.0509
ace:10.0106
urchase:9.79532
rep:9.53744
ouse:9.45021
ose:9.18655
 pause:9.17166
asse:9.15917
us:9.14118
ure:8.78874
P:8.7786
auss:8.60178
are:8.57061

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | Pause

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | Pause
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Pause>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Pause"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Pause
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Pause
LSP: Generating Completions for prefix: Pause
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "CurrentSong"
root ::= completions

Top 20 Logits:
Current:22.3163
S:15.2018
C:14.1145
 =>:13.0571
():11.7383
Cur:11.6167
(:11.3227
current:11.1311
_:11.0662
Play:10.8163
 Current:10.6094
 current:10.4066
Music:10.3463
...:9.72085
 if:9.65099

:9.6477
P:9.3689
Or:9.3398
 song:9.16459
All:8.94854
Player:8.93232

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrent

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrent
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | Pause
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrent>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PauseCurrent"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PauseCurrent
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PauseCurrent
LSP: Generating Completions for prefix: PauseCurrent
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:20.5717
 =>:11.6388
 song:11.5629
 Song:11.4024
Sound:11.0703
():11.0269
Play:10.5951
SON:10.43
ly:10.3528
(:10.3494

:10.3356
song:10.2525
_:9.90821
...:9.2494
 ->:9.11404
 >:8.55972
Id:8.53958
(_:8.50384
Player:8.43145
 #:8.39345
Music:8.35287

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrent
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrentS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PauseCurrentS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PauseCurrentS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PauseCurrentS
LSP: Generating Completions for prefix: PauseCurrentS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:24.6132
on:15.0376
song:14.9486
ongs:13.8951
ng:13.3145
oon:13.0595
one:12.7942
ung:12.7404
 song:11.9997
ongo:11.2199
n:11.2151
ou:10.7729
og:10.7572
un:10.7398
ang:10.6812
ony:10.4286
now:10.4254
ing:10.1889
om:10.1668
ons:10.1172
ond:9.89524

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrentSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PauseCurrentSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: PauseCurrentSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.3074
 if:12.9504
=>:12.609

:12.3288
 :12.0397
 when:11.6244
():11.2047
(:10.1422
  :9.92644
 ->:9.92058
 =:9.80137
 :=:9.79851
 |:9.29865
,:9.14904
 _:9.0548
 {:8.9661
    :8.87031
 as:8.6951
(_:8.65985
 ||:8.31172
   :8.2827

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:

:17.5176
 :14.7653
 play:14.372
 (:13.732
 ():12.431
 ...:11.9118
  :11.9088
 #:11.8709
 ?:11.76
 (*:11.447
 get:11.1089
 pause:11.0855
 {:10.8385
 ((:10.7509
 fail:10.6914
    :10.6493
 if:10.4697
        :10.4036
 pass:10.3759
 let:10.0791
 ([:9.90361

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
       :19.5472
         :16.5997
        :15.1471
      :14.5065
     :14.1751
           :14.1633
	:13.0381

:12.5908
#:12.2768
          :12.2536
             :11.9241
   :11.7352
               :11.2218
            :11.1169
    :10.7972
 :10.4494
                :10.4269
let:10.3084
  :9.99427
begin:9.83539
              :9.60027

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
 let:20.4547
 #:17.7538
 if:17.4373
 (:17.3711
 play:17.0049
 get:15.8178
 case:15.12
 ():14.7878
 (*:14.783
 match:14.2773
 ((:14.1364
 pause:14.0242
 ([:13.8939
 fail:13.7011
 ...:13.6968
 []:13.2658
 {:13.0511
 ?:13.0159
 <:12.9151
 (":12.8534
 [:12.7768

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:17.7001
 _,:16.0674
 _:13.933
 current:13.8947
 song:13.3547
 id:12.8717
 (:12.361
 play:12.1304
 new:11.0496
 Songs:10.5682
 pause:10.5175
 old:10.3502
 curr:10.2179
 playing:10.0682
 s:9.81644
 ids:9.76321
 all:9.60927
 :9.59233
 list:9.43858
 Id:9.43676
 plays:9.43527

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:20.6086
 =:14.88
 ,:14.1251
_,:13.5774
 _,:12.2361
 @:11.9447
_:11.745
@:11.6385
1:11.547
 ::11.4747
::11.3366
 current:10.9941
 _:10.1443
=:10.0927
 :9.76545
,,:9.73296
2:9.71128
',:9.53652
 as:9.24429
0:9.19992
.:9.165

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:19.8246
 _:18.0316
 id:16.9337
 playing:14.7481
 song:13.6945
 curr:13.5161
 cur:12.905
 play:12.318
 c:12.0711
_:11.9941
 old:11.8938
 x:11.8209
 currently:11.6318
 :11.2994
 player:11.1606
 i:11.0631
 previous:10.9305
 p:10.9176
current:10.909
 index:10.7435
 paused:10.6046

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: ?, songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:20.284
_:17.9209
=:14.2644
Id:13.4852
S:13.4502
 :13.0073
::12.1525
Play:11.3514
id:11.2383
song:11.0088
 ==:11.0038
ID:10.8757
 -:10.5129
P:10.5066
 song:10.4642
-:10.4431
 id:10.362
,:10.1912
 ::10.173
1:10.0175
Index:10.0139

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_current_song" | "get_songs" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:20.133
 get:14.367
 (:12.1639

:11.7986
 :11.4057
 pal:11.3304
 pl:11.3223
play:10.9813
 current:10.9094
 List:10.7006
 list:10.7003
 if:10.4474
 update:10.3784
 songs:10.3437
 song:10.2786
 p:10.1539
 Play:9.90542
 action:9.76068
 player:9.61711
 parse:9.60695
 pay:9.56101

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:21.2293
_:12.3351
 list:12.2792
l:12.2607
ist:11.5861
List:11.5484
.:11.1566

:11.1084
line:10.9212
link:10.7147
lst:10.6583
lis:10.3973
let:10.2816
lit:10.0847
lists:10.0108
-:9.57332
lista:9.46699
ls:9.46544
::9.30825
load:9.26348
play:9.09662

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:19.7583

:14.2092
 :12.7088
.:12.3946
;:12.258
,:11.7444
 and:11.523
in:10.508
 where:9.84584
  :9.83627
 #:9.30412
_:9.20205
):9.05691
::9.02047
():8.86283
2:8.7168
 if:8.71309
   :8.51464
    :8.49399
	:8.46551
 with:8.41543

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:

:19.0845
 :14.48
  :13.3466
        :12.6367
    :12.2729
      :11.8624
 (:11.6608
            :11.3629
          :11.3108
         :10.9185
                :10.7154
 #:10.6895
   :10.5498
     :10.4784
       :10.1245
 current:9.73712
              :9.66873
           :9.63105
 ():9.46089
             :9.38941
	:9.23525

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
       :19.6721
         :15.7247
        :15.7189

:14.1758
           :13.8576
      :13.7489
     :12.9243
	:12.804
          :12.4921
#:12.2424
   :12.1662
    :11.8089
            :11.2529
  :11.1584
             :11.1369
 :11.0313
(:10.9886
                :10.8661
               :10.7739
let:9.74721
              :9.65461

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
 (:18.7032
 if:18.4207
 #:17.1898
 let:16.9337
 ((:16.8767
 ([:16.475
 play:16.2714
 (-:16.1974
 ():15.8255
 case:14.9863
 match:14.5236
 (*:14.0292
 get:13.9239
 pause:13.6663
 []:13.657
 update:13.1895
 ...:13.0732
 songs:12.9951
 List:12.9593
 [:12.7927
 test:12.7203

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
song:16.9809
play:16.5744
if:11.9794
get:11.7783
remove:11.4797
current:11.2142
let:11.1734
List:11.0975
([:10.9923

:10.7125
add:10.6422
update:10.6353
list:10.481
(),:10.3415
Play:10.1287
((:10.1136
p:9.82621
 songs:9.8244
[]:9.756
lists:9.58036
sing:9.52605

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {current: Id, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:21.9
lists:14.1422
_:13.9599
lis:13.2058
ls:13.1018
List:12.6232
l:12.4834
ist:12.3927
lst:12.2556
ers:11.438
ing:11.3408
 list:10.9178
lit:10.6694
st:10.1412
song:10.0696
):10.0508
.:9.98531
ll:9.77658
ed:9.75854
ilst:9.71713
t:9.71435

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):19.4514
,:15.132
 @:14.0579
.:13.6379
[:12.9933
 +:12.7175

:12.6809
 ):12.3114
).:11.9968
)):11.9738
@:11.9303
);:11.7225
 with:11.6805
 ++:11.657
_:11.4849
 -:11.3068
),:11.2651
;:11.2631
 |:11.1756
[@:11.0653
2:10.8856

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.5971
 :14.4474
  :14.0872
        :13.6535
      :13.2928
 #:13.2106
    :13.1342
 @:12.1568
 if:11.8322
                :11.7483
          :11.6256
            :11.5409
   :11.4313
     :11.1202
         :10.9955
#:10.8622
       :10.8243
              :10.3568
 in:10.2805
           :10.135
@:10.1136

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :19.3896
in:14.2282
      :14.082
       :14.0484
end:13.9728
   :13.911
    :13.8409

:13.5759
        :13.495
#:12.9908
         :12.7958
 :12.2495
  :12.0417
	:11.5101
           :11.0912
          :11.0338
            :10.3629
                :10.1079
```:9.78339
|:9.60662
else:9.52204

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.5014
 #:16.6353
 end:13.6228
 (*:12.5113
 Remove:11.4248
 //:10.457

:10.3715
 ||:10.3129
 Add:10.294
 (:10.2656
 else:10.2236
 ...:10.2041
 id:10.0864
 if:10.0687
 ():10.0299
 ::10.0244
 ~:10.0014
 @:9.98248
 remove:9.97604
 in:9.90098
 <:9.8547

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Remove:21.1926
 Add:17.6986
 _:13.0029
 Rem:12.8697
 :12.3959
 Delete:11.906
 Play:11.2891
Remove:11.2009
 Stop:11.1226
 Update:11.0787
 Res:10.9061
 #:10.8256
 Next:10.8161
 Re:10.7779
 R:10.3542
 ...:10.3285
 Get:10.2851
 Un:10.1896
 Move:10.1193
 remove:10.0943
 P:10.0117

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | Remove

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | Remove
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Remove>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Remove"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Remove
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Remove
LSP: Generating Completions for prefix: Remove
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:20.9674
(:12.8152
 Song:11.7481
Current:11.4931
 song:11.4049
_:10.8578
All:10.8172
Id:10.507
From:10.4438
Last:9.67356
song:9.43756
(_:9.37611
Play:9.2868
Sing:9.11579
First:9.06808
SON:9.06516
Action:9.03833
P:8.75779
 current:8.67108
Sound:8.61473
And:8.55024

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | Remove
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "RemoveS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  RemoveS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RemoveS
LSP: Generating Completions for prefix: RemoveS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:25.0996
ongs:16.6575
song:15.8322
on:14.9651
ongo:13.8788
one:13.5899
oon:13.5693
ound:12.5308
om:12.4386
 song:12.3487
ng:12.3262
ond:12.0697
ung:11.7249
ogn:11.6144
ons:11.3411
oup:11.2238
n:10.8166
ony:10.7302
ome:10.5472
ohn:10.5119
ONG:10.3559

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Id -> PlayListAction)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  RemoveSong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: RemoveSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RemoveSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:20.7916
(_:16.6718
 id:14.3255
 =>:13.6643
():13.3523
 (:13.0448
((:11.4458
 _:10.6588
($:10.6547
([:10.5426

:10.2969
=>:10.1764
 song:10.0557
 :10.0126
(-:9.86288
(@:9.59887
({:9.50215
Id:9.34499
 ->:9.23695
(*):9.22823
::9.17262

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
id:20.4424
song:17.3566
remove:15.2553
index:14.836
rem:14.6647
i:14.6599
Id:14.5149
to:14.3297
current:14.3261
idx:14.3257
x:14.2529
0:13.9802
1:13.5992
target:13.3055
s:13.1287
play:12.5908
n:12.5616
position:12.4658
pos:12.3366
rm:12.155
key:12.0066

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):20.2437
_:16.0637
)=:15.1279
To:14.249
2:13.503
1:12.7714
),:12.7601
'):12.6203
 as:12.0652
::11.5519
t:11.4686
)->:11.4037
_):11.3697
 ):11.197
 to:11.1856
)::10.8243
0:10.6466
 =>:10.3071
)):10.1555
to:10.0188
':9.87005

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.2861
 :14.5278
 when:13.8914
 if:13.467
 ->:13.0589

:12.9529
  :11.7043
 as:10.9605
 {:10.8201
 =:10.6875
 :=:10.276
=>:10.1346
    :9.81548
   :9.79028
 ==>:9.59986
 ==:9.40535
 then:9.28809
 and:9.15163
      :8.84646
 #:8.82241
	:8.76053

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:

:18.9994
 :16.9429
 #:13.4049
  :13.0949
 (:12.8092
        :11.853
    :11.5401
      :11.0743
 play:11.0526
 (*:11.0462
            :10.9011
 {:10.742
                :10.6515
         :10.4778
          :10.3693
   :10.3633
 ():10.3531
 if:10.3275
 let:10.2824
 remove:9.97362
 ?:9.92529

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
       :21.5907
         :17.4689
        :16.6759
      :16.1675
           :15.1379
     :14.7827
	:14.2178
#:13.4667
          :13.3366
   :13.2634

:13.1311
             :13.0582
            :12.4614
 :12.314
               :12.2733
    :12.1262
let:12.0834
                :11.4693
  :11.0812
              :10.7917
(:9.92742

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
 let:21.4474
 #:18.1913
 if:17.5992
 (:16.8262
 case:16.2139
 get:14.6776
 fail:13.8431
 (*:13.8289
 test:13.757
 remove:13.6799
 fun:13.4271
 match:13.4129
 ():13.2149
 play:13.0974
 ((:13.0891
 update:12.9715
 begin:12.8915
 #(:12.6072
 {:12.1541
 print:12.1168
 <:12.0412

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:18.6322
 song:13.5888
 _,:13.3729
 remove:12.5485
 id:11.9024
 ids:11.851
 all:11.6371
 current:11.5722
 (:11.5591
 new:11.5589
 play:11.3251
 old:11.0945
 _:11.0445
 rec:10.7217
 Songs:10.7065
 filtered:10.583
 removed:10.3904
 index:10.3413
 get:10.1512
 list:10.0102
 to:10.0092

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:20.492
 =:14.8521
_:14.0987
_,:13.0339
 ,:12.9686
::11.9394
1:11.8385
',:11.7812
@:11.5277
2:11.2052
 @:10.9678
 ::10.7331
0:9.95116
 :9.9447
To:9.88388
 _,:9.82356
=:9.71565
Ids:9.33321
':9.25314
,,:9.1055
 ids:8.88472

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:19.8046
 _:17.2249
 playing:13.519
 curr:13.1249
 id:13.0878
current:12.5604
 song:12.503
_:12.4378
 :12.3838
 play:11.9583
 cur:11.904
 paused:11.7429
 c:11.6714
 x:11.3148
 index:11.2615
 pause:11.0224
 old:10.9992
 player:10.771
 currently:10.5773
 p:10.5339
 other:10.3986

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: ?, songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:20.9385
_:15.8076
=:14.6994
 :14.4631
S:11.9548
Id:11.6405
 ->:11.4864
 ==:11.4496
::11.1664
 -:11.0206
2:10.7159
1:10.6954
Play:10.582
,:10.4015
 id:10.2586
 song:10.0694
song:10.063
  :10.0124
':9.90599

:9.78833
id:9.73026

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_current_song" | "get_songs" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:20.5141
 get:12.8891
 :12.6749
 remove:11.9196
 List:11.8869

:11.6988
 (:11.5247
 pl:11.3405
 pal:11.286
play:11.0087
 list:10.9233
 Play:10.7328
 if:10.7071
 p:10.3463
 songs:10.1841
 filter:9.99664
 current:9.94665
 song:9.85912
 pay:9.72157
 find:9.3809
 split:9.34312

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:22.2139
List:14.6749
l:13.7351
_:13.7066
 list:12.6609
lst:11.951

:11.7316
ist:11.398
.:11.3637
test:11.2849
link:11.1556
load:10.9341
label:10.8541
line:10.7956
let:10.6726
lis:10.5752
 in:10.3261
 :10.2792
,:9.97435
last:9.91205
lib:9.90713

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:20.1816
 :13.3014

:12.9728
.:12.1224
,:11.7927
 and:10.5475
;:10.1223
in:9.67234
  :9.62628
   :9.00915
_:8.97376
[:8.83264
(:8.67503
2:8.55952
1:8.55584
 ?:8.51849
::8.48041
 #:8.43499
    :8.37424
 with:8.12739
?:8.10126

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:

:18.635
 :14.8471
  :12.5112
        :12.374
    :11.5543
      :11.349
            :11.038
   :11.0102
          :10.9176
         :10.3015
                :10.2285
 (:9.86655
     :9.68196
 #:9.39946
       :9.39306
	:9.17622
 [:9.15422
           :9.14726
              :8.77928
 List:8.71605
 (*:8.25075

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
       :20.1886
        :15.9929
         :15.836

:14.3869
      :14.3325
           :14.1635
	:13.1835
   :13.0082
#:12.8522
     :12.6152
          :12.5547
 :12.1302
    :11.9654
            :11.741
                :11.725
             :11.6288
(:11.5822
               :11.3502
  :11.1672
              :10.3262
let:9.75553

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
 (:20.39
 if:19.3873
 #:18.4243
 let:18.1379
 case:17.4792
 ((:16.77
 List:16.3865
 ([:16.3224
 match:15.5352
 play:14.8156
 remove:14.5584
 (*:14.5327
 update:14.3959
 filter:14.2931
 Play:14.2271
 ():14.1855
 [:14.1331
 songs:14.0699
 #(:13.7225
 get:13.6908
 list:13.6414

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
play:16.5036
song:15.2772
List:15.2405
filter:13.0653
remove:12.3798
id:12.1278
if:11.6316

:11.3349
current:10.8668
([:10.6284
list:10.6071
Id:10.5996
let:10.5702
((:10.5625
get:10.4215
Filter:10.1819
Play:10.0851
lists:9.93325
update:9.5123
 List:9.33802
 play:9.30778

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:20.519
List:14.2803
_:13.0358
test:12.0041
let:11.9213
link:11.4345
lists:11.0188
l:10.9655
 list:10.0859
ment:9.97686
t:9.9266
loop:9.8132
.:9.61422
ing:9.57596
song:9.37185
-:9.25493
label:9.13577
lst:9.1244
line:9.11049
[:9.03319
,:8.91156

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):19.4683
 @:13.65
.:13.4784
,:12.9119
 -:12.6684
 |:11.8397
[:11.6129
 ):11.5004

:11.486
_:11.442
).:11.3364
)):11.1404
 with:11.1237
@:10.8638
 without:10.8382
 :10.7039
 +:10.6414
:::10.5737
[@:10.1918
);:10.1687
.@:10.0738

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.5634
 :15.3561
  :13.8184
        :13.7278
    :12.8824
      :12.7063
   :12.4693
 #:12.19
 @:11.6564
          :11.3577
            :11.3352
                :11.2564
         :10.8927
       :10.5353
     :10.514
 if:10.2555
#:10.1485
           :9.90623
@:9.84959
              :9.84327
             :9.35399

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :19.5074
   :15.5588
       :13.8175
in:13.7305
      :13.6764
end:13.5536
    :13.3377
 :13.1817
        :13.0056
         :12.7409

:12.3719
#:12.2301
           :11.5632
  :11.3293
	:10.9505
          :10.7805
            :10.133
|:10.1016
(*:10.0852
                :9.90524
 end:9.74745

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.6293
 #:15.1335
 end:11.7832
 und:11.6448
 case:11.2494
 in:11.0593
 if:11.0458
 (*:10.7724
 ||:10.7556
 *:10.7384
 (:10.6356
 actions:10.4963
 @:10.0923
 play:10.057
 +:9.93432
 let:9.88838

:9.88069
 action:9.71146
 A:9.70714
 [:9.65757
 _:9.64184

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Add:21.3843
 _:14.1263
 Play:13.1309
 :12.7404
Add:11.6008
 P:11.5379
 Remove:10.8688
 add:10.6694
 Update:10.5089
 Get:10.4864
Â :10.3503
 Sk:10.2054
 App:10.0999
 #:9.95732
 Stop:9.87308
 =>:9.6813
 Clear:9.36934
 A:9.31174
 Res:9.12389
 (:9.06698
>:9.05625

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | Add

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | Add
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Add>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Add"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Add
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Add
LSP: Generating Completions for prefix: Add
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:20.8801
song:13.942
s:11.9055
(:11.5631
SON:11.2471
_:10.9767
 Song:10.8529
 song:10.4564
To:10.2018
New:10.0068
Play:9.47541
Id:9.44641
P:9.41079
Current:9.28945
Sound:9.28075
AS:9.19252
Action:9.04861
Sing:8.92278
Se:8.79288
T:8.76926
SS:8.72407

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | Add
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "AddS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  AddS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: AddS
LSP: Generating Completions for prefix: AddS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:24.2101
ongs:15.1289
on:14.993
song:13.5961
oon:12.8012
one:12.7525
ongo:11.8068
ung:11.3561
 song:11.086
ng:11.0715
ound:10.9578
ond:10.7608
om:10.7296
ony:10.7152
ing:10.5407
Play:10.4037
oup:10.3437
ame:10.3325
ang:10.2505
ome:10.2157
ou:10.2081

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Id -> PlayListAction)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  AddSong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: AddSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: AddSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:20.6856
(_:15.0771
 =>:13.4336
 id:12.9301
():12.8819
 (:12.3218
((:11.1136
([:10.349
 song:10.2912
=>:10.1528
Id:10.0611
 _:9.92786
(":9.76867

:9.70005
[:9.50458
 ->:9.17264
({:9.00117
($:8.93016
 :8.6683
To:8.60809
(?:8.42956

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
id:21.0621
song:18.3917
Id:16.0522
new:15.9357
current:14.4384
i:13.7975
x:13.7488
s:13.0864
ids:13.0047
next:12.9411
string:12.6833
name:12.6701
index:12.6117
title:12.4524
add:12.3005
int:12.2064
track:12.1393
play:12.1328
0:12.0612
idx:12.0252
n:11.9508

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):21.1133
)=:15.4616
_:12.9656
)->:12.7084
),:12.452
 as:12.3079
2:12.267
 ):11.9601
,:11.7912
::11.5482
_):11.1255
)::10.9788
1:10.9005
)):10.7842
 =>:10.625
);:10.375
'):10.3323
)>:10.0458
)|:9.86765
To:9.80984
)':9.72624

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.2099
 :14.3248
 if:13.6321
 ->:13.6135
 when:13.1782

:13.1141
  :12.1125
   :12.0378
    :10.8716
 {:10.2289
 =:10.205
 :=:10.1891
 as:9.90774
 &&:9.76126
=>:9.69947
 ==>:9.64683
      :9.19812
 :::8.93551
 and:8.87832
 >>:8.80534
 #:8.76377

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:

:19.2044
 :16.8453
 (:13.3571
  :13.0475
 #:12.3777
 play:12.1357
        :11.9426
    :11.6884
   :11.2217
      :11.0452
 if:10.8197
 (*:10.6435
            :10.6434
          :10.4398
 add:10.3464
         :10.2779
                :10.2776
 {:10.1874
 ((:10.1528
 update:10.0851
 let:9.84128

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
       :20.8393
         :16.3898
      :15.8206
        :15.7315
   :15.2017
     :14.3834
           :13.9961
	:12.6276
#:12.6048

:12.4133
    :12.3979
 :12.3866
          :12.2612
let:12.0658
             :11.9157
            :11.1504
  :10.9687
               :10.9606
                :10.2481
(:10.145
if:10.0322

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
 let:22.0898
 (:18.1184
 if:18.0172
 #:17.3115
 case:15.7204
 ((:15.2693
 play:14.7603
 get:14.7107
 update:14.4605
 ([:14.4535
 add:14.4161
 (*:14.0351
 test:13.9778
 List:13.6568
 fail:13.6457
 ():13.3959
 match:13.1703
 id:13.1518
 Play:12.9429
 list:12.8171
 assert:12.3617

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:19.4061
 _,:14.1852
 song:13.918
 new:13.0053
 _:12.8362
 id:12.3389
 ids:12.1538
 play:12.1523
 current:12.0411
 (:11.9375
 old:11.5822
 Songs:11.3489
 all:11.3342
 add:11.33
 list:10.8732
 existing:10.6916
 s:10.3659
 rec:10.2664
 :10.2121
 prev:10.1088
 curr:9.97136

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:21.3144
 =:15.1687
 ,:13.564
_,:12.8941
_:12.761
::11.7074
1:11.2624
',:11.1806
 @:11.1452
@:11.0446
2:11.024
 ::10.9487
 _,:10.5128
 :10.3011
=:9.93666
0:9.76126
,,:9.66168
.:9.4676
 ids:9.10029
 :=:9.08496
 current:9.03372

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:20.1815
 _:18.2192
current:12.9383
 curr:12.7754
 id:12.4911
 :12.3867
 playing:12.2954
 song:11.7153
_:11.4931
 cur:11.2232
 play:11.154
 =:10.9217
 c:10.8103
 index:10.4821
 currently:10.4053
 paused:10.3982
 last:10.369
 x:10.3465
 player:10.0718
 next:9.92261
 is:9.90054

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: ?, songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddSong PauseCurrentSong PlaySong RemoveSong [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:21.0876
=:14.3745
_:14.0599
 :14.0136
 ==:11.2183
 id:10.8555
,:10.6956
 -:10.6345
 song:10.5536
::10.5073
S:10.3544
 ->:9.92972
Id:9.87508

:9.23052
song:9.21564
  :9.04212
 <-:8.8299
 play:8.72409
 _:8.70772
1:8.68596
Play:8.58303

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_current_song" | "get_songs" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:20.9031
 get:12.376
 :12.3155
 pl:11.7234
 pal:11.6989
 (:11.6688
 List:11.4518

:11.1565
 Play:11.127
play:10.9285
 list:10.9268
 p:10.7675
 add:10.7375
 song:10.3223
 if:10.0862
 songs:10.0172
 parse:9.82682
 pla:9.7998
 pay:9.79959
 plays:9.65673
 action:9.53991

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:24.2711
let:14.8104
link:13.5143
_:13.3743
lit:13.3064
List:13.006
l:12.9728
ist:12.5281
lst:12.3973
loop:11.9934
load:11.9601
line:11.9155
 list:11.8956
label:11.7505
ling:11.6303
light:11.3896
listen:11.3801
last:11.2745
log:11.0712
less:10.8881
lists:10.8787

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi playlist sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:20.5126
 :13.5177

:12.167
,:11.8462
.:10.4247
 and:10.2308
in:10.004
  :9.52798
   :9.23405
(:8.76485
    :8.48425
 #:8.37186
 or:8.25307
[:8.24022
;:8.24015
 not:8.22992
 int:8.1767
_:8.15583
 ?:8.06443
                :8.03802
 ,:7.76764

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:

:18.2337
 :14.5721
  :12.1755
        :11.8073
    :11.2319
      :11.141
   :10.6568
            :10.3132
          :10.1538
 (:10.0994
                :9.56309
         :9.44745
     :9.13599
       :8.99941
              :8.30011
           :8.2605
	:8.10078
 #:8.09673
 play:8.09106
             :7.98397
 ():7.76317

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
       :20.1935
         :15.2657
        :14.9158
   :14.7596
      :14.4701
           :13.9884

:13.245
     :12.9705
 :12.5924
	:12.3456
    :12.2927
#:11.9471
(:11.8194
          :11.7768
  :11.2086
            :11.0925
             :10.8542
                :10.7402
               :10.6895
in:10.566
end:10.4952

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
 (:20.5552
 ((:18.893
 if:18.0863
 ([:17.6717
 #:16.7929
 let:16.4442
 play:15.4754
 case:15.3132
 List:14.7873
 [(:14.2232
 Play:14.1861
 add:14.1563
 [:14.0506
 match:14.0481
 update:13.869
 get:13.672
 ():13.6353
 (*:13.58
 songs:13.3791
 (":13.1852
 []:13.1811

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "if " | "let " | "playlist" | "type " | "update"
root ::= new-tokens

Top 20 Logits:
play:17.6148
song:15.0852
id:14.445
List:14.3884
add:12.729
if:11.8252
Id:11.6689
current:11.6298
([:11.5758
((:10.9499
list:10.9349
Play:10.7648
ids:10.7407
get:10.7113
let:10.6862
[]:10.56
sing:10.4415

:10.4327
lists:10.3002
s:10.1811
update:10.1324

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:22.5712
List:13.2415
l:12.8857
lists:12.628
link:12.6078
_:12.1211
line:11.2205
lis:11.0978
ist:10.9866
lst:10.8703
ls:10.8414
label:10.6582
ll:10.3624
load:10.3391
ling:10.1765
lint:10.0874
.:9.9211
light:9.72587
 list:9.7172
ment:9.71448
ing:9.71314

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
  LSP: Convex: Target types: PlayList
  LSP: Convex: Backpack: 
  LSP: Convex: Base: playlist ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  if  let  playlist type  update
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):19.5788
 @:15.5865
,:14.1034
 ++:14.0793
 +:12.9409
.:12.6079
)):12.5877
:::12.417

:12.3883
),:12.1917
);:12.1241
 :::12.1171
@:11.9332
 ):11.9066
 :11.8909
 |:11.8453
).:11.0866
 ||:11.0073
;:10.8448
)$:10.6696
++:10.6466

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.7059
 :15.444
  :13.8776
        :13.8585
 end:13.7511
      :12.9809
    :12.8942
   :12.6413
 in:12.3522
            :11.6486
          :11.5746
                :11.5241
     :10.7729
end:10.7107
         :10.6336
       :10.622
 @:10.5775
           :10.1861
 #:10.1574
              :10.1018
             :9.8176

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.172
in:16.1266
end:16.0538
 :14.9593
     :13.8369
  :12.8528
    :12.7341

:12.5633
       :12.4313
        :11.7968
      :11.5817
 end:11.5436
 in:11.4919
         :10.6803
let:9.95148
           :9.90612
#:9.76966
```:9.75148
          :9.66694
}:9.59925
	:9.39032

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
   

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
   
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: PlayList
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:21.2014
 in:15.3586
 #:13.4076
 else:11.9501
 with:11.9404
 es:11.5294
 case:11.1786
 return:11.0633
 match:11.0217
 where:10.9535
 (*:10.9348
 fun:10.6437
 ::10.6329
 }:10.6001
 |:10.6
 End:10.4769
 pass:10.2336

:10.2264
 ):10.2175
 (:10.2014
 if:10.0088

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
    end

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
    end
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ((PlayList, PlayListAction) -> PlayList)
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "in"
root ::= new-tokens

Top 20 Logits:

:19.0435
 :17.4395
  :15.5588
 in:15.1848
    :14.7104
      :13.4869
        :13.4241
;:12.8167
 #:12.7281
   :12.6589
 end:12.2763
                :12.2063
in:11.7334
            :11.6619
          :11.6174
     :11.3943
	:11.2329
         :11.2115
       :10.903
           :10.4181
              :10.3789

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
    end


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
    end

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
    end
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ((PlayList, PlayListAction) -> PlayList)
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "in"
root ::= new-tokens

Top 20 Logits:
in:19.5301
end:14.6893
 :14.5349

:14.1535
#:13.2854
    :13.0339
  :12.984
 in:12.7899
   :12.3629
let:12.2816
test:11.524
      :11.4809
        :11.2141
```:11.2019
type:11.0552
     :10.528
       :10.0596
                :9.79717
|:9.71964
            :9.70648
with:9.62063

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
    end
in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
    end
in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
    end

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update get_current_song get_songs string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_current_song" | "get_songs" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:16.7403
 :13.9379
  :11.4181
 test:11.3021
    :11.0738
      :9.86659
        :9.64803
   :9.39398
 #:9.37467
                :9.34338
 {:8.86161
          :8.80892
            :8.79616
     :8.4843
       :8.35405
`;:8.01422
 update:7.99577
         :7.95323
              :7.92441
           :7.83179
	:7.7827

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
    end
in


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
    end
in

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  + AddSong(Id)
in

# A playlist with a list of songs and the id for the currently playing/paused song #
# -1 if none is playing #
type PlayList = ([Id], Id) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_current_song: PlayList -> Id =
  fun playlist ->
    let songs, current = playlist in
    current
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) =>
        let songs, _ = playlist in
        (playlist)
      | PauseCurrentSong =>
        let songs, current = playlist in
        (playlist)
      | RemoveSong(id) =>
        let songs, current = playlist in
        (playlist)
      | AddSong(id) =>
        let songs, current = playlist in
        (playlist)
    end
in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((PlayList, PlayListAction) -> PlayList), get_current_song: (PlayList -> Id), get_songs: (PlayList -> [Id]), PlayList:: ([Id], Id), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update get_current_song get_songs string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddSong PauseCurrentSong PlaySong RemoveSong [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_current_song get_songs if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_current_song" | "get_songs" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.9816
test:16.0976
#:15.7369
let:15.3786
type:14.8253
```:13.7033
 :13.1101
    :12.9515
  :12.6473
assert:12.041
end:12.0352
":11.9285
module:11.813
"":11.8129
in:11.5556
        :11.5491
Play:11.2699
                :11.1799
(*:11.1436
play:11.1253
get:11.0913
