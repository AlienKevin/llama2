
================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:18.0697
 :15.0707
 fun:14.2534
  :12.0746
fun:11.2306
   :11.1903
 (:11.1319
    :10.9975
 List:10.6461
 function:10.3626
                :10.3122
 #:10.1413
 ?:9.34299
     :9.31862
 <:9.23224
 {:9.11713
        :8.89832
 let:8.67923
 (*:8.63886
       :8.6329
	:8.60318

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
   :19.8947
 :19.0862
fun:17.3502
  :15.003
       :14.1693
	:14.0968
 fun:14.0568
     :13.7557
let:13.5536
    :12.6582
func:12.6104
(:12.3307
 let:12.0991
#:11.3035
           :11.2731

:10.8988
      :10.7479
         :10.6691
fn:10.6307
                :10.4572
{:10.3614

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
   

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
   
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:18.6341
 let:15.554
 List:13.528
 #:13.4316
 (:12.7432
 if:12.0281
 ~:11.5805
 (*:11.2337
 @:11.2336
 case:11.1949
 match:11.1723
 remove:10.7276
 func:10.3159
 \:10.204
 list:10.1646
 f:10.1296
 |:9.92044
 Int:9.91461
 {:9.80412
 lambda:9.72791
 *:9.63565

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
 idx:18.0509
 i:16.5805
 index:16.2406
 n:15.3984
 id:14.1731
 ind:14.074
 (:13.9662
 x:13.5989
 pos:13.5235
 todo:12.5727
 k:12.392
 at:12.3238
(:12.0041
 number:11.9975
 target:11.9534
 num:11.7319
 key:11.6285
 to:11.4933
 position:11.2428
 remove:11.2407
 t:11.2263

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, [Todo]), remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:18.1504
 ->:13.4827
 xs:13.4772
 ,:12.543
 todo:12.3526
 list:12.2329
 l:12.121
 todos:11.9708
_:11.9635
 ts:11.5091
1:11.4638
 to:10.9782
 lst:10.787
 t:10.7712
 ls:10.2528
0:10.2443
 =>:9.77269
 x:9.76432
 items:9.73535
_,:9.62451
::9.61175

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 xs:15.5137
 todos:15.279
 todo:15.115
 ts:14.4236
 l:14.0121
 list:13.3599
 items:12.769
 lst:12.4833
 t:12.1594
 ls:11.9815
 x:11.584
 tod:11.344
 to:10.8457
 rest:10.4236
 acc:9.87351
 y:9.83371
 td:9.70521
 _:9.57135
 old:9.49121
 state:9.47601
 arr:9.41847

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.69
->:15.211
 :12.846
 =>:12.4921
0:12.1395

:11.8884
,:11.6785
 in:11.3893
 =:11.3064
':10.5071
_:10.4954
1:10.304
  :10.2009
 -:10.1573
 |:10.0848
 when:9.73306
=:9.6902
::9.36804
 ~:8.9949
 -->:8.98701
 as:8.95939

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "if " | "let " | "remove" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | "xs" | stringlit
root ::= new-tokens

Top 20 Logits:

:17.182
 List:15.8207
 :14.1945
 if:11.9062
  :11.7202
 case:11.665
 xs:11.5846
 list:11.4124
    :11.2294
 let:11.0163
 [:11.0149
 (:10.8971
 #:10.5886
 idx:10.2352
                :10.0679
 x:10.0523
        :9.76164
   :9.67397
 String:9.53519
 {:9.51277
     :9.49991

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "if " | "let " | "remove" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | "xs" | stringlit
root ::= new-tokens

Top 20 Logits:
       :18.479
   :16.9236
     :14.5739
           :13.0856
    :12.8995
      :12.7353
case:12.1331
        :12.1042
if:11.7545
 :11.199
let:11.1849
         :11.1218
  :11.0897
	:11.0679
#:11.0126
               :10.8784

:10.3804
                :10.142
          :9.51477
List:9.30789
            :9.20317

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
       

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
       
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "if " | "let " | "remove" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | "xs" | stringlit
root ::= new-tokens

Top 20 Logits:
 case:17.2766
 let:16.8683
 List:16.6937
 if:16.0546
 #:13.9289
 match:13.6258
 list:11.4806
 assert:11.4609
 (:11.2795
 todo:11.1009
 xs:10.7165
 go:10.4791
 Array:9.98824
 [:9.86779
 (*:9.73856
 fol:9.68737
 idx:9.65345
 String:9.56701
 t:9.56287
 @:9.31672
 x:9.25463

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx remove Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:16.61
 List:15.5538
 idx:14.6937
 Int:12.7251
 int:12.0603
 list:11.8942
 (:11.522
 x:10.9681
 t:10.8935
 range:10.5547
 :10.3966
xs:10.0876
 Array:10.0155

:9.94971
 filter:9.93878
 i:9.85127
 id:9.74261
 rev:9.63965
 drop:9.61925
 reverse:9.58212
 Integer:9.56836

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx remove Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.5397
 of:16.3289
,:16.1813
 :16.0443
 |:14.1922
  :13.3624
    :12.9348
 before:12.0383
 #:11.9782
[:11.7623
        :11.6619
                :11.6135
 with:11.5336
 ,:11.3065
     :11.147
   :11.0704
.:11.0434
 <:11.0223
 @:11.0172
            :10.9053
      :10.8692

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :20.1978
           :18.656
         :16.7977
        :15.4729
   :15.2974
     :14.7972
            :14.268
          :14.2383
      :13.7602
               :13.7273
	:13.3061
             :13.1383
    :13.0129
#:12.6152
                :12.5313
|:12.4555

:12.0907
              :11.563
  :11.443
 |:11.312
 :10.8968

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
       

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
       
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:23.4783
 #:17.4082
 when:13.6243
 (*:12.4311
 ||:12.1497
 ##:11.792
 #[:11.6883
 if:11.3413
 @:11.2643
 of:11.2388
 let:11.1887
 ,:11.0359
 match:10.9444
 *:10.9314
 <:10.8057
 []:10.7287
 idx:10.7063
 ~:10.5456
 -:10.5085
 //:10.4974
 #(:10.4014

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        |

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        |
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 []:18.8426
 x:15.2136
 _:15.0603
 h:14.5137
 y:13.7051
 t:12.8033
 l:12.5453
 todo:12.2517
 [:12.0311
 (:11.5273
 ts:11.4102
[]:11.3847
 xs:10.9665
 td:10.9378
 list:10.8514
 :10.6391
 (_:10.4055
 i:10.4041
 a:10.4008
 before:10.385
 head:10.2884

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | []

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | []
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ":" | "::" | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.7376
=>:13.3069
 when:13.0656
 ->:13.0111
    :12.7183
 :12.467
  :12.3886
     :12.1653
      :12.1393
 if:11.9301
         :11.9131
 :=:11.839
                :11.806
        :11.7745
   :11.5245
          :11.5124
           :11.4234
 :::11.3195
 ||:11.1429
            :11.0848
             :11.0264

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] =>

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] =>
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | []
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "if " | "let " | "remove" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | "xs" | stringlit
root ::= new-tokens

Top 20 Logits:
 []:16.6227
 xs:14.4694
 fail:13.8827
 raise:13.4926
 assert:12.3489
 error:12.2475
 abort:12.1824
 List:11.9257

:11.7353
 :10.9646
 [:10.5862
 if:10.3353
 die:9.97176
 x:9.92941
 exit:9.63124
 throw:9.58206
 #:9.41113
 !:9.36976
 nil:9.27074
 todo:9.27011
 Error:9.16972

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.1404
 :14.5882
 #:14.1469
  :13.6341
    :13.2882
        :12.6859
 (*:12.4686
                :12.2792
      :11.8025
     :11.7696
            :11.6657
   :11.5988
 |:11.4455
         :11.0042
           :10.8671
       :10.7576
          :10.7189
             :10.6863
 @:10.5747
               :10.2029
              :10.0742

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :20.8726
        :14.51
           :14.4102
   :14.1481

:13.7572
#:13.6916
	:13.69
      :13.4304
         :13.032
     :12.9242
    :12.8544
            :12.5436
          :12.1525
                :11.9928
  :11.9668
|:11.8092
               :11.5304
 :10.9365
             :10.6906
(*:10.4797
              :10.0547

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
       

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
       
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.1
 #:17.9714
 when:13.0001
 (*:12.6796
 ##:12.3634
 end:11.8141
 #{:11.7965
 #[:11.7934
 if:11.6318
 #(:11.4104
 <:11.3799
 ~:11.2942
 _:11.0609
 ||:10.9755
 @:10.9635
 x:10.7809
 //:10.7805
 !:10.7527
 +:10.6718
 (:10.667
 |\:10.665

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        |

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        |
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 x:16.9522
 h:16.528
 _:16.2214
 y:15.6374
 t:13.6601
 head:13.5053
 first:12.4377
 z:12.3069
 todo:12.0623
 td:11.9438
 [:11.9329
 item:11.8286
 (:11.3294
 [_:11.3031
 l:10.979
 a:10.9595
 f:10.9039
 el:10.833
 e:10.7501
 list:10.4305
 ts:10.4243

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: [Todo], xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new-tokens

Top 20 Logits:
:::20.7155
 :::14.9901
1:14.0159
h:13.0133
0:12.6839
 when:12.4762
_:12.0802
@:11.858
hd:11.1448
':11.0476
xs:11.0006
d:10.9906
,:10.7957
::10.5217
__:10.3371
i:10.1691
2:10.161
 as:10.0035
|:9.94892
head:9.93341
xx:9.9005

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
xs:18.5285
rest:14.1788
tl:14.1619
ys:13.5786
y:12.6219
[]:12.61
tail:12.3694
_:11.2026
t:11.1917
l:11.1666
x:11.1612
ts:10.9972
zs:10.9085
xx:10.3993
xt:10.3959
xl:10.2632
 xs:10.2147
(:10.1451
tx:9.85423
rem:9.85301
[:9.45248

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new-tokens

Top 20 Logits:
 =>:18.1698
 when:17.0894
 ->:15.4862
':14.7115
 if:14.0691
1:13.5811
2:13.455
=>:12.3227
_:12.1963
 :11.9571
 as:11.755
->:11.4713

:11.4616
0:10.828
  :10.7332
 :=:10.6704
 |:10.4665
 :::10.3961
 where:10.2299
 =:10.1643
 @:10.0232

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs =>

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs =>
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  x xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "if " | "let " | "remove" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | "x" | "xs" | stringlit
root ::= new-tokens

Top 20 Logits:
 if:18.8632

:16.8671
 :15.2814
 List:13.6759
 (:12.4241
 let:12.1116
 case:11.9073
  :11.8589
 idx:11.2616
    :10.993
 [:10.9875
 #:10.9492
if:10.3161
 x:10.2031
        :10.0475
   :9.99835
 match:9.87046
 remove:9.76743
                :9.76633
     :9.57206
 index:9.55512

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "Bool.eq" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "Model.eq" | "Model.get_buffer" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 idx:17.7969
 :14.3031
 List:13.7246
 (:12.7106
 Int:12.648
(:11.2197
 xs:11.0395
 x:10.9645
 i:10.8236
 String:10.6929
 length:10.4864
 !:10.4571
idx:10.3347
 int:10.3314
 id:10.2851
 eq:10.2706
 string:10.1241
 index:10.1228
 Integer:9.67044

:9.50854
 list:9.49607

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: == != <= >= < >
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: idx
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= new-tokens

Top 20 Logits:
 ==:19.9181
 =:17.5915
 <=:17.1982
 >:16.867
 $:16.523
 <:16.4041
 ===:15.212
 >=:14.5179
 !=:14.1423
 -:13.6641
==:13.1599
 <>:13.0156
 :12.9905
$:12.5166
=:12.2177
 then:11.6269
 %:11.1864
 +:10.9618
 !:10.8127
.:10.6126
 eq:10.5752

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx ==

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx ==
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: ==
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= completions | new-tokens

Top 20 Logits:
 :21.9099
 -:13.8503
0:13.8367
  :12.6972
?:12.3207
 Int:12.2783
!:12.2002
 List:12.1504
 length:12.1089
 zero:11.6882
 (:11.6784
 $:11.351
#:10.7733
~:10.525
@:10.4713
 [:10.4329
 ":10.3759
 i:10.3748
 list:10.3586
 string:9.94621
 ~:9.93048

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx ==
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
0:27.9045
1:23.8132
2:17.0836
3:16.1739
4:15.6837
5:15.2196
9:14.9993
7:13.9494
6:13.3522
8:13.1795

:11.4758
 -:11.3934
nd:10.6304
	:10.2034
 #:9.92398
 (:9.88567
 //:9.03021
 !:8.99235
:8.82222
 {:8.62271
​:8.57839

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 0
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 then:20.8551

:15.0549
 :14.5575
 ||:11.9049
 &&:11.7276
 ?:10.9307
then:10.3665
 x:10.1135
 {:9.93628
 Then:9.9204
  :9.88221
 THEN:9.53339
 else:9.36865
x:9.3536
 #:9.27819
.:9.22316
 (:9.13495
 the:9.13081
 [:8.98762
    :8.82018
?:8.43259

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  x xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "if " | "let " | "remove" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | "x" | "xs" | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:17.1835
 List:15.8953
 remove:14.448

:13.3803
 :12.3513
 (:11.6776
 x:11.5821
 #:10.337
 []:10.3131
 t:10.1372
 [:10.1166
 list:10.0689
xs:9.59067
 return:9.50041
 rest:9.40461
 Model:9.07285
 delete:9.03509
 rm:9.03313
 rs:8.85515
 todo:8.83071
 _:8.79323

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  x xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:
 else:21.0595

:15.1195
 =:13.7327
 :13.5616
 @:12.9871
 elif:12.7935
 |:11.0325
 els:11.0186
[:10.8838
=:10.6264
 #:10.6253
.:10.5568
    :10.4388
  :10.4274
@:10.1078
                :9.97566
;:9.858
      :9.85084
     :9.82861
 end:9.7361
 otherwise:9.72485

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  x xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "if " | "let " | "remove" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | "x" | "xs" | stringlit
root ::= new-tokens

Top 20 Logits:
 x:17.7817
 List:15.1544
 [:13.7058
 remove:13.6063
 (:13.523
 let:12.6098

:12.5083
 :11.9059
 h:10.8189
 head:10.7518
 @:10.3681
 f:10.3341
 {:10.3112
 Cons:9.84732
 todo:9.50836
 list:9.4368
 get:9.43308
 <:9.17688
 [(:9.14994
 Array:9.12566
 Tod:8.96402

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: Todo
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo")); syn = (Var "Todo")})))
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x
Nature of error: Expecting type [Todo] but got inconsistent type Todo
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Todo
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: x
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  x xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "::" | "end" | "|"
root ::= completions | new-tokens

Top 20 Logits:
:::19.6751
 :::19.5094
 ::13.4579
::12.2486
 @:12.2406
 +:11.845
:(:11.4058
@:11.2772
.:11.1957
 ++:10.4995
,:10.3853
 :=:10.2302
(:9.63949
 =:9.52886
 $:9.45813
 //:9.37236

:9.20646
 ^:9.18446
 :9.15746
:@:9.1384
@@:9.09845

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  x xs ~STRINGLIT~
LSP: Generating Completions for prefix: ::
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  x xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "if " | "let " | "remove" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | "x" | "xs" | stringlit
root ::= new-tokens

Top 20 Logits:
remove:19.4981
(:16.5946
List:15.8722
 remove:12.994
Model:12.6665
Remove:11.9134
 List:11.6938
 (:10.9607
rem:10.7568
[:10.2174
rest:10.1461
rm:10.0542
delete:10.0318
get:9.96404
((:9.84139
xs:9.80251
T:9.78034
Array:9.53322
t:9.26088
tail:9.1925
list:9.17036

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <remove>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo"));
           syn =
           (Arrow ((Prod [Int; (List (Var "Todo"))]), (List (Var "Todo"))))})))
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  remove
Nature of error: Expecting type [Todo] but got inconsistent type ((Int, [Todo]) -> [Todo])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: remove
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Int, [Todo]) -> [Todo])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: remove
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  x xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:23.3606
((:17.3234
 (:16.4054
_:13.9434
(-:13.4881
(@:13.2876
_(:12.838
([:12.6645
 ((:12.2425
.(:11.732
($:11.3748
():11.2495
'(:11.2008
({:11.1431
!(:11.0243
($(:10.8522
[:10.8355
 idx:10.8318
2:10.8267
(!:10.6209
(_:10.2811

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, [Todo])
Int <= (Int, [Todo])
Int <= (Int, [Todo])
  LSP: Convex: Target types: Int, (Int, [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  x xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
idx:22.6961
pred:13.5324
1:13.4967
x:13.4643
i:13.153
dec:13.0939
 idx:13.0057
if:12.6007
xs:12.5854
index:11.8564
id:11.7204
List:11.6003
minus:11.5133
int:11.2153
Int:11.1239
n:11.063
0:10.9283
--:10.8089
su:10.6957

:10.5508
ix:10.5021

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (List (Var "Todo"))]); syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: idx
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Int, [Todo])
Int <= (Int, [Todo])
Int <= (Int, [Todo])
  LSP: Convex: Target types: Int, (Int, [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "," | "-" | "/"
root ::= new-tokens

Top 20 Logits:
 -:21.1008
-:18.1065
 +:14.4495
 $:12.8729
,:12.7169
 =:11.7794
 –:11.5781
+:11.4377
 $-:11.4287
--:11.3487
$:11.2811
-$:11.2204
 −:11.0507
 :11.0073
 --:10.8929
 -=:10.7666
-(:10.18
$-:9.36954
.:9.26074
 @:9.24781
 /:9.24141

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx -

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx -
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >-<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Subtraction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (List (Var "Todo"))]); syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  idx - ?
Nature of error: Expecting type (Int, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Integer Subtraction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (List (Var "Todo"))]); syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  idx - ?
Nature of error: Expecting type (Int, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  idx - ?
Nature of error: Expecting type (Int, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: -
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: -
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Int, [Todo])
Int <= (Int, [Todo])
Int <= (Int, [Todo])
  LSP: Convex: Target types: Int, (Int, [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 :20.1222
1:16.5512
  :12.4365
 i:10.6386
 List:10.2922
.:10.1673
 (:9.8201

:9.77759
!:9.74386
 x:9.73687
 $:9.56791
 length:9.46479
 Int:9.26324
$:8.979
 !:8.9041
,:8.76882
%:8.6873
+:8.53372
&:8.50747
@:8.48666
 +:8.4327

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx -
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >-<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  idx - ?
Nature of error: Expecting type (Int, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
1:28.706
2:16.8329
0:16.6803
3:13.3289

:13.2306
9:13.1298
5:12.9765
8:12.4454
4:12.1076
6:11.8823
7:11.811
	:11.5337
 toggle:10.2439
xt:9.06136
toggle:8.84951
​:8.71229
 #:8.63873
nd:8.55027
１:8.50984
₁:8.48972
 {:8.0866

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  idx - 1
Nature of error: Expecting type (Int, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 1
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "," | "-" | "/"
root ::= completions | new-tokens

Top 20 Logits:
,:19.69
 ,:14.742
):13.6993
)(:11.3564
 xs:11.018
 :::10.7496
 $:10.2616
:::10.012
$:9.75748
,$:9.63413
 +:9.60118
;:9.57875
.:9.25327
 :9.05676
)$:8.96943
 -:8.9515
),:8.92788
 |:8.88156
)):8.54322
);:8.42155
 $$:8.41916

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  x xs ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Int, [Todo])
Int <= (Int, [Todo])
Int <= (Int, [Todo])
  LSP: Convex: Target types: Int, (Int, [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "if " | "let " | "remove" | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "type " | "x" | "xs" | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:20.821
 t:13.572
xs:13.4458
 ts:13.2028
 List:12.4992
 :12.4329
 y:12.0773
 rest:11.8214
 x:11.4182
 tail:11.2993
 list:11.0125
 [:10.7581
 ls:10.7353

:10.5765
 (:10.4697
 remove:10.395
 l:10.0988
 todo:10.089
 _):9.87441
 $:9.67239
 X:9.58422

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  if  let  remove string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string type  x xs ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
):23.0014
 end:14.8915
)):14.8367
);:14.578
 ):13.6475
)]:12.9587
)::12.3078
).:11.9617
)[:11.8261

:11.8147
)}:11.7551
));:11.041
))):11.0157
),:10.9617
)(:10.8946
)`:10.6499
)_:10.5873
,:10.3692
)))):10.2903
)>:10.2042
)":10.1458

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], x: Todo, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:17.5676

:15.5009
 in:12.9038
 :12.2198
end:10.9771
  :10.5552
    :9.53481
   :9.40952
        :8.93896
                :8.71094
      :8.61913
     :8.59985
 done:8.36273
 else:8.29762
 #:8.28497
            :8.14594
       :7.56163
          :7.52688
         :7.43369
 |:7.20671
 (*:7.08245

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs) end

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs) end
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Int, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:

:17.4499
 in:17.3579
 :13.5646
 end:12.5782
  :12.447
    :11.7563
        :10.8058
   :10.7795
;:10.7618
in:10.6535
                :9.92918
     :9.89267
      :9.8673
 #:9.19586
       :9.12328
            :9.12264
         :8.95848
          :8.66814
           :8.13304
):7.98363
	:7.96032

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs) end


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs) end

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs) end
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Int, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:
in:21.8646
   :15.9135

:15.7427
#:14.9251
       :14.7979
    :14.5106
        :14.4157
 in:14.0375
end:13.3238
  :13.1088
           :13.0237
     :12.8005
            :12.6603
                :12.5956
      :12.5159
 :12.495
let:11.9625
               :11.6666
         :11.6537
and:11.3765
          :11.0587

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs) end
in

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs) end
in
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs) end

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: remove Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.5534
 :14.8223
    :14.1536
  :13.946
        :13.0341
                :12.6287
      :11.9528
   :11.6507
            :11.646
     :11.6363
 let:10.9337
 #:10.9033
       :10.6046
             :10.4733
          :10.4574
         :10.4142
           :10.276
	:10.0508
              :10.04
#:9.57355
 {:9.55352

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs) end
in


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs) end
in

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
    fun idx, xs ->
        case xs
        | [] => []
        | x::xs => if idx == 0 then xs else x::remove(idx - 1, xs) end
in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {remove: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), List.filter: (((Int -> Bool), [Int]) -> [Int]), List.fold_right: ((((Int, Int) -> Int), [Int], Int) -> Int), List.fold_left: ((((Int, Int) -> Int), Int, [Int]) -> Int), List.init: ((Int, (Int -> Int)) -> [Int]), List.eq: (([Int], [Int]) -> Bool), List.rev: ([Int] -> [Int]), List.is_empty: ([Int] -> Bool), List.tl: ([Int] -> [Int]), List.length: ([Int] -> Int), List.cons: ((Int, [Int]) -> [Int]), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: remove Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq parse_term term_to_string String.transform String.reverse String.starts_with List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:21.3068
#:18.5986
    :17.47
        :16.8547
  :15.8879
            :15.6515
                :15.3625
let:15.0712
 :14.7832
      :14.1935
     :13.8163
   :13.7449
          :13.3904
         :13.2474
       :13.1698
           :13.1543
             :13.0245
              :12.9725
	:12.5975
               :12.2344
 #:12.219
