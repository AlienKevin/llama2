

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | Add


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id'


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id ==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlayS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id'


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id ==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl




================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | Pause


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrent


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end




================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | Remove


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id'


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id ==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x ==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current_state)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current_state) else


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current_state) else pl


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current_state) else pl



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current_state) else pl
 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current_state) else pl
  end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current_state) else pl
  end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current_state) else pl
  end
in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then pl
      else (songs @ [id], current_state)
  
  | PlaySong(id) =>
      let songs, _ = pl in
      if List.contains((fun id' -> id == id'), songs) then (songs, Playing(id)) else pl

  | PauseCurrentSong =>
      case get_state(pl)
        | NoSongSelected => pl
        | Playing(id) => (get_songs(pl), PausedOn(id))
        | PausedOn(_) => pl
      end

  | RemoveSong(id) =>
      let songs, current_state = pl in
      if List.contains((fun id' -> id == id'), songs) then (List.filter((fun id -> not ((fun x -> x == id)(id))), songs), current_state) else pl
  end
in


